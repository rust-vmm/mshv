/* automatically generated by rust-bindgen 0.71.1 */
/*
 * Kernel (uapi) headers used for these bindings are as follows:
 * include/linux/mshv.h
 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const HVGDK_MINI_H_VERSION: u32 = 25294;
pub const HV_STATUS_SUCCESS: u32 = 0;
pub const HV_STATUS_INVALID_HYPERCALL_CODE: u32 = 2;
pub const HV_STATUS_INVALID_HYPERCALL_INPUT: u32 = 3;
pub const HV_STATUS_INVALID_ALIGNMENT: u32 = 4;
pub const HV_STATUS_INVALID_PARAMETER: u32 = 5;
pub const HV_STATUS_ACCESS_DENIED: u32 = 6;
pub const HV_STATUS_INVALID_PARTITION_STATE: u32 = 7;
pub const HV_STATUS_OPERATION_DENIED: u32 = 8;
pub const HV_STATUS_UNKNOWN_PROPERTY: u32 = 9;
pub const HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE: u32 = 10;
pub const HV_STATUS_INSUFFICIENT_MEMORY: u32 = 11;
pub const HV_STATUS_INVALID_PARTITION_ID: u32 = 13;
pub const HV_STATUS_INVALID_VP_INDEX: u32 = 14;
pub const HV_STATUS_NOT_FOUND: u32 = 16;
pub const HV_STATUS_INVALID_PORT_ID: u32 = 17;
pub const HV_STATUS_INVALID_CONNECTION_ID: u32 = 18;
pub const HV_STATUS_INSUFFICIENT_BUFFERS: u32 = 19;
pub const HV_STATUS_NOT_ACKNOWLEDGED: u32 = 20;
pub const HV_STATUS_INVALID_VP_STATE: u32 = 21;
pub const HV_STATUS_NO_RESOURCES: u32 = 29;
pub const HV_STATUS_PROCESSOR_FEATURE_NOT_SUPPORTED: u32 = 32;
pub const HV_STATUS_INVALID_LP_INDEX: u32 = 65;
pub const HV_STATUS_INVALID_REGISTER_VALUE: u32 = 80;
pub const HV_STATUS_OPERATION_FAILED: u32 = 113;
pub const HV_STATUS_TIME_OUT: u32 = 120;
pub const HV_STATUS_CALL_PENDING: u32 = 121;
pub const HV_STATUS_VTL_ALREADY_ENABLED: u32 = 134;
pub const HV_HYP_PAGE_SHIFT: u32 = 12;
pub const HV_HYP_PAGE_SIZE: u32 = 4096;
pub const HV_HYP_PAGE_MASK: i32 = -4096;
pub const HV_HYP_LARGE_PAGE_SHIFT: u32 = 21;
pub const HV_MAXIMUM_PROCESSORS: u32 = 320;
pub const HV_MAX_VP_INDEX: u32 = 319;
pub const HVCALL_GET_PARTITION_PROPERTY: u32 = 68;
pub const HVCALL_SET_PARTITION_PROPERTY: u32 = 69;
pub const HVCALL_INSTALL_INTERCEPT: u32 = 77;
pub const HVCALL_CREATE_VP: u32 = 78;
pub const HVCALL_DELETE_VP: u32 = 79;
pub const HVCALL_GET_VP_REGISTERS: u32 = 80;
pub const HVCALL_SET_VP_REGISTERS: u32 = 81;
pub const HVCALL_TRANSLATE_VIRTUAL_ADDRESS: u32 = 82;
pub const HVCALL_READ_GPA: u32 = 83;
pub const HVCALL_WRITE_GPA: u32 = 84;
pub const HVCALL_CLEAR_VIRTUAL_INTERRUPT: u32 = 86;
pub const HVCALL_REGISTER_INTERCEPT_RESULT: u32 = 145;
pub const HVCALL_ASSERT_VIRTUAL_INTERRUPT: u32 = 148;
pub const HVCALL_SIGNAL_EVENT_DIRECT: u32 = 192;
pub const HVCALL_POST_MESSAGE_DIRECT: u32 = 193;
pub const HVCALL_IMPORT_ISOLATED_PAGES: u32 = 239;
pub const HVCALL_COMPLETE_ISOLATED_IMPORT: u32 = 241;
pub const HVCALL_ISSUE_SNP_PSP_GUEST_REQUEST: u32 = 242;
pub const HVCALL_GET_VP_CPUID_VALUES: u32 = 244;
pub const HV_INTERRUPT_VECTOR_NONE: u32 = 4294967295;
pub const HV_SYNIC_STIMER_COUNT: u32 = 4;
pub const HV_MESSAGE_SIZE: u32 = 256;
pub const HV_MESSAGE_PAYLOAD_BYTE_COUNT: u32 = 240;
pub const HV_MESSAGE_PAYLOAD_QWORD_COUNT: u32 = 30;
pub const HV_INTERCEPT_ACCESS_MASK_NONE: u32 = 0;
pub const HV_INTERCEPT_ACCESS_MASK_READ: u32 = 1;
pub const HV_INTERCEPT_ACCESS_MASK_WRITE: u32 = 2;
pub const HV_INTERCEPT_ACCESS_MASK_EXECUTE: u32 = 4;
pub const HV_INTERCEPT_ACCESS_READ: u32 = 0;
pub const HV_INTERCEPT_ACCESS_WRITE: u32 = 1;
pub const HV_INTERCEPT_ACCESS_EXECUTE: u32 = 2;
pub const HVGDK_H_VERSION: u32 = 25125;
pub const HVHVK_MINI_VERSION: u32 = 25294;
pub const HV_GENERIC_SET_SHIFT: u32 = 6;
pub const HV_GENERIC_SET_MASK: u32 = 63;
pub const HV_MAP_GPA_PERMISSIONS_NONE: u32 = 0;
pub const HV_MAP_GPA_READABLE: u32 = 1;
pub const HV_MAP_GPA_WRITABLE: u32 = 2;
pub const HV_MAP_GPA_KERNEL_EXECUTABLE: u32 = 4;
pub const HV_MAP_GPA_USER_EXECUTABLE: u32 = 8;
pub const HV_MAP_GPA_EXECUTABLE: u32 = 12;
pub const HV_MAP_GPA_PERMISSIONS_MASK: u32 = 15;
pub const HV_MAP_GPA_ADJUSTABLE: u32 = 32768;
pub const HV_MAP_GPA_NO_ACCESS: u32 = 65536;
pub const HV_MAP_GPA_NOT_CACHED: u32 = 2097152;
pub const HV_MAP_GPA_LARGE_PAGE: u32 = 2147483648;
pub const HV_PFN_RNG_PAGEBITS: u32 = 24;
pub const HVHDK_H_VERSION: u32 = 25212;
pub const HV_X64_REGISTER_CLASS_GENERAL: u32 = 0;
pub const HV_X64_REGISTER_CLASS_IP: u32 = 1;
pub const HV_X64_REGISTER_CLASS_XMM: u32 = 2;
pub const HV_X64_REGISTER_CLASS_SEGMENT: u32 = 3;
pub const HV_X64_REGISTER_CLASS_FLAGS: u32 = 4;
pub const HV_VP_REGISTER_PAGE_VERSION_1: u32 = 1;
pub const HV_VP_REGISTER_PAGE_MAX_VECTOR_COUNT: u32 = 7;
pub const HV_PARTITION_SYNTHETIC_PROCESSOR_FEATURES_BANKS: u32 = 1;
pub const HV_TRANSLATE_GVA_VALIDATE_READ: u32 = 1;
pub const HV_TRANSLATE_GVA_VALIDATE_WRITE: u32 = 2;
pub const HV_TRANSLATE_GVA_VALIDATE_EXECUTE: u32 = 4;
pub const HV_TRANSLATE_GVA_SET_PAGE_TABLE_BITS: u32 = 16;
pub const HV_TRANSLATE_GVA_TLB_FLUSH_INHIBIT: u32 = 32;
pub const HV_TRANSLATE_GVA_SUPERVISOR_ACCESS: u32 = 64;
pub const HV_TRANSLATE_GVA_USER_ACCESS: u32 = 128;
pub const HV_TRANSLATE_GVA_PAN_SET: u32 = 256;
pub const HV_TRANSLATE_GVA_PAN_CLEAR: u32 = 512;
pub const HV_PSP_CPUID_LEAF_COUNT_MAX: u32 = 64;
pub const HV_READ_WRITE_GPA_MAX_SIZE: u32 = 16;
pub const HV_PARTITION_PROCESSOR_FEATURES_BANKS: u32 = 2;
pub const MSHV_IOCTL: u32 = 184;
pub const MSHV_VP_MAX_REGISTERS: u32 = 128;
pub const MSHV_NUM_CPU_FEATURES_BANKS: u32 = 2;
pub const MSHV_HV_PAGE_SIZE: u32 = 4096;
pub const MSHV_RUN_VP_BUF_SZ: u32 = 256;
pub const MSHV_CREATE_DEVICE_TEST: u32 = 1;
pub const MSHV_DEV_VFIO_FILE: u32 = 1;
pub const MSHV_DEV_VFIO_FILE_ADD: u32 = 1;
pub const MSHV_DEV_VFIO_FILE_DEL: u32 = 2;
pub const MSHV_DIAG_IOCTL: u32 = 185;
pub const MSHV_TRACE_IOCTL: u32 = 186;
pub type bool_ = bool;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::std::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::std::mem::align_of::<__kernel_fd_set>() - 8usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::std::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::std::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::std::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::std::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type hv_nano100_time_t = __u64;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_u128 {
    pub low_part: __u64,
    pub high_part: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_u128"][::std::mem::size_of::<hv_u128>() - 16usize];
    ["Alignment of hv_u128"][::std::mem::align_of::<hv_u128>() - 1usize];
    ["Offset of field: hv_u128::low_part"][::std::mem::offset_of!(hv_u128, low_part) - 0usize];
    ["Offset of field: hv_u128::high_part"][::std::mem::offset_of!(hv_u128, high_part) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_gpa_page_range {
    pub address_space: __u64,
    pub page: hv_gpa_page_range__bindgen_ty_1,
    pub __bindgen_anon_1: hv_gpa_page_range__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_gpa_page_range__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_gpa_page_range__bindgen_ty_1"]
        [::std::mem::size_of::<hv_gpa_page_range__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_gpa_page_range__bindgen_ty_1"]
        [::std::mem::align_of::<hv_gpa_page_range__bindgen_ty_1>() - 8usize];
};
impl hv_gpa_page_range__bindgen_ty_1 {
    #[inline]
    pub fn additional_pages(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_additional_pages(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn additional_pages_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                11u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_additional_pages_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn largepage(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_largepage(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn largepage_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_largepage_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn basepfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_basepfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn basepfn_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                52u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_basepfn_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                52u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        additional_pages: __u64,
        largepage: __u64,
        basepfn: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let additional_pages: u64 = unsafe { ::std::mem::transmute(additional_pages) };
            additional_pages as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let largepage: u64 = unsafe { ::std::mem::transmute(largepage) };
            largepage as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let basepfn: u64 = unsafe { ::std::mem::transmute(basepfn) };
            basepfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_gpa_page_range__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_gpa_page_range__bindgen_ty_2"]
        [::std::mem::size_of::<hv_gpa_page_range__bindgen_ty_2>() - 8usize];
    ["Alignment of hv_gpa_page_range__bindgen_ty_2"]
        [::std::mem::align_of::<hv_gpa_page_range__bindgen_ty_2>() - 8usize];
};
impl hv_gpa_page_range__bindgen_ty_2 {
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn page_size(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_page_size(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn page_size_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_page_size_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn base_large_pfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 43u8) as u64) }
    }
    #[inline]
    pub fn set_base_large_pfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 43u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn base_large_pfn_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                43u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_base_large_pfn_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                43u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u64,
        page_size: __u64,
        reserved1: __u64,
        base_large_pfn: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let page_size: u64 = unsafe { ::std::mem::transmute(page_size) };
            page_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 43u8, {
            let base_large_pfn: u64 = unsafe { ::std::mem::transmute(base_large_pfn) };
            base_large_pfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_gpa_page_range"][::std::mem::size_of::<hv_gpa_page_range>() - 8usize];
    ["Alignment of hv_gpa_page_range"][::std::mem::align_of::<hv_gpa_page_range>() - 8usize];
    ["Offset of field: hv_gpa_page_range::address_space"]
        [::std::mem::offset_of!(hv_gpa_page_range, address_space) - 0usize];
    ["Offset of field: hv_gpa_page_range::page"]
        [::std::mem::offset_of!(hv_gpa_page_range, page) - 0usize];
};
impl Default for hv_gpa_page_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_interrupt_type_HV_ARM64_INTERRUPT_TYPE_FIXED: hv_interrupt_type = 0;
pub const hv_interrupt_type_HV_ARM64_INTERRUPT_TYPE_MAXIMUM: hv_interrupt_type = 8;
pub type hv_interrupt_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_xsave_xfem_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_xsave_xfem_register__bindgen_ty_1,
    pub __bindgen_anon_2: hv_x64_xsave_xfem_register__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_xsave_xfem_register__bindgen_ty_1 {
    pub low_uint32: __u32,
    pub high_uint32: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xsave_xfem_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_xsave_xfem_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_x64_xsave_xfem_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_xsave_xfem_register__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_x64_xsave_xfem_register__bindgen_ty_1::low_uint32"]
        [::std::mem::offset_of!(hv_x64_xsave_xfem_register__bindgen_ty_1, low_uint32) - 0usize];
    ["Offset of field: hv_x64_xsave_xfem_register__bindgen_ty_1::high_uint32"]
        [::std::mem::offset_of!(hv_x64_xsave_xfem_register__bindgen_ty_1, high_uint32) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_xsave_xfem_register__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xsave_xfem_register__bindgen_ty_2"]
        [::std::mem::size_of::<hv_x64_xsave_xfem_register__bindgen_ty_2>() - 8usize];
    ["Alignment of hv_x64_xsave_xfem_register__bindgen_ty_2"]
        [::std::mem::align_of::<hv_x64_xsave_xfem_register__bindgen_ty_2>() - 1usize];
};
impl hv_x64_xsave_xfem_register__bindgen_ty_2 {
    #[inline]
    pub fn legacy_x87(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_legacy_x87(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn legacy_x87_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_legacy_x87_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn legacy_sse(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_legacy_sse(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn legacy_sse_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_legacy_sse_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpx_bndreg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_bndreg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpx_bndreg_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mpx_bndreg_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpx_bndcsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_bndcsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpx_bndcsr_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mpx_bndcsr_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_512_op_mask(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_op_mask(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_512_op_mask_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_512_op_mask_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_512_zmmhi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_zmmhi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_512_zmmhi_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_512_zmmhi_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_512_zmm16_31(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_zmm16_31(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_512_zmm16_31_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_512_zmm16_31_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd8_9(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd8_9(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd8_9_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd8_9_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pasid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pasid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pasid_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pasid_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cet_u(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_u(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cet_u_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_cet_u_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cet_s(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_s(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cet_s_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_cet_s_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd13_16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd13_16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd13_16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd13_16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xtile_cfg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xtile_cfg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xtile_cfg_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xtile_cfg_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xtile_data(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xtile_data(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xtile_data_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xtile_data_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd19_63(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 45u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd19_63(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 45u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd19_63_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                45u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd19_63_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                45u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        legacy_x87: __u64,
        legacy_sse: __u64,
        avx: __u64,
        mpx_bndreg: __u64,
        mpx_bndcsr: __u64,
        avx_512_op_mask: __u64,
        avx_512_zmmhi: __u64,
        avx_512_zmm16_31: __u64,
        rsvd8_9: __u64,
        pasid: __u64,
        cet_u: __u64,
        cet_s: __u64,
        rsvd13_16: __u64,
        xtile_cfg: __u64,
        xtile_data: __u64,
        rsvd19_63: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let legacy_x87: u64 = unsafe { ::std::mem::transmute(legacy_x87) };
            legacy_x87 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let legacy_sse: u64 = unsafe { ::std::mem::transmute(legacy_sse) };
            legacy_sse as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let avx: u64 = unsafe { ::std::mem::transmute(avx) };
            avx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mpx_bndreg: u64 = unsafe { ::std::mem::transmute(mpx_bndreg) };
            mpx_bndreg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mpx_bndcsr: u64 = unsafe { ::std::mem::transmute(mpx_bndcsr) };
            mpx_bndcsr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let avx_512_op_mask: u64 = unsafe { ::std::mem::transmute(avx_512_op_mask) };
            avx_512_op_mask as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let avx_512_zmmhi: u64 = unsafe { ::std::mem::transmute(avx_512_zmmhi) };
            avx_512_zmmhi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let avx_512_zmm16_31: u64 = unsafe { ::std::mem::transmute(avx_512_zmm16_31) };
            avx_512_zmm16_31 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let rsvd8_9: u64 = unsafe { ::std::mem::transmute(rsvd8_9) };
            rsvd8_9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let pasid: u64 = unsafe { ::std::mem::transmute(pasid) };
            pasid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cet_u: u64 = unsafe { ::std::mem::transmute(cet_u) };
            cet_u as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cet_s: u64 = unsafe { ::std::mem::transmute(cet_s) };
            cet_s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 4u8, {
            let rsvd13_16: u64 = unsafe { ::std::mem::transmute(rsvd13_16) };
            rsvd13_16 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let xtile_cfg: u64 = unsafe { ::std::mem::transmute(xtile_cfg) };
            xtile_cfg as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xtile_data: u64 = unsafe { ::std::mem::transmute(xtile_data) };
            xtile_data as u64
        });
        __bindgen_bitfield_unit.set(19usize, 45u8, {
            let rsvd19_63: u64 = unsafe { ::std::mem::transmute(rsvd19_63) };
            rsvd19_63 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xsave_xfem_register"]
        [::std::mem::size_of::<hv_x64_xsave_xfem_register>() - 8usize];
    ["Alignment of hv_x64_xsave_xfem_register"]
        [::std::mem::align_of::<hv_x64_xsave_xfem_register>() - 8usize];
    ["Offset of field: hv_x64_xsave_xfem_register::as_uint64"]
        [::std::mem::offset_of!(hv_x64_xsave_xfem_register, as_uint64) - 0usize];
};
impl Default for hv_x64_xsave_xfem_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_stimer_config {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_stimer_config__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stimer_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_stimer_config__bindgen_ty_1"]
        [::std::mem::size_of::<hv_stimer_config__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_stimer_config__bindgen_ty_1"]
        [::std::mem::align_of::<hv_stimer_config__bindgen_ty_1>() - 1usize];
};
impl hv_stimer_config__bindgen_ty_1 {
    #[inline]
    pub fn enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn periodic(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_periodic(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn periodic_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_periodic_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lazy(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lazy(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lazy_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_lazy_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn auto_enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_auto_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auto_enable_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_auto_enable_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apic_vector(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_apic_vector(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apic_vector_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_apic_vector_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direct_mode(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_direct_mode(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direct_mode_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_direct_mode_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z0(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z0_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z0_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sintx(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_sintx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sintx_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sintx_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 44u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 44u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                44u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                44u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: __u64,
        periodic: __u64,
        lazy: __u64,
        auto_enable: __u64,
        apic_vector: __u64,
        direct_mode: __u64,
        reserved_z0: __u64,
        sintx: __u64,
        reserved_z1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u64 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let periodic: u64 = unsafe { ::std::mem::transmute(periodic) };
            periodic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lazy: u64 = unsafe { ::std::mem::transmute(lazy) };
            lazy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let auto_enable: u64 = unsafe { ::std::mem::transmute(auto_enable) };
            auto_enable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let apic_vector: u64 = unsafe { ::std::mem::transmute(apic_vector) };
            apic_vector as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let direct_mode: u64 = unsafe { ::std::mem::transmute(direct_mode) };
            direct_mode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved_z0: u64 = unsafe { ::std::mem::transmute(reserved_z0) };
            reserved_z0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let sintx: u64 = unsafe { ::std::mem::transmute(sintx) };
            sintx as u64
        });
        __bindgen_bitfield_unit.set(20usize, 44u8, {
            let reserved_z1: u64 = unsafe { ::std::mem::transmute(reserved_z1) };
            reserved_z1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_stimer_config"][::std::mem::size_of::<hv_stimer_config>() - 8usize];
    ["Alignment of hv_stimer_config"][::std::mem::align_of::<hv_stimer_config>() - 8usize];
    ["Offset of field: hv_stimer_config::as_uint64"]
        [::std::mem::offset_of!(hv_stimer_config, as_uint64) - 0usize];
};
impl Default for hv_stimer_config {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_port_id {
    pub as__u32: __u32,
    pub u: hv_port_id__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_id__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_id__bindgen_ty_1"]
        [::std::mem::size_of::<hv_port_id__bindgen_ty_1>() - 4usize];
    ["Alignment of hv_port_id__bindgen_ty_1"]
        [::std::mem::align_of::<hv_port_id__bindgen_ty_1>() - 1usize];
};
impl hv_port_id__bindgen_ty_1 {
    #[inline]
    pub fn id(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn id_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_id_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(id: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_id"][::std::mem::size_of::<hv_port_id>() - 4usize];
    ["Alignment of hv_port_id"][::std::mem::align_of::<hv_port_id>() - 4usize];
    ["Offset of field: hv_port_id::as__u32"][::std::mem::offset_of!(hv_port_id, as__u32) - 0usize];
    ["Offset of field: hv_port_id::u"][::std::mem::offset_of!(hv_port_id, u) - 0usize];
};
impl Default for hv_port_id {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_message_type_HVMSG_NONE: hv_message_type = 0;
pub const hv_message_type_HVMSG_UNMAPPED_GPA: hv_message_type = 2147483648;
pub const hv_message_type_HVMSG_GPA_INTERCEPT: hv_message_type = 2147483649;
pub const hv_message_type_HVMSG_UNACCEPTED_GPA: hv_message_type = 2147483651;
pub const hv_message_type_HVMSG_GPA_ATTRIBUTE_INTERCEPT: hv_message_type = 2147483652;
pub const hv_message_type_HVMSG_TIMER_EXPIRED: hv_message_type = 2147483664;
pub const hv_message_type_HVMSG_INVALID_VP_REGISTER_VALUE: hv_message_type = 2147483680;
pub const hv_message_type_HVMSG_UNRECOVERABLE_EXCEPTION: hv_message_type = 2147483681;
pub const hv_message_type_HVMSG_UNSUPPORTED_FEATURE: hv_message_type = 2147483682;
pub const hv_message_type_HVMSG_OPAQUE_INTERCEPT: hv_message_type = 2147483711;
pub const hv_message_type_HVMSG_EVENTLOG_BUFFERCOMPLETE: hv_message_type = 2147483712;
pub const hv_message_type_HVMSG_HYPERCALL_INTERCEPT: hv_message_type = 2147483728;
pub const hv_message_type_HVMSG_SYNIC_EVENT_INTERCEPT: hv_message_type = 2147483744;
pub const hv_message_type_HVMSG_SYNIC_SINT_INTERCEPT: hv_message_type = 2147483745;
pub const hv_message_type_HVMSG_SYNIC_SINT_DELIVERABLE: hv_message_type = 2147483746;
pub const hv_message_type_HVMSG_ASYNC_CALL_COMPLETION: hv_message_type = 2147483760;
pub const hv_message_type_HVMSG_SCHEDULER_VP_SIGNAL_BITSET: hv_message_type = 2147483904;
pub const hv_message_type_HVMSG_SCHEDULER_VP_SIGNAL_PAIR: hv_message_type = 2147483905;
pub const hv_message_type_HVMSG_X64_IO_PORT_INTERCEPT: hv_message_type = 2147549184;
pub const hv_message_type_HVMSG_X64_MSR_INTERCEPT: hv_message_type = 2147549185;
pub const hv_message_type_HVMSG_X64_CPUID_INTERCEPT: hv_message_type = 2147549186;
pub const hv_message_type_HVMSG_X64_EXCEPTION_INTERCEPT: hv_message_type = 2147549187;
pub const hv_message_type_HVMSG_X64_APIC_EOI: hv_message_type = 2147549188;
pub const hv_message_type_HVMSG_X64_LEGACY_FP_ERROR: hv_message_type = 2147549189;
pub const hv_message_type_HVMSG_X64_IOMMU_PRQ: hv_message_type = 2147549190;
pub const hv_message_type_HVMSG_X64_HALT: hv_message_type = 2147549191;
pub const hv_message_type_HVMSG_X64_INTERRUPTION_DELIVERABLE: hv_message_type = 2147549192;
pub const hv_message_type_HVMSG_X64_SIPI_INTERCEPT: hv_message_type = 2147549193;
pub const hv_message_type_HVMSG_X64_SEV_VMGEXIT_INTERCEPT: hv_message_type = 2147549203;
pub type hv_message_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message_flags {
    pub asu8: __u8,
    pub __bindgen_anon_1: hv_message_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_message_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_message_flags__bindgen_ty_1"]
        [::std::mem::size_of::<hv_message_flags__bindgen_ty_1>() - 1usize];
    ["Alignment of hv_message_flags__bindgen_ty_1"]
        [::std::mem::align_of::<hv_message_flags__bindgen_ty_1>() - 1usize];
};
impl hv_message_flags__bindgen_ty_1 {
    #[inline]
    pub fn msg_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msg_pending_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_msg_pending_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_pending: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_pending: u8 = unsafe { ::std::mem::transmute(msg_pending) };
            msg_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_message_flags"][::std::mem::size_of::<hv_message_flags>() - 1usize];
    ["Alignment of hv_message_flags"][::std::mem::align_of::<hv_message_flags>() - 1usize];
    ["Offset of field: hv_message_flags::asu8"]
        [::std::mem::offset_of!(hv_message_flags, asu8) - 0usize];
};
impl Default for hv_message_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message_header {
    pub message_type: __u32,
    pub payload_size: __u8,
    pub message_flags: hv_message_flags,
    pub reserved: [__u8; 2usize],
    pub __bindgen_anon_1: hv_message_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message_header__bindgen_ty_1 {
    pub sender: __u64,
    pub port: hv_port_id,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_message_header__bindgen_ty_1"]
        [::std::mem::size_of::<hv_message_header__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_message_header__bindgen_ty_1"]
        [::std::mem::align_of::<hv_message_header__bindgen_ty_1>() - 8usize];
    ["Offset of field: hv_message_header__bindgen_ty_1::sender"]
        [::std::mem::offset_of!(hv_message_header__bindgen_ty_1, sender) - 0usize];
    ["Offset of field: hv_message_header__bindgen_ty_1::port"]
        [::std::mem::offset_of!(hv_message_header__bindgen_ty_1, port) - 0usize];
};
impl Default for hv_message_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_message_header"][::std::mem::size_of::<hv_message_header>() - 16usize];
    ["Alignment of hv_message_header"][::std::mem::align_of::<hv_message_header>() - 1usize];
    ["Offset of field: hv_message_header::message_type"]
        [::std::mem::offset_of!(hv_message_header, message_type) - 0usize];
    ["Offset of field: hv_message_header::payload_size"]
        [::std::mem::offset_of!(hv_message_header, payload_size) - 4usize];
    ["Offset of field: hv_message_header::message_flags"]
        [::std::mem::offset_of!(hv_message_header, message_flags) - 5usize];
    ["Offset of field: hv_message_header::reserved"]
        [::std::mem::offset_of!(hv_message_header, reserved) - 6usize];
};
impl Default for hv_message_header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message {
    pub header: hv_message_header,
    pub u: hv_message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message__bindgen_ty_1 {
    pub payload: [__u64; 30usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_message__bindgen_ty_1"]
        [::std::mem::size_of::<hv_message__bindgen_ty_1>() - 240usize];
    ["Alignment of hv_message__bindgen_ty_1"]
        [::std::mem::align_of::<hv_message__bindgen_ty_1>() - 8usize];
    ["Offset of field: hv_message__bindgen_ty_1::payload"]
        [::std::mem::offset_of!(hv_message__bindgen_ty_1, payload) - 0usize];
};
impl Default for hv_message__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_message"][::std::mem::size_of::<hv_message>() - 256usize];
    ["Alignment of hv_message"][::std::mem::align_of::<hv_message>() - 1usize];
    ["Offset of field: hv_message::header"][::std::mem::offset_of!(hv_message, header) - 0usize];
    ["Offset of field: hv_message::u"][::std::mem::offset_of!(hv_message, u) - 16usize];
};
impl Default for hv_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_segment_register {
    pub base: __u64,
    pub limit: __u32,
    pub selector: __u16,
    pub __bindgen_anon_1: hv_x64_segment_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_segment_register__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1,
    pub attributes: __u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Alignment of hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_type(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_segment_type(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segment_type_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_segment_type_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_system_segment(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_non_system_segment(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_system_segment_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_non_system_segment_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn descriptor_privilege_level(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_descriptor_privilege_level(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn descriptor_privilege_level_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_descriptor_privilege_level_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn present(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_present(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn present_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_present_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn available(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_available(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn available_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_available_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _long(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__long(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _long_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__long_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _default(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__default(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _default_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__default_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn granularity(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_granularity(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn granularity_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_granularity_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_type: __u16,
        non_system_segment: __u16,
        descriptor_privilege_level: __u16,
        present: __u16,
        reserved: __u16,
        available: __u16,
        _long: __u16,
        _default: __u16,
        granularity: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let segment_type: u16 = unsafe { ::std::mem::transmute(segment_type) };
            segment_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let non_system_segment: u16 = unsafe { ::std::mem::transmute(non_system_segment) };
            non_system_segment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let descriptor_privilege_level: u16 =
                unsafe { ::std::mem::transmute(descriptor_privilege_level) };
            descriptor_privilege_level as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let present: u16 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let available: u16 = unsafe { ::std::mem::transmute(available) };
            available as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let _long: u16 = unsafe { ::std::mem::transmute(_long) };
            _long as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let _default: u16 = unsafe { ::std::mem::transmute(_default) };
            _default as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let granularity: u16 = unsafe { ::std::mem::transmute(granularity) };
            granularity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_segment_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_segment_register__bindgen_ty_1>() - 2usize];
    ["Alignment of hv_x64_segment_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_segment_register__bindgen_ty_1>() - 2usize];
    ["Offset of field: hv_x64_segment_register__bindgen_ty_1::attributes"]
        [::std::mem::offset_of!(hv_x64_segment_register__bindgen_ty_1, attributes) - 0usize];
};
impl Default for hv_x64_segment_register__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_segment_register"][::std::mem::size_of::<hv_x64_segment_register>() - 16usize];
    ["Alignment of hv_x64_segment_register"]
        [::std::mem::align_of::<hv_x64_segment_register>() - 1usize];
    ["Offset of field: hv_x64_segment_register::base"]
        [::std::mem::offset_of!(hv_x64_segment_register, base) - 0usize];
    ["Offset of field: hv_x64_segment_register::limit"]
        [::std::mem::offset_of!(hv_x64_segment_register, limit) - 8usize];
    ["Offset of field: hv_x64_segment_register::selector"]
        [::std::mem::offset_of!(hv_x64_segment_register, selector) - 12usize];
};
impl Default for hv_x64_segment_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_table_register {
    pub pad: [__u16; 3usize],
    pub limit: __u16,
    pub base: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_table_register"][::std::mem::size_of::<hv_x64_table_register>() - 16usize];
    ["Alignment of hv_x64_table_register"]
        [::std::mem::align_of::<hv_x64_table_register>() - 1usize];
    ["Offset of field: hv_x64_table_register::pad"]
        [::std::mem::offset_of!(hv_x64_table_register, pad) - 0usize];
    ["Offset of field: hv_x64_table_register::limit"]
        [::std::mem::offset_of!(hv_x64_table_register, limit) - 6usize];
    ["Offset of field: hv_x64_table_register::base"]
        [::std::mem::offset_of!(hv_x64_table_register, base) - 8usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_control_status_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_fp_control_status_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_fp_control_status_register__bindgen_ty_1 {
    pub fp_control: __u16,
    pub fp_status: __u16,
    pub fp_tag: __u8,
    pub reserved: __u8,
    pub last_fp_op: __u16,
    pub __bindgen_anon_1: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_rip: __u64,
    pub __bindgen_anon_1:
        hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_eip: __u32,
    pub last_fp_cs: __u16,
    pub padding: __u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<
            hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >() - 8usize];
    ["Alignment of hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<
            hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >() - 1usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::last_fp_eip"] [:: std :: mem :: offset_of ! (hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , last_fp_eip) - 0usize] ;
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::last_fp_cs"] [:: std :: mem :: offset_of ! (hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , last_fp_cs) - 4usize] ;
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::padding"] [:: std :: mem :: offset_of ! (hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , padding) - 6usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1>()
            - 8usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1::last_fp_rip"] [:: std :: mem :: offset_of ! (hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 , last_fp_rip) - 0usize] ;
};
impl Default for hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_fp_control_status_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_fp_control_status_register__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_x64_fp_control_status_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_fp_control_status_register__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1::fp_control"][::std::mem::offset_of!(
        hv_x64_fp_control_status_register__bindgen_ty_1,
        fp_control
    ) - 0usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1::fp_status"][::std::mem::offset_of!(
        hv_x64_fp_control_status_register__bindgen_ty_1,
        fp_status
    ) - 2usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1::fp_tag"]
        [::std::mem::offset_of!(hv_x64_fp_control_status_register__bindgen_ty_1, fp_tag) - 4usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1::reserved"][::std::mem::offset_of!(
        hv_x64_fp_control_status_register__bindgen_ty_1,
        reserved
    ) - 5usize];
    ["Offset of field: hv_x64_fp_control_status_register__bindgen_ty_1::last_fp_op"][::std::mem::offset_of!(
        hv_x64_fp_control_status_register__bindgen_ty_1,
        last_fp_op
    ) - 6usize];
};
impl Default for hv_x64_fp_control_status_register__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_fp_control_status_register"]
        [::std::mem::size_of::<hv_x64_fp_control_status_register>() - 16usize];
    ["Alignment of hv_x64_fp_control_status_register"]
        [::std::mem::align_of::<hv_x64_fp_control_status_register>() - 1usize];
    ["Offset of field: hv_x64_fp_control_status_register::as_uint128"]
        [::std::mem::offset_of!(hv_x64_fp_control_status_register, as_uint128) - 0usize];
};
impl Default for hv_x64_fp_control_status_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_xmm_control_status_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_xmm_control_status_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_xmm_control_status_register__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1,
    pub xmm_status_control: __u32,
    pub xmm_status_control_mask: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_rdp: __u64,
    pub __bindgen_anon_1:
        hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_dp: __u32,
    pub last_fp_ds: __u16,
    pub padding: __u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<
            hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >() - 8usize];
    ["Alignment of hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<
            hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >() - 1usize];
    ["Offset of field: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::last_fp_dp"] [:: std :: mem :: offset_of ! (hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , last_fp_dp) - 0usize] ;
    ["Offset of field: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::last_fp_ds"] [:: std :: mem :: offset_of ! (hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , last_fp_ds) - 4usize] ;
    ["Offset of field: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::padding"] [:: std :: mem :: offset_of ! (hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , padding) - 6usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1>()
            - 8usize];
    ["Offset of field: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1::last_fp_rdp"] [:: std :: mem :: offset_of ! (hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 , last_fp_rdp) - 0usize] ;
};
impl Default for hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xmm_control_status_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_xmm_control_status_register__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_x64_xmm_control_status_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_xmm_control_status_register__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_x64_xmm_control_status_register__bindgen_ty_1::xmm_status_control"][::std::mem::offset_of!(
        hv_x64_xmm_control_status_register__bindgen_ty_1,
        xmm_status_control
    )
        - 8usize];
    ["Offset of field: hv_x64_xmm_control_status_register__bindgen_ty_1::xmm_status_control_mask"] [:: std :: mem :: offset_of ! (hv_x64_xmm_control_status_register__bindgen_ty_1 , xmm_status_control_mask) - 12usize] ;
};
impl Default for hv_x64_xmm_control_status_register__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_xmm_control_status_register"]
        [::std::mem::size_of::<hv_x64_xmm_control_status_register>() - 16usize];
    ["Alignment of hv_x64_xmm_control_status_register"]
        [::std::mem::align_of::<hv_x64_xmm_control_status_register>() - 1usize];
    ["Offset of field: hv_x64_xmm_control_status_register::as_uint128"]
        [::std::mem::offset_of!(hv_x64_xmm_control_status_register, as_uint128) - 0usize];
};
impl Default for hv_x64_xmm_control_status_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_fp_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_fp_register__bindgen_ty_1 {
    pub mantissa: __u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_fp_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_fp_register__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_x64_fp_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_fp_register__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_x64_fp_register__bindgen_ty_1::mantissa"]
        [::std::mem::offset_of!(hv_x64_fp_register__bindgen_ty_1, mantissa) - 0usize];
};
impl hv_x64_fp_register__bindgen_ty_1 {
    #[inline]
    pub fn biased_exponent(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                15u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                48u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                48u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        biased_exponent: __u64,
        sign: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let biased_exponent: u64 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sign: u64 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_fp_register"][::std::mem::size_of::<hv_x64_fp_register>() - 16usize];
    ["Alignment of hv_x64_fp_register"][::std::mem::align_of::<hv_x64_fp_register>() - 1usize];
    ["Offset of field: hv_x64_fp_register::as_uint128"]
        [::std::mem::offset_of!(hv_x64_fp_register, as_uint128) - 0usize];
};
impl Default for hv_x64_fp_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_msr_npiep_config_contents {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_msr_npiep_config_contents__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_msr_npiep_config_contents__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_msr_npiep_config_contents__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_msr_npiep_config_contents__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_x64_msr_npiep_config_contents__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_msr_npiep_config_contents__bindgen_ty_1>() - 1usize];
};
impl hv_x64_msr_npiep_config_contents__bindgen_ty_1 {
    #[inline]
    pub fn prevents_gdt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_gdt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn prevents_gdt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_prevents_gdt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn prevents_idt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_idt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn prevents_idt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_prevents_idt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn prevents_ldt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_ldt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn prevents_ldt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_prevents_ldt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn prevents_tr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_tr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn prevents_tr_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_prevents_tr_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                60u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                60u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prevents_gdt: __u64,
        prevents_idt: __u64,
        prevents_ldt: __u64,
        prevents_tr: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let prevents_gdt: u64 = unsafe { ::std::mem::transmute(prevents_gdt) };
            prevents_gdt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prevents_idt: u64 = unsafe { ::std::mem::transmute(prevents_idt) };
            prevents_idt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let prevents_ldt: u64 = unsafe { ::std::mem::transmute(prevents_ldt) };
            prevents_ldt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let prevents_tr: u64 = unsafe { ::std::mem::transmute(prevents_tr) };
            prevents_tr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_msr_npiep_config_contents"]
        [::std::mem::size_of::<hv_x64_msr_npiep_config_contents>() - 8usize];
    ["Alignment of hv_x64_msr_npiep_config_contents"]
        [::std::mem::align_of::<hv_x64_msr_npiep_config_contents>() - 8usize];
    ["Offset of field: hv_x64_msr_npiep_config_contents::as_uint64"]
        [::std::mem::offset_of!(hv_x64_msr_npiep_config_contents, as_uint64) - 0usize];
};
impl Default for hv_x64_msr_npiep_config_contents {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_input_vtl {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_input_vtl__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_vtl__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_vtl__bindgen_ty_1"]
        [::std::mem::size_of::<hv_input_vtl__bindgen_ty_1>() - 1usize];
    ["Alignment of hv_input_vtl__bindgen_ty_1"]
        [::std::mem::align_of::<hv_input_vtl__bindgen_ty_1>() - 1usize];
};
impl hv_input_vtl__bindgen_ty_1 {
    #[inline]
    pub fn target_vtl(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_target_vtl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn target_vtl_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_target_vtl_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_target_vtl(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_target_vtl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_target_vtl_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_target_vtl_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_z(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        target_vtl: __u8,
        use_target_vtl: __u8,
        reserved_z: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let target_vtl: u8 = unsafe { ::std::mem::transmute(target_vtl) };
            target_vtl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let use_target_vtl: u8 = unsafe { ::std::mem::transmute(use_target_vtl) };
            use_target_vtl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved_z: u8 = unsafe { ::std::mem::transmute(reserved_z) };
            reserved_z as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_vtl"][::std::mem::size_of::<hv_input_vtl>() - 1usize];
    ["Alignment of hv_input_vtl"][::std::mem::align_of::<hv_input_vtl>() - 1usize];
    ["Offset of field: hv_input_vtl::as_uint8"]
        [::std::mem::offset_of!(hv_input_vtl, as_uint8) - 0usize];
};
impl Default for hv_input_vtl {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_register_vsm_partition_config {
    pub as_u64: __u64,
    pub __bindgen_anon_1: hv_register_vsm_partition_config__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_register_vsm_partition_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_register_vsm_partition_config__bindgen_ty_1"]
        [::std::mem::size_of::<hv_register_vsm_partition_config__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_register_vsm_partition_config__bindgen_ty_1"]
        [::std::mem::align_of::<hv_register_vsm_partition_config__bindgen_ty_1>() - 8usize];
};
impl hv_register_vsm_partition_config__bindgen_ty_1 {
    #[inline]
    pub fn enable_vtl_protection(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_vtl_protection(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_vtl_protection_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_enable_vtl_protection_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn default_vtl_protection_mask(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_default_vtl_protection_mask(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_vtl_protection_mask_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_default_vtl_protection_mask_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zero_memory_on_reset(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_zero_memory_on_reset(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zero_memory_on_reset_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_zero_memory_on_reset_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn deny_lower_vtl_startup(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_deny_lower_vtl_startup(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn deny_lower_vtl_startup_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_deny_lower_vtl_startup_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_acceptance(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_acceptance(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_acceptance_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_acceptance_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_enable_vtl_protection(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_enable_vtl_protection(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_enable_vtl_protection_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_enable_vtl_protection_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_vp_startup(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_vp_startup(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_vp_startup_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_vp_startup_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_cpuid_unimplemented(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_cpuid_unimplemented(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_cpuid_unimplemented_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_cpuid_unimplemented_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_unrecoverable_exception(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_unrecoverable_exception(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_unrecoverable_exception_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_unrecoverable_exception_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_page(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_page_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_page_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_restore_partition_time(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_restore_partition_time(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_restore_partition_time_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_restore_partition_time_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intercept_not_present(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_not_present(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intercept_not_present_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intercept_not_present_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mbz(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 49u8) as u64) }
    }
    #[inline]
    pub fn set_mbz(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 49u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mbz_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                49u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mbz_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                49u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_vtl_protection: __u64,
        default_vtl_protection_mask: __u64,
        zero_memory_on_reset: __u64,
        deny_lower_vtl_startup: __u64,
        intercept_acceptance: __u64,
        intercept_enable_vtl_protection: __u64,
        intercept_vp_startup: __u64,
        intercept_cpuid_unimplemented: __u64,
        intercept_unrecoverable_exception: __u64,
        intercept_page: __u64,
        intercept_restore_partition_time: __u64,
        intercept_not_present: __u64,
        mbz: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_vtl_protection: u64 =
                unsafe { ::std::mem::transmute(enable_vtl_protection) };
            enable_vtl_protection as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let default_vtl_protection_mask: u64 =
                unsafe { ::std::mem::transmute(default_vtl_protection_mask) };
            default_vtl_protection_mask as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let zero_memory_on_reset: u64 = unsafe { ::std::mem::transmute(zero_memory_on_reset) };
            zero_memory_on_reset as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let deny_lower_vtl_startup: u64 =
                unsafe { ::std::mem::transmute(deny_lower_vtl_startup) };
            deny_lower_vtl_startup as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let intercept_acceptance: u64 = unsafe { ::std::mem::transmute(intercept_acceptance) };
            intercept_acceptance as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let intercept_enable_vtl_protection: u64 =
                unsafe { ::std::mem::transmute(intercept_enable_vtl_protection) };
            intercept_enable_vtl_protection as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let intercept_vp_startup: u64 = unsafe { ::std::mem::transmute(intercept_vp_startup) };
            intercept_vp_startup as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let intercept_cpuid_unimplemented: u64 =
                unsafe { ::std::mem::transmute(intercept_cpuid_unimplemented) };
            intercept_cpuid_unimplemented as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let intercept_unrecoverable_exception: u64 =
                unsafe { ::std::mem::transmute(intercept_unrecoverable_exception) };
            intercept_unrecoverable_exception as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let intercept_page: u64 = unsafe { ::std::mem::transmute(intercept_page) };
            intercept_page as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let intercept_restore_partition_time: u64 =
                unsafe { ::std::mem::transmute(intercept_restore_partition_time) };
            intercept_restore_partition_time as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let intercept_not_present: u64 =
                unsafe { ::std::mem::transmute(intercept_not_present) };
            intercept_not_present as u64
        });
        __bindgen_bitfield_unit.set(15usize, 49u8, {
            let mbz: u64 = unsafe { ::std::mem::transmute(mbz) };
            mbz as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_register_vsm_partition_config"]
        [::std::mem::size_of::<hv_register_vsm_partition_config>() - 8usize];
    ["Alignment of hv_register_vsm_partition_config"]
        [::std::mem::align_of::<hv_register_vsm_partition_config>() - 8usize];
    ["Offset of field: hv_register_vsm_partition_config::as_u64"]
        [::std::mem::offset_of!(hv_register_vsm_partition_config, as_u64) - 0usize];
};
impl Default for hv_register_vsm_partition_config {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_register_name_HV_REGISTER_EXPLICIT_SUSPEND: hv_register_name = 0;
pub const hv_register_name_HV_REGISTER_INTERCEPT_SUSPEND: hv_register_name = 1;
pub const hv_register_name_HV_REGISTER_INSTRUCTION_EMULATION_HINTS: hv_register_name = 2;
pub const hv_register_name_HV_REGISTER_DISPATCH_SUSPEND: hv_register_name = 3;
pub const hv_register_name_HV_REGISTER_INTERNAL_ACTIVITY_STATE: hv_register_name = 4;
pub const hv_register_name_HV_REGISTER_HYPERVISOR_VERSION: hv_register_name = 256;
pub const hv_register_name_HV_REGISTER_PRIVILEGES_AND_FEATURES_INFO: hv_register_name = 512;
pub const hv_register_name_HV_REGISTER_FEATURES_INFO: hv_register_name = 513;
pub const hv_register_name_HV_REGISTER_IMPLEMENTATION_LIMITS_INFO: hv_register_name = 514;
pub const hv_register_name_HV_REGISTER_HARDWARE_FEATURES_INFO: hv_register_name = 515;
pub const hv_register_name_HV_REGISTER_CPU_MANAGEMENT_FEATURES_INFO: hv_register_name = 516;
pub const hv_register_name_HV_REGISTER_SVM_FEATURES_INFO: hv_register_name = 517;
pub const hv_register_name_HV_REGISTER_SKIP_LEVEL_FEATURES_INFO: hv_register_name = 518;
pub const hv_register_name_HV_REGISTER_NESTED_VIRT_FEATURES_INFO: hv_register_name = 519;
pub const hv_register_name_HV_REGISTER_IPT_FEATURES_INFO: hv_register_name = 520;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P0: hv_register_name = 528;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P1: hv_register_name = 529;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P2: hv_register_name = 530;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P3: hv_register_name = 531;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P4: hv_register_name = 532;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_CTL: hv_register_name = 533;
pub const hv_register_name_HV_REGISTER_POWER_STATE_CONFIG_C1: hv_register_name = 544;
pub const hv_register_name_HV_REGISTER_POWER_STATE_TRIGGER_C1: hv_register_name = 545;
pub const hv_register_name_HV_REGISTER_POWER_STATE_CONFIG_C2: hv_register_name = 546;
pub const hv_register_name_HV_REGISTER_POWER_STATE_TRIGGER_C2: hv_register_name = 547;
pub const hv_register_name_HV_REGISTER_POWER_STATE_CONFIG_C3: hv_register_name = 548;
pub const hv_register_name_HV_REGISTER_POWER_STATE_TRIGGER_C3: hv_register_name = 549;
pub const hv_register_name_HV_REGISTER_PROCESSOR_CLOCK_FREQUENCY: hv_register_name = 576;
pub const hv_register_name_HV_REGISTER_INTERRUPT_CLOCK_FREQUENCY: hv_register_name = 577;
pub const hv_register_name_HV_REGISTER_GUEST_IDLE: hv_register_name = 592;
pub const hv_register_name_HV_REGISTER_DEBUG_DEVICE_OPTIONS: hv_register_name = 608;
pub const hv_register_name_HV_REGISTER_MEMORY_ZEROING_CONTROL: hv_register_name = 624;
pub const hv_register_name_HV_REGISTER_PENDING_EVENT0: hv_register_name = 65540;
pub const hv_register_name_HV_REGISTER_PENDING_EVENT1: hv_register_name = 65541;
pub const hv_register_name_HV_REGISTER_DELIVERABILITY_NOTIFICATIONS: hv_register_name = 65542;
pub const hv_register_name_HV_REGISTER_VP_RUNTIME: hv_register_name = 589824;
pub const hv_register_name_HV_REGISTER_GUEST_OS_ID: hv_register_name = 589826;
pub const hv_register_name_HV_REGISTER_VP_INDEX: hv_register_name = 589827;
pub const hv_register_name_HV_REGISTER_TIME_REF_COUNT: hv_register_name = 589828;
pub const hv_register_name_HV_REGISTER_CPU_MANAGEMENT_VERSION: hv_register_name = 589831;
pub const hv_register_name_HV_REGISTER_VP_ASSIST_PAGE: hv_register_name = 589843;
pub const hv_register_name_HV_REGISTER_VP_ROOT_SIGNAL_COUNT: hv_register_name = 589844;
pub const hv_register_name_HV_REGISTER_REFERENCE_TSC: hv_register_name = 589847;
pub const hv_register_name_HV_REGISTER_STATS_PARTITION_RETAIL: hv_register_name = 589856;
pub const hv_register_name_HV_REGISTER_STATS_PARTITION_INTERNAL: hv_register_name = 589857;
pub const hv_register_name_HV_REGISTER_STATS_VP_RETAIL: hv_register_name = 589858;
pub const hv_register_name_HV_REGISTER_STATS_VP_INTERNAL: hv_register_name = 589859;
pub const hv_register_name_HV_REGISTER_NESTED_VP_INDEX: hv_register_name = 593923;
pub const hv_register_name_HV_REGISTER_SINT0: hv_register_name = 655360;
pub const hv_register_name_HV_REGISTER_SINT1: hv_register_name = 655361;
pub const hv_register_name_HV_REGISTER_SINT2: hv_register_name = 655362;
pub const hv_register_name_HV_REGISTER_SINT3: hv_register_name = 655363;
pub const hv_register_name_HV_REGISTER_SINT4: hv_register_name = 655364;
pub const hv_register_name_HV_REGISTER_SINT5: hv_register_name = 655365;
pub const hv_register_name_HV_REGISTER_SINT6: hv_register_name = 655366;
pub const hv_register_name_HV_REGISTER_SINT7: hv_register_name = 655367;
pub const hv_register_name_HV_REGISTER_SINT8: hv_register_name = 655368;
pub const hv_register_name_HV_REGISTER_SINT9: hv_register_name = 655369;
pub const hv_register_name_HV_REGISTER_SINT10: hv_register_name = 655370;
pub const hv_register_name_HV_REGISTER_SINT11: hv_register_name = 655371;
pub const hv_register_name_HV_REGISTER_SINT12: hv_register_name = 655372;
pub const hv_register_name_HV_REGISTER_SINT13: hv_register_name = 655373;
pub const hv_register_name_HV_REGISTER_SINT14: hv_register_name = 655374;
pub const hv_register_name_HV_REGISTER_SINT15: hv_register_name = 655375;
pub const hv_register_name_HV_REGISTER_SCONTROL: hv_register_name = 655376;
pub const hv_register_name_HV_REGISTER_SVERSION: hv_register_name = 655377;
pub const hv_register_name_HV_REGISTER_SIEFP: hv_register_name = 655378;
pub const hv_register_name_HV_REGISTER_SIMP: hv_register_name = 655379;
pub const hv_register_name_HV_REGISTER_EOM: hv_register_name = 655380;
pub const hv_register_name_HV_REGISTER_SIRBP: hv_register_name = 655381;
pub const hv_register_name_HV_REGISTER_NESTED_SINT0: hv_register_name = 659456;
pub const hv_register_name_HV_REGISTER_NESTED_SINT1: hv_register_name = 659457;
pub const hv_register_name_HV_REGISTER_NESTED_SINT2: hv_register_name = 659458;
pub const hv_register_name_HV_REGISTER_NESTED_SINT3: hv_register_name = 659459;
pub const hv_register_name_HV_REGISTER_NESTED_SINT4: hv_register_name = 659460;
pub const hv_register_name_HV_REGISTER_NESTED_SINT5: hv_register_name = 659461;
pub const hv_register_name_HV_REGISTER_NESTED_SINT6: hv_register_name = 659462;
pub const hv_register_name_HV_REGISTER_NESTED_SINT7: hv_register_name = 659463;
pub const hv_register_name_HV_REGISTER_NESTED_SINT8: hv_register_name = 659464;
pub const hv_register_name_HV_REGISTER_NESTED_SINT9: hv_register_name = 659465;
pub const hv_register_name_HV_REGISTER_NESTED_SINT10: hv_register_name = 659466;
pub const hv_register_name_HV_REGISTER_NESTED_SINT11: hv_register_name = 659467;
pub const hv_register_name_HV_REGISTER_NESTED_SINT12: hv_register_name = 659468;
pub const hv_register_name_HV_REGISTER_NESTED_SINT13: hv_register_name = 659469;
pub const hv_register_name_HV_REGISTER_NESTED_SINT14: hv_register_name = 659470;
pub const hv_register_name_HV_REGISTER_NESTED_SINT15: hv_register_name = 659471;
pub const hv_register_name_HV_REGISTER_NESTED_SCONTROL: hv_register_name = 659472;
pub const hv_register_name_HV_REGISTER_NESTED_SVERSION: hv_register_name = 659473;
pub const hv_register_name_HV_REGISTER_NESTED_SIFP: hv_register_name = 659474;
pub const hv_register_name_HV_REGISTER_NESTED_SIPP: hv_register_name = 659475;
pub const hv_register_name_HV_REGISTER_NESTED_EOM: hv_register_name = 659476;
pub const hv_register_name_HV_REGISTER_NESTED_SIRBP: hv_register_name = 659477;
pub const hv_register_name_HV_REGISTER_STIMER0_CONFIG: hv_register_name = 720896;
pub const hv_register_name_HV_REGISTER_STIMER0_COUNT: hv_register_name = 720897;
pub const hv_register_name_HV_REGISTER_STIMER1_CONFIG: hv_register_name = 720898;
pub const hv_register_name_HV_REGISTER_STIMER1_COUNT: hv_register_name = 720899;
pub const hv_register_name_HV_REGISTER_STIMER2_CONFIG: hv_register_name = 720900;
pub const hv_register_name_HV_REGISTER_STIMER2_COUNT: hv_register_name = 720901;
pub const hv_register_name_HV_REGISTER_STIMER3_CONFIG: hv_register_name = 720902;
pub const hv_register_name_HV_REGISTER_STIMER3_COUNT: hv_register_name = 720903;
pub const hv_register_name_HV_REGISTER_STIME_UNHALTED_TIMER_CONFIG: hv_register_name = 721152;
pub const hv_register_name_HV_REGISTER_STIME_UNHALTED_TIMER_COUNT: hv_register_name = 721153;
pub const hv_register_name_HV_REGISTER_VSM_CODE_PAGE_OFFSETS: hv_register_name = 851970;
pub const hv_register_name_HV_REGISTER_VSM_VP_STATUS: hv_register_name = 851971;
pub const hv_register_name_HV_REGISTER_VSM_PARTITION_STATUS: hv_register_name = 851972;
pub const hv_register_name_HV_REGISTER_VSM_VINA: hv_register_name = 851973;
pub const hv_register_name_HV_REGISTER_VSM_CAPABILITIES: hv_register_name = 851974;
pub const hv_register_name_HV_REGISTER_VSM_PARTITION_CONFIG: hv_register_name = 851975;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL0: hv_register_name = 851984;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL1: hv_register_name = 851985;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL2: hv_register_name = 851986;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL3: hv_register_name = 851987;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL4: hv_register_name = 851988;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL5: hv_register_name = 851989;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL6: hv_register_name = 851990;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL7: hv_register_name = 851991;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL8: hv_register_name = 851992;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL9: hv_register_name = 851993;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL10: hv_register_name = 851994;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL11: hv_register_name = 851995;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL12: hv_register_name = 851996;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL13: hv_register_name = 851997;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL14: hv_register_name = 851998;
pub const hv_register_name_HV_REGISTER_VSM_VP_WAIT_FOR_TLB_LOCK: hv_register_name = 852000;
pub const hv_register_name_HV_REGISTER_ISOLATION_CAPABILITIES: hv_register_name = 852224;
pub const hv_register_name_HV_ARM64_REGISTER_XZR: hv_register_name = 196606;
pub const hv_register_name_HV_ARM64_REGISTER_X0: hv_register_name = 131072;
pub const hv_register_name_HV_ARM64_REGISTER_X1: hv_register_name = 131073;
pub const hv_register_name_HV_ARM64_REGISTER_X2: hv_register_name = 131074;
pub const hv_register_name_HV_ARM64_REGISTER_X3: hv_register_name = 131075;
pub const hv_register_name_HV_ARM64_REGISTER_X4: hv_register_name = 131076;
pub const hv_register_name_HV_ARM64_REGISTER_X5: hv_register_name = 131077;
pub const hv_register_name_HV_ARM64_REGISTER_X6: hv_register_name = 131078;
pub const hv_register_name_HV_ARM64_REGISTER_X7: hv_register_name = 131079;
pub const hv_register_name_HV_ARM64_REGISTER_X8: hv_register_name = 131080;
pub const hv_register_name_HV_ARM64_REGISTER_X9: hv_register_name = 131081;
pub const hv_register_name_HV_ARM64_REGISTER_X10: hv_register_name = 131082;
pub const hv_register_name_HV_ARM64_REGISTER_X11: hv_register_name = 131083;
pub const hv_register_name_HV_ARM64_REGISTER_X12: hv_register_name = 131084;
pub const hv_register_name_HV_ARM64_REGISTER_X13: hv_register_name = 131085;
pub const hv_register_name_HV_ARM64_REGISTER_X14: hv_register_name = 131086;
pub const hv_register_name_HV_ARM64_REGISTER_X15: hv_register_name = 131087;
pub const hv_register_name_HV_ARM64_REGISTER_X16: hv_register_name = 131088;
pub const hv_register_name_HV_ARM64_REGISTER_X17: hv_register_name = 131089;
pub const hv_register_name_HV_ARM64_REGISTER_X18: hv_register_name = 131090;
pub const hv_register_name_HV_ARM64_REGISTER_X19: hv_register_name = 131091;
pub const hv_register_name_HV_ARM64_REGISTER_X20: hv_register_name = 131092;
pub const hv_register_name_HV_ARM64_REGISTER_X21: hv_register_name = 131093;
pub const hv_register_name_HV_ARM64_REGISTER_X22: hv_register_name = 131094;
pub const hv_register_name_HV_ARM64_REGISTER_X23: hv_register_name = 131095;
pub const hv_register_name_HV_ARM64_REGISTER_X24: hv_register_name = 131096;
pub const hv_register_name_HV_ARM64_REGISTER_X25: hv_register_name = 131097;
pub const hv_register_name_HV_ARM64_REGISTER_X26: hv_register_name = 131098;
pub const hv_register_name_HV_ARM64_REGISTER_X27: hv_register_name = 131099;
pub const hv_register_name_HV_ARM64_REGISTER_X28: hv_register_name = 131100;
pub const hv_register_name_HV_ARM64_REGISTER_FP: hv_register_name = 131101;
pub const hv_register_name_HV_ARM64_REGISTER_LR: hv_register_name = 131102;
pub const hv_register_name_HV_ARM64_REGISTER_PC: hv_register_name = 131106;
pub const hv_register_name_HV_ARM64_REGISTER_Q0: hv_register_name = 196608;
pub const hv_register_name_HV_ARM64_REGISTER_Q1: hv_register_name = 196609;
pub const hv_register_name_HV_ARM64_REGISTER_Q2: hv_register_name = 196610;
pub const hv_register_name_HV_ARM64_REGISTER_Q3: hv_register_name = 196611;
pub const hv_register_name_HV_ARM64_REGISTER_Q4: hv_register_name = 196612;
pub const hv_register_name_HV_ARM64_REGISTER_Q5: hv_register_name = 196613;
pub const hv_register_name_HV_ARM64_REGISTER_Q6: hv_register_name = 196614;
pub const hv_register_name_HV_ARM64_REGISTER_Q7: hv_register_name = 196615;
pub const hv_register_name_HV_ARM64_REGISTER_Q8: hv_register_name = 196616;
pub const hv_register_name_HV_ARM64_REGISTER_Q9: hv_register_name = 196617;
pub const hv_register_name_HV_ARM64_REGISTER_Q10: hv_register_name = 196618;
pub const hv_register_name_HV_ARM64_REGISTER_Q11: hv_register_name = 196619;
pub const hv_register_name_HV_ARM64_REGISTER_Q12: hv_register_name = 196620;
pub const hv_register_name_HV_ARM64_REGISTER_Q13: hv_register_name = 196621;
pub const hv_register_name_HV_ARM64_REGISTER_Q14: hv_register_name = 196622;
pub const hv_register_name_HV_ARM64_REGISTER_Q15: hv_register_name = 196623;
pub const hv_register_name_HV_ARM64_REGISTER_Q16: hv_register_name = 196624;
pub const hv_register_name_HV_ARM64_REGISTER_Q17: hv_register_name = 196625;
pub const hv_register_name_HV_ARM64_REGISTER_Q18: hv_register_name = 196626;
pub const hv_register_name_HV_ARM64_REGISTER_Q19: hv_register_name = 196627;
pub const hv_register_name_HV_ARM64_REGISTER_Q20: hv_register_name = 196628;
pub const hv_register_name_HV_ARM64_REGISTER_Q21: hv_register_name = 196629;
pub const hv_register_name_HV_ARM64_REGISTER_Q22: hv_register_name = 196630;
pub const hv_register_name_HV_ARM64_REGISTER_Q23: hv_register_name = 196631;
pub const hv_register_name_HV_ARM64_REGISTER_Q24: hv_register_name = 196632;
pub const hv_register_name_HV_ARM64_REGISTER_Q25: hv_register_name = 196633;
pub const hv_register_name_HV_ARM64_REGISTER_Q26: hv_register_name = 196634;
pub const hv_register_name_HV_ARM64_REGISTER_Q27: hv_register_name = 196635;
pub const hv_register_name_HV_ARM64_REGISTER_Q28: hv_register_name = 196636;
pub const hv_register_name_HV_ARM64_REGISTER_Q29: hv_register_name = 196637;
pub const hv_register_name_HV_ARM64_REGISTER_Q30: hv_register_name = 196638;
pub const hv_register_name_HV_ARM64_REGISTER_Q31: hv_register_name = 196639;
pub const hv_register_name_HV_ARM64_REGISTER_Z0: hv_register_name = 196864;
pub const hv_register_name_HV_ARM64_REGISTER_Z1: hv_register_name = 196865;
pub const hv_register_name_HV_ARM64_REGISTER_Z2: hv_register_name = 196866;
pub const hv_register_name_HV_ARM64_REGISTER_Z3: hv_register_name = 196867;
pub const hv_register_name_HV_ARM64_REGISTER_Z4: hv_register_name = 196868;
pub const hv_register_name_HV_ARM64_REGISTER_Z5: hv_register_name = 196869;
pub const hv_register_name_HV_ARM64_REGISTER_Z6: hv_register_name = 196870;
pub const hv_register_name_HV_ARM64_REGISTER_Z7: hv_register_name = 196871;
pub const hv_register_name_HV_ARM64_REGISTER_Z8: hv_register_name = 196872;
pub const hv_register_name_HV_ARM64_REGISTER_Z9: hv_register_name = 196873;
pub const hv_register_name_HV_ARM64_REGISTER_Z10: hv_register_name = 196874;
pub const hv_register_name_HV_ARM64_REGISTER_Z11: hv_register_name = 196875;
pub const hv_register_name_HV_ARM64_REGISTER_Z12: hv_register_name = 196876;
pub const hv_register_name_HV_ARM64_REGISTER_Z13: hv_register_name = 196877;
pub const hv_register_name_HV_ARM64_REGISTER_Z14: hv_register_name = 196878;
pub const hv_register_name_HV_ARM64_REGISTER_Z15: hv_register_name = 196879;
pub const hv_register_name_HV_ARM64_REGISTER_Z16: hv_register_name = 196880;
pub const hv_register_name_HV_ARM64_REGISTER_Z17: hv_register_name = 196881;
pub const hv_register_name_HV_ARM64_REGISTER_Z18: hv_register_name = 196882;
pub const hv_register_name_HV_ARM64_REGISTER_Z19: hv_register_name = 196883;
pub const hv_register_name_HV_ARM64_REGISTER_Z20: hv_register_name = 196884;
pub const hv_register_name_HV_ARM64_REGISTER_Z21: hv_register_name = 196885;
pub const hv_register_name_HV_ARM64_REGISTER_Z22: hv_register_name = 196886;
pub const hv_register_name_HV_ARM64_REGISTER_Z23: hv_register_name = 196887;
pub const hv_register_name_HV_ARM64_REGISTER_Z24: hv_register_name = 196888;
pub const hv_register_name_HV_ARM64_REGISTER_Z25: hv_register_name = 196889;
pub const hv_register_name_HV_ARM64_REGISTER_Z26: hv_register_name = 196890;
pub const hv_register_name_HV_ARM64_REGISTER_Z27: hv_register_name = 196891;
pub const hv_register_name_HV_ARM64_REGISTER_Z28: hv_register_name = 196892;
pub const hv_register_name_HV_ARM64_REGISTER_Z29: hv_register_name = 196893;
pub const hv_register_name_HV_ARM64_REGISTER_Z30: hv_register_name = 196894;
pub const hv_register_name_HV_ARM64_REGISTER_Z31: hv_register_name = 196895;
pub const hv_register_name_HV_ARM64_REGISTER_P0: hv_register_name = 196896;
pub const hv_register_name_HV_ARM64_REGISTER_P1: hv_register_name = 196897;
pub const hv_register_name_HV_ARM64_REGISTER_P2: hv_register_name = 196898;
pub const hv_register_name_HV_ARM64_REGISTER_P3: hv_register_name = 196899;
pub const hv_register_name_HV_ARM64_REGISTER_P4: hv_register_name = 196900;
pub const hv_register_name_HV_ARM64_REGISTER_P5: hv_register_name = 196901;
pub const hv_register_name_HV_ARM64_REGISTER_P6: hv_register_name = 196902;
pub const hv_register_name_HV_ARM64_REGISTER_P7: hv_register_name = 196903;
pub const hv_register_name_HV_ARM64_REGISTER_P8: hv_register_name = 196904;
pub const hv_register_name_HV_ARM64_REGISTER_P9: hv_register_name = 196905;
pub const hv_register_name_HV_ARM64_REGISTER_P10: hv_register_name = 196906;
pub const hv_register_name_HV_ARM64_REGISTER_P11: hv_register_name = 196907;
pub const hv_register_name_HV_ARM64_REGISTER_P12: hv_register_name = 196908;
pub const hv_register_name_HV_ARM64_REGISTER_P13: hv_register_name = 196909;
pub const hv_register_name_HV_ARM64_REGISTER_P14: hv_register_name = 196910;
pub const hv_register_name_HV_ARM64_REGISTER_P15: hv_register_name = 196911;
pub const hv_register_name_HV_ARM64_REGISTER_FFR: hv_register_name = 196912;
pub const hv_register_name_HV_ARM64_REGISTER_CURRENT_EL: hv_register_name = 135171;
pub const hv_register_name_HV_ARM64_REGISTER_DAIF: hv_register_name = 135172;
pub const hv_register_name_HV_ARM64_REGISTER_DIT: hv_register_name = 135173;
pub const hv_register_name_HV_ARM64_REGISTER_PSTATE: hv_register_name = 131107;
pub const hv_register_name_HV_ARM64_REGISTER_ELR_EL1: hv_register_name = 262165;
pub const hv_register_name_HV_ARM64_REGISTER_ELR_EL2: hv_register_name = 135169;
pub const hv_register_name_HV_ARM64_REGISTER_ELR_ELX: hv_register_name = 135180;
pub const hv_register_name_HV_ARM64_REGISTER_FPCR: hv_register_name = 262162;
pub const hv_register_name_HV_ARM64_REGISTER_FPSR: hv_register_name = 262163;
pub const hv_register_name_HV_ARM64_REGISTER_NZCV: hv_register_name = 135174;
pub const hv_register_name_HV_ARM64_REGISTER_PAN: hv_register_name = 135175;
pub const hv_register_name_HV_ARM64_REGISTER_SP: hv_register_name = 131103;
pub const hv_register_name_HV_ARM64_REGISTER_SP_EL0: hv_register_name = 131104;
pub const hv_register_name_HV_ARM64_REGISTER_SP_EL1: hv_register_name = 131105;
pub const hv_register_name_HV_ARM64_REGISTER_SP_EL2: hv_register_name = 135168;
pub const hv_register_name_HV_ARM64_REGISTER_SP_SEL: hv_register_name = 135176;
pub const hv_register_name_HV_ARM64_REGISTER_SPSR_EL1: hv_register_name = 262164;
pub const hv_register_name_HV_ARM64_REGISTER_SPSR_EL2: hv_register_name = 135170;
pub const hv_register_name_HV_ARM64_REGISTER_SPSR_ELX: hv_register_name = 135181;
pub const hv_register_name_HV_ARM64_REGISTER_SSBS: hv_register_name = 135177;
pub const hv_register_name_HV_ARM64_REGISTER_TCO: hv_register_name = 135178;
pub const hv_register_name_HV_ARM64_REGISTER_UAO: hv_register_name = 135179;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MIDR_EL1: hv_register_name = 139264;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES01_EL1: hv_register_name = 139265;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES02_EL1: hv_register_name = 139266;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES03_EL1: hv_register_name = 139267;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES04_EL1: hv_register_name = 139268;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MPIDR_EL1: hv_register_name = 139269;
pub const hv_register_name_HV_ARM64_REGISTER_ID_REVIDR_EL1: hv_register_name = 139270;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES07_EL1: hv_register_name = 139271;
pub const hv_register_name_HV_ARM64_REGISTER_ID_PFR0_EL1: hv_register_name = 139272;
pub const hv_register_name_HV_ARM64_REGISTER_ID_PFR1_EL1: hv_register_name = 139273;
pub const hv_register_name_HV_ARM64_REGISTER_ID_DFR0_EL1: hv_register_name = 139274;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES13_EL1: hv_register_name = 139275;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MMFR0_EL1: hv_register_name = 139276;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MMFR1_EL1: hv_register_name = 139277;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MMFR2_EL1: hv_register_name = 139278;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MMFR3_EL1: hv_register_name = 139279;
pub const hv_register_name_HV_ARM64_REGISTER_ID_ISAR0_EL1: hv_register_name = 139280;
pub const hv_register_name_HV_ARM64_REGISTER_ID_ISAR1_EL1: hv_register_name = 139281;
pub const hv_register_name_HV_ARM64_REGISTER_ID_ISAR2_EL1: hv_register_name = 139282;
pub const hv_register_name_HV_ARM64_REGISTER_ID_ISAR3_EL1: hv_register_name = 139283;
pub const hv_register_name_HV_ARM64_REGISTER_ID_ISAR4_EL1: hv_register_name = 139284;
pub const hv_register_name_HV_ARM64_REGISTER_ID_ISAR5_EL1: hv_register_name = 139285;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES26_EL1: hv_register_name = 139286;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES27_EL1: hv_register_name = 139287;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MVFR0_EL1: hv_register_name = 139288;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MVFR1_EL1: hv_register_name = 139289;
pub const hv_register_name_HV_ARM64_REGISTER_ID_MVFR2_EL1: hv_register_name = 139290;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES33_EL1: hv_register_name = 139291;
pub const hv_register_name_HV_ARM64_REGISTER_ID_PFR2_EL1: hv_register_name = 139292;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES35_EL1: hv_register_name = 139293;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES36_EL1: hv_register_name = 139294;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES37_EL1: hv_register_name = 139295;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_PFR0_EL1: hv_register_name = 139296;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_PFR1_EL1: hv_register_name = 139297;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_PFR2_EL1: hv_register_name = 139298;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES43_EL1: hv_register_name = 139299;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_ZFR0_EL1: hv_register_name = 139300;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_SMFR0_EL1: hv_register_name = 139301;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES46_EL1: hv_register_name = 139302;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES47_EL1: hv_register_name = 139303;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_DFR0_EL1: hv_register_name = 139304;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_DFR1_EL1: hv_register_name = 139305;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES52_EL1: hv_register_name = 139306;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES53_EL1: hv_register_name = 139307;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES54_EL1: hv_register_name = 139308;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES55_EL1: hv_register_name = 139309;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES56_EL1: hv_register_name = 139310;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES57_EL1: hv_register_name = 139311;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_ISAR0_EL1: hv_register_name = 139312;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_ISAR1_EL1: hv_register_name = 139313;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_ISAR2_EL1: hv_register_name = 139314;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES63_EL1: hv_register_name = 139315;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES64_EL1: hv_register_name = 139316;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES65_EL1: hv_register_name = 139317;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES66_EL1: hv_register_name = 139318;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES67_EL1: hv_register_name = 139319;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_MMFR0_EL1: hv_register_name = 139320;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_MMFR1_EL1: hv_register_name = 139321;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_MMFR2_EL1: hv_register_name = 139322;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_MMFR3_EL1: hv_register_name = 139323;
pub const hv_register_name_HV_ARM64_REGISTER_ID_AA64_MMFR4_EL1: hv_register_name = 139324;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES75_EL1: hv_register_name = 139325;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES76_EL1: hv_register_name = 139326;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES77_EL1: hv_register_name = 139327;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES80_EL1: hv_register_name = 139328;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES81_EL1: hv_register_name = 139329;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES82_EL1: hv_register_name = 139330;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES83_EL1: hv_register_name = 139331;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES84_EL1: hv_register_name = 139332;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES85_EL1: hv_register_name = 139333;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES86_EL1: hv_register_name = 139334;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES87_EL1: hv_register_name = 139335;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES90_EL1: hv_register_name = 139336;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES91_EL1: hv_register_name = 139337;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES92_EL1: hv_register_name = 139338;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES93_EL1: hv_register_name = 139339;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES94_EL1: hv_register_name = 139340;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES95_EL1: hv_register_name = 139341;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES96_EL1: hv_register_name = 139342;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES97_EL1: hv_register_name = 139343;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES100_EL1: hv_register_name = 139344;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES101_EL1: hv_register_name = 139345;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES102_EL1: hv_register_name = 139346;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES103_EL1: hv_register_name = 139347;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES104_EL1: hv_register_name = 139348;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES105_EL1: hv_register_name = 139349;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES106_EL1: hv_register_name = 139350;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES107_EL1: hv_register_name = 139351;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES110_EL1: hv_register_name = 139352;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES111_EL1: hv_register_name = 139353;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES112_EL1: hv_register_name = 139354;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES113_EL1: hv_register_name = 139355;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES114_EL1: hv_register_name = 139356;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES115_EL1: hv_register_name = 139357;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES116_EL1: hv_register_name = 139358;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES117_EL1: hv_register_name = 139359;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES120_EL1: hv_register_name = 139360;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES121_EL1: hv_register_name = 139361;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES122_EL1: hv_register_name = 139362;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES123_EL1: hv_register_name = 139363;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES124_EL1: hv_register_name = 139364;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES125_EL1: hv_register_name = 139365;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES126_EL1: hv_register_name = 139366;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES127_EL1: hv_register_name = 139367;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES130_EL1: hv_register_name = 139368;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES131_EL1: hv_register_name = 139369;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES132_EL1: hv_register_name = 139370;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES133_EL1: hv_register_name = 139371;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES134_EL1: hv_register_name = 139372;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES135_EL1: hv_register_name = 139373;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES136_EL1: hv_register_name = 139374;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES137_EL1: hv_register_name = 139375;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES140_EL1: hv_register_name = 139376;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES141_EL1: hv_register_name = 139377;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES142_EL1: hv_register_name = 139378;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES143_EL1: hv_register_name = 139379;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES144_EL1: hv_register_name = 139380;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES145_EL1: hv_register_name = 139381;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES146_EL1: hv_register_name = 139382;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES147_EL1: hv_register_name = 139383;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES150_EL1: hv_register_name = 139384;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES151_EL1: hv_register_name = 139385;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES152_EL1: hv_register_name = 139386;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES153_EL1: hv_register_name = 139387;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES154_EL1: hv_register_name = 139388;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES155_EL1: hv_register_name = 139389;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES156_EL1: hv_register_name = 139390;
pub const hv_register_name_HV_ARM64_REGISTER_ID_RES157_EL1: hv_register_name = 139391;
pub const hv_register_name_HV_ARM64_REGISTER_ACCDATA_EL1: hv_register_name = 262176;
pub const hv_register_name_HV_ARM64_REGISTER_ACTLR_EL1: hv_register_name = 262147;
pub const hv_register_name_HV_ARM64_REGISTER_ACTLR_EL2: hv_register_name = 262177;
pub const hv_register_name_HV_ARM64_REGISTER_AFSR0_EL1: hv_register_name = 262166;
pub const hv_register_name_HV_ARM64_REGISTER_AFSR0_EL2: hv_register_name = 262178;
pub const hv_register_name_HV_ARM64_REGISTER_AFSR0_ELX: hv_register_name = 262259;
pub const hv_register_name_HV_ARM64_REGISTER_AFSR1_EL1: hv_register_name = 262167;
pub const hv_register_name_HV_ARM64_REGISTER_AFSR1_EL2: hv_register_name = 262179;
pub const hv_register_name_HV_ARM64_REGISTER_AFSR1_ELX: hv_register_name = 262260;
pub const hv_register_name_HV_ARM64_REGISTER_AIDR_EL1: hv_register_name = 262180;
pub const hv_register_name_HV_ARM64_REGISTER_AMAIR_EL1: hv_register_name = 262168;
pub const hv_register_name_HV_ARM64_REGISTER_AMAIR_EL2: hv_register_name = 262181;
pub const hv_register_name_HV_ARM64_REGISTER_AMAIR_ELX: hv_register_name = 262261;
pub const hv_register_name_HV_ARM64_REGISTER_APD_A_KEY_HI_EL1: hv_register_name = 262182;
pub const hv_register_name_HV_ARM64_REGISTER_APD_A_KEY_LO_EL1: hv_register_name = 262183;
pub const hv_register_name_HV_ARM64_REGISTER_APD_B_KEY_HI_EL1: hv_register_name = 262184;
pub const hv_register_name_HV_ARM64_REGISTER_APD_B_KEY_LO_EL1: hv_register_name = 262185;
pub const hv_register_name_HV_ARM64_REGISTER_APG_A_KEY_HI_EL1: hv_register_name = 262186;
pub const hv_register_name_HV_ARM64_REGISTER_APG_A_KEY_LO_EL1: hv_register_name = 262187;
pub const hv_register_name_HV_ARM64_REGISTER_API_A_KEY_HI_EL1: hv_register_name = 262188;
pub const hv_register_name_HV_ARM64_REGISTER_API_A_KEY_LO_EL1: hv_register_name = 262189;
pub const hv_register_name_HV_ARM64_REGISTER_API_B_KEY_HI_EL1: hv_register_name = 262190;
pub const hv_register_name_HV_ARM64_REGISTER_API_B_KEY_LO_EL1: hv_register_name = 262191;
pub const hv_register_name_HV_ARM64_REGISTER_CCSIDR_EL1: hv_register_name = 262192;
pub const hv_register_name_HV_ARM64_REGISTER_CCSIDR2_EL1: hv_register_name = 262193;
pub const hv_register_name_HV_ARM64_REGISTER_CLIDR_EL1: hv_register_name = 262194;
pub const hv_register_name_HV_ARM64_REGISTER_CONTEXTIDR_EL1: hv_register_name = 262157;
pub const hv_register_name_HV_ARM64_REGISTER_CONTEXTIDR_EL2: hv_register_name = 262195;
pub const hv_register_name_HV_ARM64_REGISTER_CONTEXTIDR_ELX: hv_register_name = 262262;
pub const hv_register_name_HV_ARM64_REGISTER_CPACR_EL1: hv_register_name = 262148;
pub const hv_register_name_HV_ARM64_REGISTER_CPTR_EL2: hv_register_name = 262196;
pub const hv_register_name_HV_ARM64_REGISTER_CPACR_ELX: hv_register_name = 262263;
pub const hv_register_name_HV_ARM64_REGISTER_CSSELR_EL1: hv_register_name = 262197;
pub const hv_register_name_HV_ARM64_REGISTER_CTR_EL0: hv_register_name = 262198;
pub const hv_register_name_HV_ARM64_REGISTER_DACR32_EL2: hv_register_name = 262199;
pub const hv_register_name_HV_ARM64_REGISTER_DCZID_EL0: hv_register_name = 262200;
pub const hv_register_name_HV_ARM64_REGISTER_ESR_EL1: hv_register_name = 262152;
pub const hv_register_name_HV_ARM64_REGISTER_ESR_EL2: hv_register_name = 262201;
pub const hv_register_name_HV_ARM64_REGISTER_ESR_ELX: hv_register_name = 262264;
pub const hv_register_name_HV_ARM64_REGISTER_FAR_EL1: hv_register_name = 262153;
pub const hv_register_name_HV_ARM64_REGISTER_FAR_EL2: hv_register_name = 262202;
pub const hv_register_name_HV_ARM64_REGISTER_FAR_ELX: hv_register_name = 262265;
pub const hv_register_name_HV_ARM64_REGISTER_FPEXC32_EL2: hv_register_name = 262203;
pub const hv_register_name_HV_ARM64_REGISTER_GCR_EL1: hv_register_name = 262204;
pub const hv_register_name_HV_ARM64_REGISTER_GMID_EL1: hv_register_name = 262205;
pub const hv_register_name_HV_ARM64_REGISTER_HACR_EL2: hv_register_name = 262206;
pub const hv_register_name_HV_ARM64_REGISTER_HAFGRTR_EL2: hv_register_name = 262207;
pub const hv_register_name_HV_ARM64_REGISTER_HCR_EL2: hv_register_name = 262208;
pub const hv_register_name_HV_ARM64_REGISTER_HCRX_EL2: hv_register_name = 262209;
pub const hv_register_name_HV_ARM64_REGISTER_HDFGRTR_EL2: hv_register_name = 262210;
pub const hv_register_name_HV_ARM64_REGISTER_HDFGWTR_EL2: hv_register_name = 262211;
pub const hv_register_name_HV_ARM64_REGISTER_HFGITR_EL2: hv_register_name = 262212;
pub const hv_register_name_HV_ARM64_REGISTER_HFGRTR_EL2: hv_register_name = 262213;
pub const hv_register_name_HV_ARM64_REGISTER_HFGWTR_EL2: hv_register_name = 262214;
pub const hv_register_name_HV_ARM64_REGISTER_HPFAR_EL2: hv_register_name = 262215;
pub const hv_register_name_HV_ARM64_REGISTER_HSTR_EL2: hv_register_name = 262216;
pub const hv_register_name_HV_ARM64_REGISTER_IFSR32_EL2: hv_register_name = 262217;
pub const hv_register_name_HV_ARM64_REGISTER_ISR_EL1: hv_register_name = 262218;
pub const hv_register_name_HV_ARM64_REGISTER_LORC_EL1: hv_register_name = 262219;
pub const hv_register_name_HV_ARM64_REGISTER_LOREA_EL1: hv_register_name = 262220;
pub const hv_register_name_HV_ARM64_REGISTER_LORID_EL1: hv_register_name = 262221;
pub const hv_register_name_HV_ARM64_REGISTER_LORN_EL1: hv_register_name = 262222;
pub const hv_register_name_HV_ARM64_REGISTER_LORSA_EL1: hv_register_name = 262223;
pub const hv_register_name_HV_ARM64_REGISTER_MAIR_EL1: hv_register_name = 262155;
pub const hv_register_name_HV_ARM64_REGISTER_MAIR_EL2: hv_register_name = 262224;
pub const hv_register_name_HV_ARM64_REGISTER_MAIR_ELX: hv_register_name = 262266;
pub const hv_register_name_HV_ARM64_REGISTER_MIDR_EL1: hv_register_name = 262225;
pub const hv_register_name_HV_ARM64_REGISTER_MPIDR_EL1: hv_register_name = 262145;
pub const hv_register_name_HV_ARM64_REGISTER_MVFR0_EL1: hv_register_name = 262226;
pub const hv_register_name_HV_ARM64_REGISTER_MVFR1_EL1: hv_register_name = 262227;
pub const hv_register_name_HV_ARM64_REGISTER_MVFR2_EL1: hv_register_name = 262228;
pub const hv_register_name_HV_ARM64_REGISTER_PAR_EL1: hv_register_name = 262154;
pub const hv_register_name_HV_ARM64_REGISTER_REVIDR_EL1: hv_register_name = 262229;
pub const hv_register_name_HV_ARM64_REGISTER_RGSR_EL1: hv_register_name = 262230;
pub const hv_register_name_HV_ARM64_REGISTER_RNDR: hv_register_name = 262231;
pub const hv_register_name_HV_ARM64_REGISTER_RNDRRS: hv_register_name = 262232;
pub const hv_register_name_HV_ARM64_REGISTER_SCTLR_EL1: hv_register_name = 262146;
pub const hv_register_name_HV_ARM64_REGISTER_SCTLR_EL2: hv_register_name = 262233;
pub const hv_register_name_HV_ARM64_REGISTER_SCTLR_ELX: hv_register_name = 262267;
pub const hv_register_name_HV_ARM64_REGISTER_SCXTNUM_EL0: hv_register_name = 262234;
pub const hv_register_name_HV_ARM64_REGISTER_SCXTNUM_EL1: hv_register_name = 262235;
pub const hv_register_name_HV_ARM64_REGISTER_SCXTNUM_EL2: hv_register_name = 262236;
pub const hv_register_name_HV_ARM64_REGISTER_SMCR_EL1: hv_register_name = 262237;
pub const hv_register_name_HV_ARM64_REGISTER_SMCR_EL2: hv_register_name = 262238;
pub const hv_register_name_HV_ARM64_REGISTER_SMIDR_EL1: hv_register_name = 262239;
pub const hv_register_name_HV_ARM64_REGISTER_SMPRI_EL1: hv_register_name = 262240;
pub const hv_register_name_HV_ARM64_REGISTER_SMPRIMAP_EL2: hv_register_name = 262241;
pub const hv_register_name_HV_ARM64_REGISTER_TCR_EL1: hv_register_name = 262151;
pub const hv_register_name_HV_ARM64_REGISTER_TCR_EL2: hv_register_name = 262242;
pub const hv_register_name_HV_ARM64_REGISTER_TCR_ELX: hv_register_name = 262268;
pub const hv_register_name_HV_ARM64_REGISTER_TFSRE0_EL1: hv_register_name = 262243;
pub const hv_register_name_HV_ARM64_REGISTER_TFSR_EL1: hv_register_name = 262244;
pub const hv_register_name_HV_ARM64_REGISTER_TFSR_EL2: hv_register_name = 262245;
pub const hv_register_name_HV_ARM64_REGISTER_TPIDR2_EL0: hv_register_name = 262246;
pub const hv_register_name_HV_ARM64_REGISTER_TPIDR_EL0: hv_register_name = 262161;
pub const hv_register_name_HV_ARM64_REGISTER_TPIDR_EL1: hv_register_name = 262158;
pub const hv_register_name_HV_ARM64_REGISTER_TPIDR_EL2: hv_register_name = 262247;
pub const hv_register_name_HV_ARM64_REGISTER_TPIDRRO_EL0: hv_register_name = 262160;
pub const hv_register_name_HV_ARM64_REGISTER_TTBR0_EL1: hv_register_name = 262149;
pub const hv_register_name_HV_ARM64_REGISTER_TTBR0_EL2: hv_register_name = 262248;
pub const hv_register_name_HV_ARM64_REGISTER_TTBR0_ELX: hv_register_name = 262269;
pub const hv_register_name_HV_ARM64_REGISTER_TTBR1_EL1: hv_register_name = 262150;
pub const hv_register_name_HV_ARM64_REGISTER_TTBR1_EL2: hv_register_name = 262270;
pub const hv_register_name_HV_ARM64_REGISTER_TTBR1_ELX: hv_register_name = 262271;
pub const hv_register_name_HV_ARM64_REGISTER_VBAR_EL1: hv_register_name = 262156;
pub const hv_register_name_HV_ARM64_REGISTER_VBAR_EL2: hv_register_name = 262249;
pub const hv_register_name_HV_ARM64_REGISTER_VBAR_ELX: hv_register_name = 262272;
pub const hv_register_name_HV_ARM64_REGISTER_VMPIDR_EL2: hv_register_name = 262250;
pub const hv_register_name_HV_ARM64_REGISTER_VNCR_EL2: hv_register_name = 262251;
pub const hv_register_name_HV_ARM64_REGISTER_VPIDR_EL2: hv_register_name = 262252;
pub const hv_register_name_HV_ARM64_REGISTER_VSTCR_EL2: hv_register_name = 262253;
pub const hv_register_name_HV_ARM64_REGISTER_VSTTBR_EL2: hv_register_name = 262254;
pub const hv_register_name_HV_ARM64_REGISTER_VTCR_EL2: hv_register_name = 262255;
pub const hv_register_name_HV_ARM64_REGISTER_VTTBR_EL2: hv_register_name = 262256;
pub const hv_register_name_HV_ARM64_REGISTER_ZCR_EL1: hv_register_name = 262257;
pub const hv_register_name_HV_ARM64_REGISTER_ZCR_EL2: hv_register_name = 262258;
pub const hv_register_name_HV_ARM64_REGISTER_ZCR_ELX: hv_register_name = 262273;
pub const hv_register_name_HV_ARM64_REGISTER_DBGAUTHSTATUS_EL1: hv_register_name = 327744;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR0_EL1: hv_register_name = 327680;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR1_EL1: hv_register_name = 327681;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR2_EL1: hv_register_name = 327682;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR3_EL1: hv_register_name = 327683;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR4_EL1: hv_register_name = 327684;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR5_EL1: hv_register_name = 327685;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR6_EL1: hv_register_name = 327686;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR7_EL1: hv_register_name = 327687;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR8_EL1: hv_register_name = 327688;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR9_EL1: hv_register_name = 327689;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR10_EL1: hv_register_name = 327690;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR11_EL1: hv_register_name = 327691;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR12_EL1: hv_register_name = 327692;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR13_EL1: hv_register_name = 327693;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR14_EL1: hv_register_name = 327694;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBCR15_EL1: hv_register_name = 327695;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR0_EL1: hv_register_name = 327712;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR1_EL1: hv_register_name = 327713;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR2_EL1: hv_register_name = 327714;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR3_EL1: hv_register_name = 327715;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR4_EL1: hv_register_name = 327716;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR5_EL1: hv_register_name = 327717;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR6_EL1: hv_register_name = 327718;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR7_EL1: hv_register_name = 327719;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR8_EL1: hv_register_name = 327720;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR9_EL1: hv_register_name = 327721;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR10_EL1: hv_register_name = 327722;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR11_EL1: hv_register_name = 327723;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR12_EL1: hv_register_name = 327724;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR13_EL1: hv_register_name = 327725;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR14_EL1: hv_register_name = 327726;
pub const hv_register_name_HV_ARM64_REGISTER_DBGBVR15_EL1: hv_register_name = 327727;
pub const hv_register_name_HV_ARM64_REGISTER_DBGCLAIMCLR_EL1: hv_register_name = 327745;
pub const hv_register_name_HV_ARM64_REGISTER_DBGCLAIMSET_EL1: hv_register_name = 327746;
pub const hv_register_name_HV_ARM64_REGISTER_DBGDTRRX_EL0: hv_register_name = 327747;
pub const hv_register_name_HV_ARM64_REGISTER_DBGDTRTX_EL0: hv_register_name = 327748;
pub const hv_register_name_HV_ARM64_REGISTER_DBGPRCR_EL1: hv_register_name = 327749;
pub const hv_register_name_HV_ARM64_REGISTER_DBGVCR32_EL2: hv_register_name = 327750;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR0_EL1: hv_register_name = 327696;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR1_EL1: hv_register_name = 327697;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR2_EL1: hv_register_name = 327698;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR3_EL1: hv_register_name = 327699;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR4_EL1: hv_register_name = 327700;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR5_EL1: hv_register_name = 327701;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR6_EL1: hv_register_name = 327702;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR7_EL1: hv_register_name = 327703;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR8_EL1: hv_register_name = 327704;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR9_EL1: hv_register_name = 327705;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR10_EL1: hv_register_name = 327706;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR11_EL1: hv_register_name = 327707;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR12_EL1: hv_register_name = 327708;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR13_EL1: hv_register_name = 327709;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR14_EL1: hv_register_name = 327710;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWCR15_EL1: hv_register_name = 327711;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR0_EL1: hv_register_name = 327728;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR1_EL1: hv_register_name = 327729;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR2_EL1: hv_register_name = 327730;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR3_EL1: hv_register_name = 327731;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR4_EL1: hv_register_name = 327732;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR5_EL1: hv_register_name = 327733;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR6_EL1: hv_register_name = 327734;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR7_EL1: hv_register_name = 327735;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR8_EL1: hv_register_name = 327736;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR9_EL1: hv_register_name = 327737;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR10_EL1: hv_register_name = 327738;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR11_EL1: hv_register_name = 327739;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR12_EL1: hv_register_name = 327740;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR13_EL1: hv_register_name = 327741;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR14_EL1: hv_register_name = 327742;
pub const hv_register_name_HV_ARM64_REGISTER_DBGWVR15_EL1: hv_register_name = 327743;
pub const hv_register_name_HV_ARM64_REGISTER_DLR_EL0: hv_register_name = 327751;
pub const hv_register_name_HV_ARM64_REGISTER_DSPSR_EL0: hv_register_name = 327752;
pub const hv_register_name_HV_ARM64_REGISTER_MDCCINT_EL1: hv_register_name = 327753;
pub const hv_register_name_HV_ARM64_REGISTER_MDCCSR_EL0: hv_register_name = 327754;
pub const hv_register_name_HV_ARM64_REGISTER_MDCR_EL2: hv_register_name = 327755;
pub const hv_register_name_HV_ARM64_REGISTER_MDRAR_EL1: hv_register_name = 327756;
pub const hv_register_name_HV_ARM64_REGISTER_MDSCR_EL1: hv_register_name = 327757;
pub const hv_register_name_HV_ARM64_REGISTER_OSDLR_EL1: hv_register_name = 327758;
pub const hv_register_name_HV_ARM64_REGISTER_OSDTRRX_EL1: hv_register_name = 327759;
pub const hv_register_name_HV_ARM64_REGISTER_OSDTRTX_EL1: hv_register_name = 327760;
pub const hv_register_name_HV_ARM64_REGISTER_OSECCR_EL1: hv_register_name = 327761;
pub const hv_register_name_HV_ARM64_REGISTER_OSLAR_EL1: hv_register_name = 327762;
pub const hv_register_name_HV_ARM64_REGISTER_OSLSR_EL1: hv_register_name = 327763;
pub const hv_register_name_HV_ARM64_REGISTER_SDER32_EL2: hv_register_name = 327764;
pub const hv_register_name_HV_ARM64_REGISTER_TRFCR_EL1: hv_register_name = 327765;
pub const hv_register_name_HV_ARM64_REGISTER_TRFCR_EL2: hv_register_name = 327766;
pub const hv_register_name_HV_ARM64_REGISTER_TRFCR_ELX: hv_register_name = 327767;
pub const hv_register_name_HV_ARM64_REGISTER_PMCCFILTR_EL0: hv_register_name = 335872;
pub const hv_register_name_HV_ARM64_REGISTER_PMCCNTR_EL0: hv_register_name = 335873;
pub const hv_register_name_HV_ARM64_REGISTER_PMCEID0_EL0: hv_register_name = 335874;
pub const hv_register_name_HV_ARM64_REGISTER_PMCEID1_EL0: hv_register_name = 335875;
pub const hv_register_name_HV_ARM64_REGISTER_PMCNTENCLR_EL0: hv_register_name = 335876;
pub const hv_register_name_HV_ARM64_REGISTER_PMCNTENSET_EL0: hv_register_name = 335877;
pub const hv_register_name_HV_ARM64_REGISTER_PMCR_EL0: hv_register_name = 335878;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR0_EL0: hv_register_name = 335879;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR1_EL0: hv_register_name = 335880;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR2_EL0: hv_register_name = 335881;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR3_EL0: hv_register_name = 335882;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR4_EL0: hv_register_name = 335883;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR5_EL0: hv_register_name = 335884;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR6_EL0: hv_register_name = 335885;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR7_EL0: hv_register_name = 335886;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR8_EL0: hv_register_name = 335887;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR9_EL0: hv_register_name = 335888;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR10_EL0: hv_register_name = 335889;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR11_EL0: hv_register_name = 335890;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR12_EL0: hv_register_name = 335891;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR13_EL0: hv_register_name = 335892;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR14_EL0: hv_register_name = 335893;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR15_EL0: hv_register_name = 335894;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR16_EL0: hv_register_name = 335895;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR17_EL0: hv_register_name = 335896;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR18_EL0: hv_register_name = 335897;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR19_EL0: hv_register_name = 335898;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR20_EL0: hv_register_name = 335899;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR21_EL0: hv_register_name = 335900;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR22_EL0: hv_register_name = 335901;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR23_EL0: hv_register_name = 335902;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR24_EL0: hv_register_name = 335903;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR25_EL0: hv_register_name = 335904;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR26_EL0: hv_register_name = 335905;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR27_EL0: hv_register_name = 335906;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR28_EL0: hv_register_name = 335907;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR29_EL0: hv_register_name = 335908;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVCNTR30_EL0: hv_register_name = 335909;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER0_EL0: hv_register_name = 335910;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER1_EL0: hv_register_name = 335911;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER2_EL0: hv_register_name = 335912;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER3_EL0: hv_register_name = 335913;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER4_EL0: hv_register_name = 335914;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER5_EL0: hv_register_name = 335915;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER6_EL0: hv_register_name = 335916;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER7_EL0: hv_register_name = 335917;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER8_EL0: hv_register_name = 335918;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER9_EL0: hv_register_name = 335919;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER10_EL0: hv_register_name = 335920;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER11_EL0: hv_register_name = 335921;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER12_EL0: hv_register_name = 335922;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER13_EL0: hv_register_name = 335923;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER14_EL0: hv_register_name = 335924;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER15_EL0: hv_register_name = 335925;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER16_EL0: hv_register_name = 335926;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER17_EL0: hv_register_name = 335927;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER18_EL0: hv_register_name = 335928;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER19_EL0: hv_register_name = 335929;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER20_EL0: hv_register_name = 335930;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER21_EL0: hv_register_name = 335931;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER22_EL0: hv_register_name = 335932;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER23_EL0: hv_register_name = 335933;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER24_EL0: hv_register_name = 335934;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER25_EL0: hv_register_name = 335935;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER26_EL0: hv_register_name = 335936;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER27_EL0: hv_register_name = 335937;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER28_EL0: hv_register_name = 335938;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER29_EL0: hv_register_name = 335939;
pub const hv_register_name_HV_ARM64_REGISTER_PMEVTYPER30_EL0: hv_register_name = 335940;
pub const hv_register_name_HV_ARM64_REGISTER_PMINTENCLR_EL1: hv_register_name = 335941;
pub const hv_register_name_HV_ARM64_REGISTER_PMINTENSET_EL1: hv_register_name = 335942;
pub const hv_register_name_HV_ARM64_REGISTER_PMMIR_EL1: hv_register_name = 335943;
pub const hv_register_name_HV_ARM64_REGISTER_PMOVSCLR_EL0: hv_register_name = 335944;
pub const hv_register_name_HV_ARM64_REGISTER_PMOVSSET_EL0: hv_register_name = 335945;
pub const hv_register_name_HV_ARM64_REGISTER_PMSELR_EL0: hv_register_name = 335946;
pub const hv_register_name_HV_ARM64_REGISTER_PMSWINC_EL0: hv_register_name = 335947;
pub const hv_register_name_HV_ARM64_REGISTER_PMUSERENR_EL0: hv_register_name = 335948;
pub const hv_register_name_HV_ARM64_REGISTER_PMXEVCNTR_EL0: hv_register_name = 335949;
pub const hv_register_name_HV_ARM64_REGISTER_PMXEVTYPER_EL0: hv_register_name = 335950;
pub const hv_register_name_HV_ARM64_REGISTER_AMEVCNTR00_EL0: hv_register_name = 339968;
pub const hv_register_name_HV_ARM64_REGISTER_AMEVCNTR01_EL0: hv_register_name = 339969;
pub const hv_register_name_HV_ARM64_REGISTER_AMEVCNTR02_EL0: hv_register_name = 339970;
pub const hv_register_name_HV_ARM64_REGISTER_AMEVCNTR03_EL0: hv_register_name = 339971;
pub const hv_register_name_HV_ARM64_REGISTER_PMBIDR_EL1: hv_register_name = 344064;
pub const hv_register_name_HV_ARM64_REGISTER_PMBLIMITR_EL1: hv_register_name = 344065;
pub const hv_register_name_HV_ARM64_REGISTER_PMBPTR_EL1: hv_register_name = 344066;
pub const hv_register_name_HV_ARM64_REGISTER_PMBSR_EL1: hv_register_name = 344067;
pub const hv_register_name_HV_ARM64_REGISTER_PMSCR_EL1: hv_register_name = 344068;
pub const hv_register_name_HV_ARM64_REGISTER_PMSCR_EL2: hv_register_name = 344069;
pub const hv_register_name_HV_ARM64_REGISTER_PMSEVFR_EL1: hv_register_name = 344070;
pub const hv_register_name_HV_ARM64_REGISTER_PMSFCR_EL1: hv_register_name = 344071;
pub const hv_register_name_HV_ARM64_REGISTER_PMSICR_EL1: hv_register_name = 344072;
pub const hv_register_name_HV_ARM64_REGISTER_PMSIDR_EL1: hv_register_name = 344073;
pub const hv_register_name_HV_ARM64_REGISTER_PMSIRR_EL1: hv_register_name = 344074;
pub const hv_register_name_HV_ARM64_REGISTER_PMSLATFR_EL1: hv_register_name = 344075;
pub const hv_register_name_HV_ARM64_REGISTER_PMSNEVFR_EL1: hv_register_name = 344076;
pub const hv_register_name_HV_ARM64_REGISTER_DISR_EL1: hv_register_name = 352256;
pub const hv_register_name_HV_ARM64_REGISTER_ERRIDR_EL1: hv_register_name = 352257;
pub const hv_register_name_HV_ARM64_REGISTER_ERRSELR_EL1: hv_register_name = 352258;
pub const hv_register_name_HV_ARM64_REGISTER_ERXADDR_EL1: hv_register_name = 352259;
pub const hv_register_name_HV_ARM64_REGISTER_ERXCTLR_EL1: hv_register_name = 352260;
pub const hv_register_name_HV_ARM64_REGISTER_ERRXFR_EL1: hv_register_name = 352261;
pub const hv_register_name_HV_ARM64_REGISTER_ERXMISC0_EL1: hv_register_name = 352262;
pub const hv_register_name_HV_ARM64_REGISTER_ERXMISC1_EL1: hv_register_name = 352263;
pub const hv_register_name_HV_ARM64_REGISTER_ERXMISC2_EL1: hv_register_name = 352264;
pub const hv_register_name_HV_ARM64_REGISTER_ERXMISC3_EL1: hv_register_name = 352265;
pub const hv_register_name_HV_ARM64_REGISTER_ERXPFGCDN_EL1: hv_register_name = 352266;
pub const hv_register_name_HV_ARM64_REGISTER_ERXPFGCTL_EL1: hv_register_name = 352267;
pub const hv_register_name_HV_ARM64_REGISTER_ERXPFGF_EL1: hv_register_name = 352268;
pub const hv_register_name_HV_ARM64_REGISTER_ERXSTATUS_EL1: hv_register_name = 352269;
pub const hv_register_name_HV_ARM64_REGISTER_VDISR_EL2: hv_register_name = 352270;
pub const hv_register_name_HV_ARM64_REGISTER_VSESR_EL2: hv_register_name = 352271;
pub const hv_register_name_HV_ARM64_REGISTER_CNTFRQ_EL0: hv_register_name = 360448;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHCTL_EL2: hv_register_name = 360449;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHP_CTL_EL2: hv_register_name = 360450;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHP_CVAL_EL2: hv_register_name = 360451;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHP_TVAL_EL2: hv_register_name = 360452;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHV_CTL_EL2: hv_register_name = 360453;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHV_CVAL_EL2: hv_register_name = 360454;
pub const hv_register_name_HV_ARM64_REGISTER_CNTHV_TVAL_EL2: hv_register_name = 360455;
pub const hv_register_name_HV_ARM64_REGISTER_CNTKCTL_EL1: hv_register_name = 360456;
pub const hv_register_name_HV_ARM64_REGISTER_CNTKCTL_ELX: hv_register_name = 360467;
pub const hv_register_name_HV_ARM64_REGISTER_CNTP_CTL_EL0: hv_register_name = 360457;
pub const hv_register_name_HV_ARM64_REGISTER_CNTP_CTL_ELX: hv_register_name = 360468;
pub const hv_register_name_HV_ARM64_REGISTER_CNTP_CVAL_EL0: hv_register_name = 360458;
pub const hv_register_name_HV_ARM64_REGISTER_CNTP_CVAL_ELX: hv_register_name = 360469;
pub const hv_register_name_HV_ARM64_REGISTER_CNTP_TVAL_EL0: hv_register_name = 360459;
pub const hv_register_name_HV_ARM64_REGISTER_CNTP_TVAL_ELX: hv_register_name = 360470;
pub const hv_register_name_HV_ARM64_REGISTER_CNTPCT_EL0: hv_register_name = 360460;
pub const hv_register_name_HV_ARM64_REGISTER_CNTPOFF_EL2: hv_register_name = 360461;
pub const hv_register_name_HV_ARM64_REGISTER_CNTV_CTL_EL0: hv_register_name = 360462;
pub const hv_register_name_HV_ARM64_REGISTER_CNTV_CTL_ELX: hv_register_name = 360471;
pub const hv_register_name_HV_ARM64_REGISTER_CNTV_CVAL_EL0: hv_register_name = 360463;
pub const hv_register_name_HV_ARM64_REGISTER_CNTV_CVAL_ELX: hv_register_name = 360472;
pub const hv_register_name_HV_ARM64_REGISTER_CNTV_TVAL_EL0: hv_register_name = 360464;
pub const hv_register_name_HV_ARM64_REGISTER_CNTV_TVAL_ELX: hv_register_name = 360473;
pub const hv_register_name_HV_ARM64_REGISTER_CNTVCT_EL0: hv_register_name = 360465;
pub const hv_register_name_HV_ARM64_REGISTER_CNTVOFF_EL2: hv_register_name = 360466;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_AP1R0_EL1: hv_register_name = 393216;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_AP1R1_EL1: hv_register_name = 393217;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_AP1R2_EL1: hv_register_name = 393218;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_AP1R3_EL1: hv_register_name = 393219;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_ASGI1R_EL1: hv_register_name = 393220;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_BPR1_EL1: hv_register_name = 393221;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_CTLR_EL1: hv_register_name = 393222;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_DIR_EL1: hv_register_name = 393223;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_EOIR1_EL1: hv_register_name = 393224;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_HPPIR1_EL1: hv_register_name = 393225;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_IAR1_EL1: hv_register_name = 393226;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_IGRPEN1_EL1: hv_register_name = 393227;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_PMR_EL1: hv_register_name = 393228;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_RPR_EL1: hv_register_name = 393229;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_SGI1R_EL1: hv_register_name = 393230;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_SRE_EL1: hv_register_name = 393231;
pub const hv_register_name_HV_ARM64_REGISTER_ICC_SRE_EL2: hv_register_name = 393232;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_AP1R0_EL2: hv_register_name = 397312;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_AP1R1_EL2: hv_register_name = 397313;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_AP1R2_EL2: hv_register_name = 397314;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_AP1R3_EL2: hv_register_name = 397315;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_EISR_EL2: hv_register_name = 397316;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_ELRSR_EL2: hv_register_name = 397317;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_HCR_EL2: hv_register_name = 397318;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR0_EL2: hv_register_name = 397319;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR1_EL2: hv_register_name = 397320;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR2_EL2: hv_register_name = 397321;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR3_EL2: hv_register_name = 397322;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR4_EL2: hv_register_name = 397323;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR5_EL2: hv_register_name = 397324;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR6_EL2: hv_register_name = 397325;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR7_EL2: hv_register_name = 397326;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR8_EL2: hv_register_name = 397327;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR9_EL2: hv_register_name = 397328;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR10_EL2: hv_register_name = 397329;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR11_EL2: hv_register_name = 397330;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR12_EL2: hv_register_name = 397331;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR13_EL2: hv_register_name = 397332;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR14_EL2: hv_register_name = 397333;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_LR15_EL2: hv_register_name = 397334;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_MISR_EL2: hv_register_name = 397335;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_VMCR_EL2: hv_register_name = 397336;
pub const hv_register_name_HV_ARM64_REGISTER_ICH_VTR_EL2: hv_register_name = 397337;
pub const hv_register_name_HV_ARM64_REGISTER_GICR_BASE_GPA: hv_register_name = 405504;
pub const hv_register_name_HV_ARM64_REGISTER_INTERFACE_VERSION: hv_register_name = 589830;
pub const hv_register_name_HV_ARM64_REGISTER_PARTITION_INFO_PAGE: hv_register_name = 589845;
pub const hv_register_name_HV_ARM64_REGISTER_SYNTHETIC_ESR_EL1: hv_register_name = 263169;
pub const hv_register_name_HV_ARM64_REGISTER_SYNTHETIC_VBAR_EL1: hv_register_name = 263168;
pub const hv_register_name_HV_ARM64_REGISTER_TLBI_CONTROL: hv_register_name = 589846;
pub const hv_register_name_HV_ARM64_REGISTER_GLOBAL_INTERRUPT_STATE_CHUNK_SIZE: hv_register_name =
    458752;
pub const hv_register_name_HV_ARM64_REGISTER_MPAM0_EL1: hv_register_name = 462848;
pub const hv_register_name_HV_ARM64_REGISTER_MPAM1_EL1: hv_register_name = 462849;
pub const hv_register_name_HV_ARM64_REGISTER_MPAM2_EL2: hv_register_name = 462850;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMHCR_EL2: hv_register_name = 462851;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMIDR_EL1: hv_register_name = 462852;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMSM_EL1: hv_register_name = 462853;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM0_EL2: hv_register_name = 462854;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM1_EL2: hv_register_name = 462855;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM2_EL2: hv_register_name = 462856;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM3_EL2: hv_register_name = 462857;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM4_EL2: hv_register_name = 462858;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM5_EL2: hv_register_name = 462859;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM6_EL2: hv_register_name = 462860;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPM7_EL2: hv_register_name = 462861;
pub const hv_register_name_HV_ARM64_REGISTER_MPAMVPMV_EL2: hv_register_name = 462862;
pub type hv_register_name = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_explicit_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_explicit_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_explicit_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_explicit_suspend_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_explicit_suspend_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_explicit_suspend_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_explicit_suspend_register__bindgen_ty_1>() - 1usize];
};
impl hv_explicit_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn suspended_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_suspended_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                63u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                63u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_explicit_suspend_register"]
        [::std::mem::size_of::<hv_explicit_suspend_register>() - 8usize];
    ["Alignment of hv_explicit_suspend_register"]
        [::std::mem::align_of::<hv_explicit_suspend_register>() - 8usize];
    ["Offset of field: hv_explicit_suspend_register::as_uint64"]
        [::std::mem::offset_of!(hv_explicit_suspend_register, as_uint64) - 0usize];
};
impl Default for hv_explicit_suspend_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_intercept_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_intercept_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_intercept_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_intercept_suspend_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_intercept_suspend_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_intercept_suspend_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_intercept_suspend_register__bindgen_ty_1>() - 1usize];
};
impl hv_intercept_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn suspended_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_suspended_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                63u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                63u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_intercept_suspend_register"]
        [::std::mem::size_of::<hv_intercept_suspend_register>() - 8usize];
    ["Alignment of hv_intercept_suspend_register"]
        [::std::mem::align_of::<hv_intercept_suspend_register>() - 8usize];
    ["Offset of field: hv_intercept_suspend_register::as_uint64"]
        [::std::mem::offset_of!(hv_intercept_suspend_register, as_uint64) - 0usize];
};
impl Default for hv_intercept_suspend_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_internal_activity_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_internal_activity_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_internal_activity_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_internal_activity_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_internal_activity_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_internal_activity_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_internal_activity_register__bindgen_ty_1>() - 1usize];
};
impl hv_internal_activity_register__bindgen_ty_1 {
    #[inline]
    pub fn startup_suspend(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_startup_suspend(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn startup_suspend_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_startup_suspend_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn halt_suspend(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_halt_suspend(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn halt_suspend_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_halt_suspend_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idle_suspend(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_idle_suspend(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idle_suspend_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_idle_suspend_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd_z(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd_z(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd_z_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                61u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd_z_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                61u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        startup_suspend: __u64,
        halt_suspend: __u64,
        idle_suspend: __u64,
        rsvd_z: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let startup_suspend: u64 = unsafe { ::std::mem::transmute(startup_suspend) };
            startup_suspend as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let halt_suspend: u64 = unsafe { ::std::mem::transmute(halt_suspend) };
            halt_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let idle_suspend: u64 = unsafe { ::std::mem::transmute(idle_suspend) };
            idle_suspend as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let rsvd_z: u64 = unsafe { ::std::mem::transmute(rsvd_z) };
            rsvd_z as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_internal_activity_register"]
        [::std::mem::size_of::<hv_internal_activity_register>() - 8usize];
    ["Alignment of hv_internal_activity_register"]
        [::std::mem::align_of::<hv_internal_activity_register>() - 8usize];
    ["Offset of field: hv_internal_activity_register::as_uint64"]
        [::std::mem::offset_of!(hv_internal_activity_register, as_uint64) - 0usize];
};
impl Default for hv_internal_activity_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_interrupt_state_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_interrupt_state_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_interrupt_state_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_interrupt_state_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_interrupt_state_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_x64_interrupt_state_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_interrupt_state_register__bindgen_ty_1>() - 1usize];
};
impl hv_x64_interrupt_state_register__bindgen_ty_1 {
    #[inline]
    pub fn interrupt_shadow(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_interrupt_shadow(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interrupt_shadow_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_interrupt_shadow_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nmi_masked(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nmi_masked(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nmi_masked_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nmi_masked_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                62u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                62u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt_shadow: __u64,
        nmi_masked: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt_shadow: u64 = unsafe { ::std::mem::transmute(interrupt_shadow) };
            interrupt_shadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nmi_masked: u64 = unsafe { ::std::mem::transmute(nmi_masked) };
            nmi_masked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_interrupt_state_register"]
        [::std::mem::size_of::<hv_x64_interrupt_state_register>() - 8usize];
    ["Alignment of hv_x64_interrupt_state_register"]
        [::std::mem::align_of::<hv_x64_interrupt_state_register>() - 8usize];
    ["Offset of field: hv_x64_interrupt_state_register::as_uint64"]
        [::std::mem::offset_of!(hv_x64_interrupt_state_register, as_uint64) - 0usize];
};
impl Default for hv_x64_interrupt_state_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_arm64_pending_synthetic_exception_event {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_arm64_pending_synthetic_exception_event__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_arm64_pending_synthetic_exception_event__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub exception_type: __u32,
    pub context: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_pending_synthetic_exception_event__bindgen_ty_1"][::std::mem::size_of::<
        hv_arm64_pending_synthetic_exception_event__bindgen_ty_1,
    >() - 13usize];
    ["Alignment of hv_arm64_pending_synthetic_exception_event__bindgen_ty_1"][::std::mem::align_of::<
        hv_arm64_pending_synthetic_exception_event__bindgen_ty_1,
    >() - 1usize];
    ["Offset of field: hv_arm64_pending_synthetic_exception_event__bindgen_ty_1::exception_type"][::std::mem::offset_of!(
        hv_arm64_pending_synthetic_exception_event__bindgen_ty_1,
        exception_type
    )
        - 1usize];
    ["Offset of field: hv_arm64_pending_synthetic_exception_event__bindgen_ty_1::context"][::std::mem::offset_of!(
        hv_arm64_pending_synthetic_exception_event__bindgen_ty_1,
        context
    )
        - 5usize];
};
impl hv_arm64_pending_synthetic_exception_event__bindgen_ty_1 {
    #[inline]
    pub fn event_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_event_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_pending_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_event_pending_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn event_type(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_type_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_event_type_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        event_pending: __u8,
        event_type: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let event_pending: u8 = unsafe { ::std::mem::transmute(event_pending) };
            event_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let event_type: u8 = unsafe { ::std::mem::transmute(event_type) };
            event_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_pending_synthetic_exception_event"]
        [::std::mem::size_of::<hv_arm64_pending_synthetic_exception_event>() - 16usize];
    ["Alignment of hv_arm64_pending_synthetic_exception_event"]
        [::std::mem::align_of::<hv_arm64_pending_synthetic_exception_event>() - 8usize];
    ["Offset of field: hv_arm64_pending_synthetic_exception_event::as_uint64"]
        [::std::mem::offset_of!(hv_arm64_pending_synthetic_exception_event, as_uint64) - 0usize];
};
impl Default for hv_arm64_pending_synthetic_exception_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_arm64_interrupt_state_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_arm64_interrupt_state_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_arm64_interrupt_state_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_interrupt_state_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_arm64_interrupt_state_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_arm64_interrupt_state_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_arm64_interrupt_state_register__bindgen_ty_1>() - 1usize];
};
impl hv_arm64_interrupt_state_register__bindgen_ty_1 {
    #[inline]
    pub fn interrupt_shadow(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_interrupt_shadow(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interrupt_shadow_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_interrupt_shadow_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                63u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                63u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt_shadow: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt_shadow: u64 = unsafe { ::std::mem::transmute(interrupt_shadow) };
            interrupt_shadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_interrupt_state_register"]
        [::std::mem::size_of::<hv_arm64_interrupt_state_register>() - 8usize];
    ["Alignment of hv_arm64_interrupt_state_register"]
        [::std::mem::align_of::<hv_arm64_interrupt_state_register>() - 8usize];
    ["Offset of field: hv_arm64_interrupt_state_register::as_uint64"]
        [::std::mem::offset_of!(hv_arm64_interrupt_state_register, as_uint64) - 0usize];
};
impl Default for hv_arm64_interrupt_state_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_arm64_pending_interruption_type_HV_ARM64_PENDING_INTERRUPT:
    hv_arm64_pending_interruption_type = 0;
pub const hv_arm64_pending_interruption_type_HV_ARM64_PENDING_EXCEPTION:
    hv_arm64_pending_interruption_type = 1;
pub type hv_arm64_pending_interruption_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_arm64_pending_interruption_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_arm64_pending_interruption_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_arm64_pending_interruption_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_pending_interruption_register__bindgen_ty_1"]
        [::std::mem::size_of::<hv_arm64_pending_interruption_register__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_arm64_pending_interruption_register__bindgen_ty_1"]
        [::std::mem::align_of::<hv_arm64_pending_interruption_register__bindgen_ty_1>() - 1usize];
};
impl hv_arm64_pending_interruption_register__bindgen_ty_1 {
    #[inline]
    pub fn interruption_pending(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_interruption_pending(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interruption_pending_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_interruption_pending_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn interruption_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_interruption_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interruption_type_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_interruption_type_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn error_code(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_error_code(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn error_code_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                32u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_error_code_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interruption_pending: __u64,
        interruption_type: __u64,
        reserved: __u64,
        error_code: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interruption_pending: u64 = unsafe { ::std::mem::transmute(interruption_pending) };
            interruption_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let interruption_type: u64 = unsafe { ::std::mem::transmute(interruption_type) };
            interruption_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let error_code: u64 = unsafe { ::std::mem::transmute(error_code) };
            error_code as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_pending_interruption_register"]
        [::std::mem::size_of::<hv_arm64_pending_interruption_register>() - 8usize];
    ["Alignment of hv_arm64_pending_interruption_register"]
        [::std::mem::align_of::<hv_arm64_pending_interruption_register>() - 8usize];
    ["Offset of field: hv_arm64_pending_interruption_register::as_uint64"]
        [::std::mem::offset_of!(hv_arm64_pending_interruption_register, as_uint64) - 0usize];
};
impl Default for hv_arm64_pending_interruption_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_register_value {
    pub reg128: hv_u128,
    pub reg64: __u64,
    pub reg32: __u32,
    pub reg16: __u16,
    pub reg8: __u8,
    pub explicit_suspend: hv_explicit_suspend_register,
    pub intercept_suspend: hv_intercept_suspend_register,
    pub internal_activity: hv_internal_activity_register,
    pub pending_interruption: hv_arm64_pending_interruption_register,
    pub interrupt_state: hv_arm64_interrupt_state_register,
    pub pending_synthetic_exception_event: hv_arm64_pending_synthetic_exception_event,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_register_value"][::std::mem::size_of::<hv_register_value>() - 16usize];
    ["Alignment of hv_register_value"][::std::mem::align_of::<hv_register_value>() - 8usize];
    ["Offset of field: hv_register_value::reg128"]
        [::std::mem::offset_of!(hv_register_value, reg128) - 0usize];
    ["Offset of field: hv_register_value::reg64"]
        [::std::mem::offset_of!(hv_register_value, reg64) - 0usize];
    ["Offset of field: hv_register_value::reg32"]
        [::std::mem::offset_of!(hv_register_value, reg32) - 0usize];
    ["Offset of field: hv_register_value::reg16"]
        [::std::mem::offset_of!(hv_register_value, reg16) - 0usize];
    ["Offset of field: hv_register_value::reg8"]
        [::std::mem::offset_of!(hv_register_value, reg8) - 0usize];
    ["Offset of field: hv_register_value::explicit_suspend"]
        [::std::mem::offset_of!(hv_register_value, explicit_suspend) - 0usize];
    ["Offset of field: hv_register_value::intercept_suspend"]
        [::std::mem::offset_of!(hv_register_value, intercept_suspend) - 0usize];
    ["Offset of field: hv_register_value::internal_activity"]
        [::std::mem::offset_of!(hv_register_value, internal_activity) - 0usize];
    ["Offset of field: hv_register_value::pending_interruption"]
        [::std::mem::offset_of!(hv_register_value, pending_interruption) - 0usize];
    ["Offset of field: hv_register_value::interrupt_state"]
        [::std::mem::offset_of!(hv_register_value, interrupt_state) - 0usize];
    ["Offset of field: hv_register_value::pending_synthetic_exception_event"]
        [::std::mem::offset_of!(hv_register_value, pending_synthetic_exception_event) - 0usize];
};
impl Default for hv_register_value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_register_assoc {
    pub name: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
    pub value: hv_register_value,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_register_assoc"][::std::mem::size_of::<hv_register_assoc>() - 32usize];
    ["Alignment of hv_register_assoc"][::std::mem::align_of::<hv_register_assoc>() - 1usize];
    ["Offset of field: hv_register_assoc::name"]
        [::std::mem::offset_of!(hv_register_assoc, name) - 0usize];
    ["Offset of field: hv_register_assoc::reserved1"]
        [::std::mem::offset_of!(hv_register_assoc, reserved1) - 4usize];
    ["Offset of field: hv_register_assoc::reserved2"]
        [::std::mem::offset_of!(hv_register_assoc, reserved2) - 8usize];
    ["Offset of field: hv_register_assoc::value"]
        [::std::mem::offset_of!(hv_register_assoc, value) - 16usize];
};
impl Default for hv_register_assoc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_get_vp_registers {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub input_vtl: hv_input_vtl,
    pub rsvd_z8: __u8,
    pub rsvd_z16: __u16,
    pub names: __IncompleteArrayField<__u32>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_get_vp_registers"]
        [::std::mem::size_of::<hv_input_get_vp_registers>() - 16usize];
    ["Alignment of hv_input_get_vp_registers"]
        [::std::mem::align_of::<hv_input_get_vp_registers>() - 1usize];
    ["Offset of field: hv_input_get_vp_registers::partition_id"]
        [::std::mem::offset_of!(hv_input_get_vp_registers, partition_id) - 0usize];
    ["Offset of field: hv_input_get_vp_registers::vp_index"]
        [::std::mem::offset_of!(hv_input_get_vp_registers, vp_index) - 8usize];
    ["Offset of field: hv_input_get_vp_registers::input_vtl"]
        [::std::mem::offset_of!(hv_input_get_vp_registers, input_vtl) - 12usize];
    ["Offset of field: hv_input_get_vp_registers::rsvd_z8"]
        [::std::mem::offset_of!(hv_input_get_vp_registers, rsvd_z8) - 13usize];
    ["Offset of field: hv_input_get_vp_registers::rsvd_z16"]
        [::std::mem::offset_of!(hv_input_get_vp_registers, rsvd_z16) - 14usize];
    ["Offset of field: hv_input_get_vp_registers::names"]
        [::std::mem::offset_of!(hv_input_get_vp_registers, names) - 16usize];
};
impl Default for hv_input_get_vp_registers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_set_vp_registers {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub input_vtl: hv_input_vtl,
    pub rsvd_z8: __u8,
    pub rsvd_z16: __u16,
    pub elements: __IncompleteArrayField<hv_register_assoc>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_set_vp_registers"]
        [::std::mem::size_of::<hv_input_set_vp_registers>() - 16usize];
    ["Alignment of hv_input_set_vp_registers"]
        [::std::mem::align_of::<hv_input_set_vp_registers>() - 1usize];
    ["Offset of field: hv_input_set_vp_registers::partition_id"]
        [::std::mem::offset_of!(hv_input_set_vp_registers, partition_id) - 0usize];
    ["Offset of field: hv_input_set_vp_registers::vp_index"]
        [::std::mem::offset_of!(hv_input_set_vp_registers, vp_index) - 8usize];
    ["Offset of field: hv_input_set_vp_registers::input_vtl"]
        [::std::mem::offset_of!(hv_input_set_vp_registers, input_vtl) - 12usize];
    ["Offset of field: hv_input_set_vp_registers::rsvd_z8"]
        [::std::mem::offset_of!(hv_input_set_vp_registers, rsvd_z8) - 13usize];
    ["Offset of field: hv_input_set_vp_registers::rsvd_z16"]
        [::std::mem::offset_of!(hv_input_set_vp_registers, rsvd_z16) - 14usize];
    ["Offset of field: hv_input_set_vp_registers::elements"]
        [::std::mem::offset_of!(hv_input_set_vp_registers, elements) - 16usize];
};
impl Default for hv_input_set_vp_registers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_intercept_type_HV_INTERCEPT_TYPE_EXCEPTION: hv_intercept_type = 3;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_RESERVED0: hv_intercept_type = 4;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_MMIO: hv_intercept_type = 5;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_HYPERCALL: hv_intercept_type = 8;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_MAX: hv_intercept_type = 9;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_INVALID: hv_intercept_type = 4294967295;
pub type hv_intercept_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_intercept_parameters {
    pub as_uint64: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_intercept_parameters"][::std::mem::size_of::<hv_intercept_parameters>() - 8usize];
    ["Alignment of hv_intercept_parameters"]
        [::std::mem::align_of::<hv_intercept_parameters>() - 8usize];
    ["Offset of field: hv_intercept_parameters::as_uint64"]
        [::std::mem::offset_of!(hv_intercept_parameters, as_uint64) - 0usize];
};
impl Default for hv_intercept_parameters {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_install_intercept {
    pub partition_id: __u64,
    pub access_type: __u32,
    pub intercept_type: __u32,
    pub intercept_parameter: hv_intercept_parameters,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_install_intercept"]
        [::std::mem::size_of::<hv_input_install_intercept>() - 24usize];
    ["Alignment of hv_input_install_intercept"]
        [::std::mem::align_of::<hv_input_install_intercept>() - 1usize];
    ["Offset of field: hv_input_install_intercept::partition_id"]
        [::std::mem::offset_of!(hv_input_install_intercept, partition_id) - 0usize];
    ["Offset of field: hv_input_install_intercept::access_type"]
        [::std::mem::offset_of!(hv_input_install_intercept, access_type) - 8usize];
    ["Offset of field: hv_input_install_intercept::intercept_type"]
        [::std::mem::offset_of!(hv_input_install_intercept, intercept_type) - 12usize];
    ["Offset of field: hv_input_install_intercept::intercept_parameter"]
        [::std::mem::offset_of!(hv_input_install_intercept, intercept_parameter) - 16usize];
};
impl Default for hv_input_install_intercept {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_sev_ghcb {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_register_sev_ghcb__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_register_sev_ghcb__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_register_sev_ghcb__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_register_sev_ghcb__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_x64_register_sev_ghcb__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_register_sev_ghcb__bindgen_ty_1>() - 1usize];
};
impl hv_x64_register_sev_ghcb__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedz(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reservedz(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedz_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                11u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reservedz_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn page_number_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                52u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_page_number_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                52u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: __u64,
        reservedz: __u64,
        page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reservedz: u64 = unsafe { ::std::mem::transmute(reservedz) };
            reservedz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let page_number: u64 = unsafe { ::std::mem::transmute(page_number) };
            page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_register_sev_ghcb"]
        [::std::mem::size_of::<hv_x64_register_sev_ghcb>() - 8usize];
    ["Alignment of hv_x64_register_sev_ghcb"]
        [::std::mem::align_of::<hv_x64_register_sev_ghcb>() - 8usize];
    ["Offset of field: hv_x64_register_sev_ghcb::as_uint64"]
        [::std::mem::offset_of!(hv_x64_register_sev_ghcb, as_uint64) - 0usize];
};
impl Default for hv_x64_register_sev_ghcb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_sev_hv_doorbell {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_register_sev_hv_doorbell__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_register_sev_hv_doorbell__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_register_sev_hv_doorbell__bindgen_ty_1"]
        [::std::mem::size_of::<hv_x64_register_sev_hv_doorbell__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_x64_register_sev_hv_doorbell__bindgen_ty_1"]
        [::std::mem::align_of::<hv_x64_register_sev_hv_doorbell__bindgen_ty_1>() - 1usize];
};
impl hv_x64_register_sev_hv_doorbell__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enabled_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_enabled_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedz(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reservedz(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedz_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                11u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reservedz_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn page_number_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                52u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_page_number_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                52u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: __u64,
        reservedz: __u64,
        page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reservedz: u64 = unsafe { ::std::mem::transmute(reservedz) };
            reservedz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let page_number: u64 = unsafe { ::std::mem::transmute(page_number) };
            page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_register_sev_hv_doorbell"]
        [::std::mem::size_of::<hv_x64_register_sev_hv_doorbell>() - 8usize];
    ["Alignment of hv_x64_register_sev_hv_doorbell"]
        [::std::mem::align_of::<hv_x64_register_sev_hv_doorbell>() - 8usize];
    ["Offset of field: hv_x64_register_sev_hv_doorbell::as_uint64"]
        [::std::mem::offset_of!(hv_x64_register_sev_hv_doorbell, as_uint64) - 0usize];
};
impl Default for hv_x64_register_sev_hv_doorbell {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_generic_set_format_HV_GENERIC_SET_SPARSE_4K: hv_generic_set_format = 0;
pub const hv_generic_set_format_HV_GENERIC_SET_ALL: hv_generic_set_format = 1;
pub type hv_generic_set_format = ::std::os::raw::c_uint;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PRIVILEGE_FLAGS:
    hv_partition_property_code = 65536;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SYNTHETIC_PROC_FEATURES:
    hv_partition_property_code = 65537;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SUSPEND: hv_partition_property_code =
    131072;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_RESERVE: hv_partition_property_code =
    131073;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_CAP: hv_partition_property_code =
    131074;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_WEIGHT: hv_partition_property_code =
    131075;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_GROUP_ID:
    hv_partition_property_code = 131076;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_TIME_FREEZE: hv_partition_property_code =
    196611;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_REFERENCE_TIME:
    hv_partition_property_code = 196613;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEBUG_CHANNEL_ID:
    hv_partition_property_code = 262144;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VIRTUAL_TLB_PAGE_COUNT:
    hv_partition_property_code = 327680;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VSM_CONFIG: hv_partition_property_code =
    327681;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ZERO_MEMORY_ON_RESET:
    hv_partition_property_code = 327682;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSORS_PER_SOCKET:
    hv_partition_property_code = 327683;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_NESTED_TLB_SIZE:
    hv_partition_property_code = 327684;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GPA_PAGE_ACCESS_TRACKING:
    hv_partition_property_code = 327685;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VSM_PERMISSIONS_DIRTY_SINCE_LAST_QUERY : hv_partition_property_code = 327686 ;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SGX_LAUNCH_CONTROL_CONFIG:
    hv_partition_property_code = 327687;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL0:
    hv_partition_property_code = 327688;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL1:
    hv_partition_property_code = 327689;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL2:
    hv_partition_property_code = 327690;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL3:
    hv_partition_property_code = 327691;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_STATE:
    hv_partition_property_code = 327692;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_CONTROL:
    hv_partition_property_code = 327693;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ALLOCATION_ID:
    hv_partition_property_code = 327694;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_MONITORING_ID:
    hv_partition_property_code = 327695;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_IMPLEMENTED_PHYSICAL_ADDRESS_BITS:
    hv_partition_property_code = 327696;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_NON_ARCHITECTURAL_CORE_SHARING:
    hv_partition_property_code = 327697;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_HYPERCALL_DOORBELL_PAGE:
    hv_partition_property_code = 327698;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_POLICY:
    hv_partition_property_code = 327700;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_UNIMPLEMENTED_MSR_ACTION:
    hv_partition_property_code = 327703;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SEV_VMGEXIT_OFFLOADS:
    hv_partition_property_code = 327714;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PARTITION_DIAG_BUFFER_CONFIG:
    hv_partition_property_code = 327718;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GICD_BASE_ADDRESS:
    hv_partition_property_code = 327720;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GITS_TRANSLATER_BASE_ADDRESS:
    hv_partition_property_code = 327721;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GIC_LPI_INT_ID_BITS:
    hv_partition_property_code = 327722;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GIC_PPI_OVERFLOW_INTERRUPT_FROM_CNTV:
    hv_partition_property_code = 327723;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GIC_PPI_OVERFLOW_INTERRUPT_FROM_CNTP:
    hv_partition_property_code = 327724;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GIC_PPI_PERFORMANCE_MONITORS_INTERRUPT : hv_partition_property_code = 327725 ;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GIC_PPI_PMBIRQ:
    hv_partition_property_code = 327726;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_VENDOR:
    hv_partition_property_code = 393216;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES_DEPRECATED:
    hv_partition_property_code = 393217;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_XSAVE_FEATURES:
    hv_partition_property_code = 393218;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_CL_FLUSH_SIZE:
    hv_partition_property_code = 393219;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ENLIGHTENMENT_MODIFICATIONS:
    hv_partition_property_code = 393220;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_COMPATIBILITY_VERSION:
    hv_partition_property_code = 393221;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PHYSICAL_ADDRESS_WIDTH:
    hv_partition_property_code = 393222;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_XSAVE_STATES:
    hv_partition_property_code = 393223;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_MAX_XSAVE_DATA_SIZE:
    hv_partition_property_code = 393224;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_CLOCK_FREQUENCY:
    hv_partition_property_code = 393225;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES0:
    hv_partition_property_code = 393226;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES1:
    hv_partition_property_code = 393227;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GUEST_OS_ID: hv_partition_property_code =
    458752;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_VIRTUALIZATION_FEATURES:
    hv_partition_property_code = 524288;
pub type hv_partition_property_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_pfn_range {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_pfn_range__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_pfn_range__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_pfn_range__bindgen_ty_1"]
        [::std::mem::size_of::<hv_pfn_range__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_pfn_range__bindgen_ty_1"]
        [::std::mem::align_of::<hv_pfn_range__bindgen_ty_1>() - 1usize];
};
impl hv_pfn_range__bindgen_ty_1 {
    #[inline]
    pub fn base_pfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_base_pfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn base_pfn_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                40u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_base_pfn_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                40u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn add_pfns(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_add_pfns(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn add_pfns_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                24u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_add_pfns_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(base_pfn: __u64, add_pfns: __u64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 40u8, {
            let base_pfn: u64 = unsafe { ::std::mem::transmute(base_pfn) };
            base_pfn as u64
        });
        __bindgen_bitfield_unit.set(40usize, 24u8, {
            let add_pfns: u64 = unsafe { ::std::mem::transmute(add_pfns) };
            add_pfns as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_pfn_range"][::std::mem::size_of::<hv_pfn_range>() - 8usize];
    ["Alignment of hv_pfn_range"][::std::mem::align_of::<hv_pfn_range>() - 8usize];
    ["Offset of field: hv_pfn_range::as_uint64"]
        [::std::mem::offset_of!(hv_pfn_range, as_uint64) - 0usize];
};
impl Default for hv_pfn_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_snp_guest_policy {
    pub __bindgen_anon_1: hv_snp_guest_policy__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_snp_guest_policy__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_snp_guest_policy__bindgen_ty_1"]
        [::std::mem::size_of::<hv_snp_guest_policy__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_snp_guest_policy__bindgen_ty_1"]
        [::std::mem::align_of::<hv_snp_guest_policy__bindgen_ty_1>() - 1usize];
};
impl hv_snp_guest_policy__bindgen_ty_1 {
    #[inline]
    pub fn minor_version(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_minor_version(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn minor_version_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_minor_version_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn major_version(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_major_version(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn major_version_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_major_version_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smt_allowed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smt_allowed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smt_allowed_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_smt_allowed_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vmpls_required(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vmpls_required(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vmpls_required_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_vmpls_required_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn migration_agent_allowed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_migration_agent_allowed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn migration_agent_allowed_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_migration_agent_allowed_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn debug_allowed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_debug_allowed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn debug_allowed_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_debug_allowed_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 44u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 44u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                44u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                44u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minor_version: __u64,
        major_version: __u64,
        smt_allowed: __u64,
        vmpls_required: __u64,
        migration_agent_allowed: __u64,
        debug_allowed: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let minor_version: u64 = unsafe { ::std::mem::transmute(minor_version) };
            minor_version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let major_version: u64 = unsafe { ::std::mem::transmute(major_version) };
            major_version as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let smt_allowed: u64 = unsafe { ::std::mem::transmute(smt_allowed) };
            smt_allowed as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let vmpls_required: u64 = unsafe { ::std::mem::transmute(vmpls_required) };
            vmpls_required as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let migration_agent_allowed: u64 =
                unsafe { ::std::mem::transmute(migration_agent_allowed) };
            migration_agent_allowed as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let debug_allowed: u64 = unsafe { ::std::mem::transmute(debug_allowed) };
            debug_allowed as u64
        });
        __bindgen_bitfield_unit.set(20usize, 44u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_snp_guest_policy"][::std::mem::size_of::<hv_snp_guest_policy>() - 8usize];
    ["Alignment of hv_snp_guest_policy"][::std::mem::align_of::<hv_snp_guest_policy>() - 8usize];
    ["Offset of field: hv_snp_guest_policy::as_uint64"]
        [::std::mem::offset_of!(hv_snp_guest_policy, as_uint64) - 0usize];
};
impl Default for hv_snp_guest_policy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_snp_id_block {
    pub launch_digest: [__u8; 48usize],
    pub family_id: [__u8; 16usize],
    pub image_id: [__u8; 16usize],
    pub version: __u32,
    pub guest_svn: __u32,
    pub policy: hv_snp_guest_policy,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_snp_id_block"][::std::mem::size_of::<hv_snp_id_block>() - 96usize];
    ["Alignment of hv_snp_id_block"][::std::mem::align_of::<hv_snp_id_block>() - 1usize];
    ["Offset of field: hv_snp_id_block::launch_digest"]
        [::std::mem::offset_of!(hv_snp_id_block, launch_digest) - 0usize];
    ["Offset of field: hv_snp_id_block::family_id"]
        [::std::mem::offset_of!(hv_snp_id_block, family_id) - 48usize];
    ["Offset of field: hv_snp_id_block::image_id"]
        [::std::mem::offset_of!(hv_snp_id_block, image_id) - 64usize];
    ["Offset of field: hv_snp_id_block::version"]
        [::std::mem::offset_of!(hv_snp_id_block, version) - 80usize];
    ["Offset of field: hv_snp_id_block::guest_svn"]
        [::std::mem::offset_of!(hv_snp_id_block, guest_svn) - 84usize];
    ["Offset of field: hv_snp_id_block::policy"]
        [::std::mem::offset_of!(hv_snp_id_block, policy) - 88usize];
};
impl Default for hv_snp_id_block {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_snp_id_auth_info {
    pub id_key_algorithm: __u32,
    pub auth_key_algorithm: __u32,
    pub reserved0: [__u8; 56usize],
    pub id_block_signature: [__u8; 512usize],
    pub id_key: [__u8; 1028usize],
    pub reserved1: [__u8; 60usize],
    pub id_key_signature: [__u8; 512usize],
    pub author_key: [__u8; 1028usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_snp_id_auth_info"][::std::mem::size_of::<hv_snp_id_auth_info>() - 3204usize];
    ["Alignment of hv_snp_id_auth_info"][::std::mem::align_of::<hv_snp_id_auth_info>() - 1usize];
    ["Offset of field: hv_snp_id_auth_info::id_key_algorithm"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, id_key_algorithm) - 0usize];
    ["Offset of field: hv_snp_id_auth_info::auth_key_algorithm"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, auth_key_algorithm) - 4usize];
    ["Offset of field: hv_snp_id_auth_info::reserved0"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, reserved0) - 8usize];
    ["Offset of field: hv_snp_id_auth_info::id_block_signature"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, id_block_signature) - 64usize];
    ["Offset of field: hv_snp_id_auth_info::id_key"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, id_key) - 576usize];
    ["Offset of field: hv_snp_id_auth_info::reserved1"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, reserved1) - 1604usize];
    ["Offset of field: hv_snp_id_auth_info::id_key_signature"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, id_key_signature) - 1664usize];
    ["Offset of field: hv_snp_id_auth_info::author_key"]
        [::std::mem::offset_of!(hv_snp_id_auth_info, author_key) - 2176usize];
};
impl Default for hv_snp_id_auth_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_psp_launch_finish_data {
    pub id_block: hv_snp_id_block,
    pub id_auth_info: hv_snp_id_auth_info,
    pub host_data: [__u8; 32usize],
    pub id_block_enabled: __u8,
    pub author_key_enabled: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_psp_launch_finish_data"]
        [::std::mem::size_of::<hv_psp_launch_finish_data>() - 3334usize];
    ["Alignment of hv_psp_launch_finish_data"]
        [::std::mem::align_of::<hv_psp_launch_finish_data>() - 1usize];
    ["Offset of field: hv_psp_launch_finish_data::id_block"]
        [::std::mem::offset_of!(hv_psp_launch_finish_data, id_block) - 0usize];
    ["Offset of field: hv_psp_launch_finish_data::id_auth_info"]
        [::std::mem::offset_of!(hv_psp_launch_finish_data, id_auth_info) - 96usize];
    ["Offset of field: hv_psp_launch_finish_data::host_data"]
        [::std::mem::offset_of!(hv_psp_launch_finish_data, host_data) - 3300usize];
    ["Offset of field: hv_psp_launch_finish_data::id_block_enabled"]
        [::std::mem::offset_of!(hv_psp_launch_finish_data, id_block_enabled) - 3332usize];
    ["Offset of field: hv_psp_launch_finish_data::author_key_enabled"]
        [::std::mem::offset_of!(hv_psp_launch_finish_data, author_key_enabled) - 3333usize];
};
impl Default for hv_psp_launch_finish_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_partition_complete_isolated_import_data {
    pub reserved: __u64,
    pub psp_parameters: hv_psp_launch_finish_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_complete_isolated_import_data"]
        [::std::mem::size_of::<hv_partition_complete_isolated_import_data>() - 3334usize];
    ["Alignment of hv_partition_complete_isolated_import_data"]
        [::std::mem::align_of::<hv_partition_complete_isolated_import_data>() - 1usize];
    ["Offset of field: hv_partition_complete_isolated_import_data::reserved"]
        [::std::mem::offset_of!(hv_partition_complete_isolated_import_data, reserved) - 0usize];
    ["Offset of field: hv_partition_complete_isolated_import_data::psp_parameters"][::std::mem::offset_of!(
        hv_partition_complete_isolated_import_data,
        psp_parameters
    ) - 0usize];
};
impl Default for hv_partition_complete_isolated_import_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_complete_isolated_import {
    pub partition_id: __u64,
    pub import_data: hv_partition_complete_isolated_import_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_complete_isolated_import"]
        [::std::mem::size_of::<hv_input_complete_isolated_import>() - 3342usize];
    ["Alignment of hv_input_complete_isolated_import"]
        [::std::mem::align_of::<hv_input_complete_isolated_import>() - 1usize];
    ["Offset of field: hv_input_complete_isolated_import::partition_id"]
        [::std::mem::offset_of!(hv_input_complete_isolated_import, partition_id) - 0usize];
    ["Offset of field: hv_input_complete_isolated_import::import_data"]
        [::std::mem::offset_of!(hv_input_complete_isolated_import, import_data) - 8usize];
};
impl Default for hv_input_complete_isolated_import {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page_interrupt_vectors {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_vp_register_page_interrupt_vectors__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_register_page_interrupt_vectors__bindgen_ty_1 {
    pub vector_count: __u8,
    pub vector: [__u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_vp_register_page_interrupt_vectors__bindgen_ty_1"]
        [::std::mem::size_of::<hv_vp_register_page_interrupt_vectors__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_vp_register_page_interrupt_vectors__bindgen_ty_1"]
        [::std::mem::align_of::<hv_vp_register_page_interrupt_vectors__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_vp_register_page_interrupt_vectors__bindgen_ty_1::vector_count"][::std::mem::offset_of!(
        hv_vp_register_page_interrupt_vectors__bindgen_ty_1,
        vector_count
    )
        - 0usize];
    ["Offset of field: hv_vp_register_page_interrupt_vectors__bindgen_ty_1::vector"][::std::mem::offset_of!(
        hv_vp_register_page_interrupt_vectors__bindgen_ty_1,
        vector
    ) - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_vp_register_page_interrupt_vectors"]
        [::std::mem::size_of::<hv_vp_register_page_interrupt_vectors>() - 8usize];
    ["Alignment of hv_vp_register_page_interrupt_vectors"]
        [::std::mem::align_of::<hv_vp_register_page_interrupt_vectors>() - 1usize];
    ["Offset of field: hv_vp_register_page_interrupt_vectors::as_uint64"]
        [::std::mem::offset_of!(hv_vp_register_page_interrupt_vectors, as_uint64) - 0usize];
};
impl Default for hv_vp_register_page_interrupt_vectors {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_register_page {
    pub version: __u16,
    pub isvalid: __u8,
    pub rsvdz: __u8,
    pub dirty: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_vp_register_page"][::std::mem::size_of::<hv_vp_register_page>() - 8usize];
    ["Alignment of hv_vp_register_page"][::std::mem::align_of::<hv_vp_register_page>() - 1usize];
    ["Offset of field: hv_vp_register_page::version"]
        [::std::mem::offset_of!(hv_vp_register_page, version) - 0usize];
    ["Offset of field: hv_vp_register_page::isvalid"]
        [::std::mem::offset_of!(hv_vp_register_page, isvalid) - 2usize];
    ["Offset of field: hv_vp_register_page::rsvdz"]
        [::std::mem::offset_of!(hv_vp_register_page, rsvdz) - 3usize];
    ["Offset of field: hv_vp_register_page::dirty"]
        [::std::mem::offset_of!(hv_vp_register_page, dirty) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_synthetic_processor_features {
    pub as_uint64: [__u64; 1usize],
    pub __bindgen_anon_1: hv_partition_synthetic_processor_features__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_synthetic_processor_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_synthetic_processor_features__bindgen_ty_1"]
        [::std::mem::size_of::<hv_partition_synthetic_processor_features__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_partition_synthetic_processor_features__bindgen_ty_1"][::std::mem::align_of::<
        hv_partition_synthetic_processor_features__bindgen_ty_1,
    >() - 1usize];
};
impl hv_partition_synthetic_processor_features__bindgen_ty_1 {
    #[inline]
    pub fn hypervisor_present(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hypervisor_present(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hypervisor_present_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_hypervisor_present_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hv1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hv1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hv1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_hv1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_vp_run_time_reg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_vp_run_time_reg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_vp_run_time_reg_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_vp_run_time_reg_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_partition_reference_counter(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_partition_reference_counter(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_partition_reference_counter_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_partition_reference_counter_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_synic_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_synic_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_synic_regs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_synic_regs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_synthetic_timer_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_synthetic_timer_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_synthetic_timer_regs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_synthetic_timer_regs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_intr_ctrl_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_intr_ctrl_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_intr_ctrl_regs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_intr_ctrl_regs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_hypercall_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_hypercall_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_hypercall_regs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_hypercall_regs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_vp_index(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_vp_index(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_vp_index_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_vp_index_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_partition_reference_tsc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_partition_reference_tsc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_partition_reference_tsc_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_partition_reference_tsc_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z10(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z10(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z10_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z10_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_frequency_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_frequency_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_frequency_regs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_access_frequency_regs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z12(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z12(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z12_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z12_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z13(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z13(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z13_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z13_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z14(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z14(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z14_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z14_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z15(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z15(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z15_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z15_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z17(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z17(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z17_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z17_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fast_hypercall_output(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fast_hypercall_output(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fast_hypercall_output_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fast_hypercall_output_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z19(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z19(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z19_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z19_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn start_virtual_processor(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_start_virtual_processor(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn start_virtual_processor_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_start_virtual_processor_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z21(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z21(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z21_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z21_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direct_synthetic_timers(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_direct_synthetic_timers(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direct_synthetic_timers_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_direct_synthetic_timers_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z23(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z23(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z23_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z23_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extended_processor_masks(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_extended_processor_masks(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_processor_masks_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_extended_processor_masks_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tb_flush_hypercalls(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tb_flush_hypercalls(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tb_flush_hypercalls_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tb_flush_hypercalls_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn synthetic_cluster_ipi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_synthetic_cluster_ipi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn synthetic_cluster_ipi_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_synthetic_cluster_ipi_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn notify_long_spin_wait(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_notify_long_spin_wait(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn notify_long_spin_wait_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_notify_long_spin_wait_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn query_numa_distance(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_query_numa_distance(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn query_numa_distance_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_query_numa_distance_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn signal_events(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_signal_events(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn signal_events_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_signal_events_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn retarget_device_interrupt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_retarget_device_interrupt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn retarget_device_interrupt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_retarget_device_interrupt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z31(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z31(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z31_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z31_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_z32(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z32(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_z32_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_z32_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                30u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hypervisor_present: __u64,
        hv1: __u64,
        access_vp_run_time_reg: __u64,
        access_partition_reference_counter: __u64,
        access_synic_regs: __u64,
        access_synthetic_timer_regs: __u64,
        access_intr_ctrl_regs: __u64,
        access_hypercall_regs: __u64,
        access_vp_index: __u64,
        access_partition_reference_tsc: __u64,
        reserved_z10: __u64,
        access_frequency_regs: __u64,
        reserved_z12: __u64,
        reserved_z13: __u64,
        reserved_z14: __u64,
        reserved_z15: __u64,
        reserved_z16: __u64,
        reserved_z17: __u64,
        fast_hypercall_output: __u64,
        reserved_z19: __u64,
        start_virtual_processor: __u64,
        reserved_z21: __u64,
        direct_synthetic_timers: __u64,
        reserved_z23: __u64,
        extended_processor_masks: __u64,
        tb_flush_hypercalls: __u64,
        synthetic_cluster_ipi: __u64,
        notify_long_spin_wait: __u64,
        query_numa_distance: __u64,
        signal_events: __u64,
        retarget_device_interrupt: __u64,
        reserved_z31: __u64,
        reserved_z32: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hypervisor_present: u64 = unsafe { ::std::mem::transmute(hypervisor_present) };
            hypervisor_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hv1: u64 = unsafe { ::std::mem::transmute(hv1) };
            hv1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let access_vp_run_time_reg: u64 =
                unsafe { ::std::mem::transmute(access_vp_run_time_reg) };
            access_vp_run_time_reg as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let access_partition_reference_counter: u64 =
                unsafe { ::std::mem::transmute(access_partition_reference_counter) };
            access_partition_reference_counter as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let access_synic_regs: u64 = unsafe { ::std::mem::transmute(access_synic_regs) };
            access_synic_regs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let access_synthetic_timer_regs: u64 =
                unsafe { ::std::mem::transmute(access_synthetic_timer_regs) };
            access_synthetic_timer_regs as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let access_intr_ctrl_regs: u64 =
                unsafe { ::std::mem::transmute(access_intr_ctrl_regs) };
            access_intr_ctrl_regs as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let access_hypercall_regs: u64 =
                unsafe { ::std::mem::transmute(access_hypercall_regs) };
            access_hypercall_regs as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let access_vp_index: u64 = unsafe { ::std::mem::transmute(access_vp_index) };
            access_vp_index as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let access_partition_reference_tsc: u64 =
                unsafe { ::std::mem::transmute(access_partition_reference_tsc) };
            access_partition_reference_tsc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reserved_z10: u64 = unsafe { ::std::mem::transmute(reserved_z10) };
            reserved_z10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let access_frequency_regs: u64 =
                unsafe { ::std::mem::transmute(access_frequency_regs) };
            access_frequency_regs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved_z12: u64 = unsafe { ::std::mem::transmute(reserved_z12) };
            reserved_z12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved_z13: u64 = unsafe { ::std::mem::transmute(reserved_z13) };
            reserved_z13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved_z14: u64 = unsafe { ::std::mem::transmute(reserved_z14) };
            reserved_z14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved_z15: u64 = unsafe { ::std::mem::transmute(reserved_z15) };
            reserved_z15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved_z16: u64 = unsafe { ::std::mem::transmute(reserved_z16) };
            reserved_z16 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let reserved_z17: u64 = unsafe { ::std::mem::transmute(reserved_z17) };
            reserved_z17 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let fast_hypercall_output: u64 =
                unsafe { ::std::mem::transmute(fast_hypercall_output) };
            fast_hypercall_output as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let reserved_z19: u64 = unsafe { ::std::mem::transmute(reserved_z19) };
            reserved_z19 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let start_virtual_processor: u64 =
                unsafe { ::std::mem::transmute(start_virtual_processor) };
            start_virtual_processor as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved_z21: u64 = unsafe { ::std::mem::transmute(reserved_z21) };
            reserved_z21 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let direct_synthetic_timers: u64 =
                unsafe { ::std::mem::transmute(direct_synthetic_timers) };
            direct_synthetic_timers as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved_z23: u64 = unsafe { ::std::mem::transmute(reserved_z23) };
            reserved_z23 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let extended_processor_masks: u64 =
                unsafe { ::std::mem::transmute(extended_processor_masks) };
            extended_processor_masks as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let tb_flush_hypercalls: u64 = unsafe { ::std::mem::transmute(tb_flush_hypercalls) };
            tb_flush_hypercalls as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let synthetic_cluster_ipi: u64 =
                unsafe { ::std::mem::transmute(synthetic_cluster_ipi) };
            synthetic_cluster_ipi as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let notify_long_spin_wait: u64 =
                unsafe { ::std::mem::transmute(notify_long_spin_wait) };
            notify_long_spin_wait as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let query_numa_distance: u64 = unsafe { ::std::mem::transmute(query_numa_distance) };
            query_numa_distance as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let signal_events: u64 = unsafe { ::std::mem::transmute(signal_events) };
            signal_events as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let retarget_device_interrupt: u64 =
                unsafe { ::std::mem::transmute(retarget_device_interrupt) };
            retarget_device_interrupt as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved_z31: u64 = unsafe { ::std::mem::transmute(reserved_z31) };
            reserved_z31 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let reserved_z32: u64 = unsafe { ::std::mem::transmute(reserved_z32) };
            reserved_z32 as u64
        });
        __bindgen_bitfield_unit.set(33usize, 30u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_synthetic_processor_features"]
        [::std::mem::size_of::<hv_partition_synthetic_processor_features>() - 8usize];
    ["Alignment of hv_partition_synthetic_processor_features"]
        [::std::mem::align_of::<hv_partition_synthetic_processor_features>() - 8usize];
    ["Offset of field: hv_partition_synthetic_processor_features::as_uint64"]
        [::std::mem::offset_of!(hv_partition_synthetic_processor_features, as_uint64) - 0usize];
};
impl Default for hv_partition_synthetic_processor_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_INVALID:
    hv_partition_isolation_state = 0;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_INSECURE_CLEAN:
    hv_partition_isolation_state = 1;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_INSECURE_DIRTY:
    hv_partition_isolation_state = 2;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_SECURE: hv_partition_isolation_state =
    3;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_SECURE_DIRTY:
    hv_partition_isolation_state = 4;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_SECURE_TERMINATING:
    hv_partition_isolation_state = 5;
pub type hv_partition_isolation_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_isolation_properties {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_partition_isolation_properties__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_isolation_properties__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_isolation_properties__bindgen_ty_1"]
        [::std::mem::size_of::<hv_partition_isolation_properties__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_partition_isolation_properties__bindgen_ty_1"]
        [::std::mem::align_of::<hv_partition_isolation_properties__bindgen_ty_1>() - 1usize];
};
impl hv_partition_isolation_properties__bindgen_ty_1 {
    #[inline]
    pub fn isolation_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_isolation_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isolation_type_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_isolation_type_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn isolation_host_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_isolation_host_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isolation_host_type_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_isolation_host_type_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd_z(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd_z(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd_z_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd_z_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared_gpa_boundary_page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_shared_gpa_boundary_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_gpa_boundary_page_number_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                52u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_shared_gpa_boundary_page_number_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                52u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isolation_type: __u64,
        isolation_host_type: __u64,
        rsvd_z: __u64,
        shared_gpa_boundary_page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let isolation_type: u64 = unsafe { ::std::mem::transmute(isolation_type) };
            isolation_type as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let isolation_host_type: u64 = unsafe { ::std::mem::transmute(isolation_host_type) };
            isolation_host_type as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let rsvd_z: u64 = unsafe { ::std::mem::transmute(rsvd_z) };
            rsvd_z as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let shared_gpa_boundary_page_number: u64 =
                unsafe { ::std::mem::transmute(shared_gpa_boundary_page_number) };
            shared_gpa_boundary_page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_isolation_properties"]
        [::std::mem::size_of::<hv_partition_isolation_properties>() - 8usize];
    ["Alignment of hv_partition_isolation_properties"]
        [::std::mem::align_of::<hv_partition_isolation_properties>() - 8usize];
    ["Offset of field: hv_partition_isolation_properties::as_uint64"]
        [::std::mem::offset_of!(hv_partition_isolation_properties, as_uint64) - 0usize];
};
impl Default for hv_partition_isolation_properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_get_partition_property {
    pub partition_id: __u64,
    pub property_code: __u32,
    pub padding: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_get_partition_property"]
        [::std::mem::size_of::<hv_input_get_partition_property>() - 16usize];
    ["Alignment of hv_input_get_partition_property"]
        [::std::mem::align_of::<hv_input_get_partition_property>() - 1usize];
    ["Offset of field: hv_input_get_partition_property::partition_id"]
        [::std::mem::offset_of!(hv_input_get_partition_property, partition_id) - 0usize];
    ["Offset of field: hv_input_get_partition_property::property_code"]
        [::std::mem::offset_of!(hv_input_get_partition_property, property_code) - 8usize];
    ["Offset of field: hv_input_get_partition_property::padding"]
        [::std::mem::offset_of!(hv_input_get_partition_property, padding) - 12usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_get_partition_property {
    pub property_value: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_output_get_partition_property"]
        [::std::mem::size_of::<hv_output_get_partition_property>() - 8usize];
    ["Alignment of hv_output_get_partition_property"]
        [::std::mem::align_of::<hv_output_get_partition_property>() - 1usize];
    ["Offset of field: hv_output_get_partition_property::property_value"]
        [::std::mem::offset_of!(hv_output_get_partition_property, property_value) - 0usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_set_partition_property {
    pub partition_id: __u64,
    pub property_code: __u32,
    pub padding: __u32,
    pub property_value: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_set_partition_property"]
        [::std::mem::size_of::<hv_input_set_partition_property>() - 24usize];
    ["Alignment of hv_input_set_partition_property"]
        [::std::mem::align_of::<hv_input_set_partition_property>() - 1usize];
    ["Offset of field: hv_input_set_partition_property::partition_id"]
        [::std::mem::offset_of!(hv_input_set_partition_property, partition_id) - 0usize];
    ["Offset of field: hv_input_set_partition_property::property_code"]
        [::std::mem::offset_of!(hv_input_set_partition_property, property_code) - 8usize];
    ["Offset of field: hv_input_set_partition_property::padding"]
        [::std::mem::offset_of!(hv_input_set_partition_property, padding) - 12usize];
    ["Offset of field: hv_input_set_partition_property::property_value"]
        [::std::mem::offset_of!(hv_input_set_partition_property, property_value) - 16usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_cpuid_leaf_info {
    pub eax: __u32,
    pub ecx: __u32,
    pub xfem: __u64,
    pub xss: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_cpuid_leaf_info"][::std::mem::size_of::<hv_cpuid_leaf_info>() - 24usize];
    ["Alignment of hv_cpuid_leaf_info"][::std::mem::align_of::<hv_cpuid_leaf_info>() - 1usize];
    ["Offset of field: hv_cpuid_leaf_info::eax"]
        [::std::mem::offset_of!(hv_cpuid_leaf_info, eax) - 0usize];
    ["Offset of field: hv_cpuid_leaf_info::ecx"]
        [::std::mem::offset_of!(hv_cpuid_leaf_info, ecx) - 4usize];
    ["Offset of field: hv_cpuid_leaf_info::xfem"]
        [::std::mem::offset_of!(hv_cpuid_leaf_info, xfem) - 8usize];
    ["Offset of field: hv_cpuid_leaf_info::xss"]
        [::std::mem::offset_of!(hv_cpuid_leaf_info, xss) - 16usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_get_vp_cpuid_values_flags {
    pub as_uint32: __u32,
    pub __bindgen_anon_1: hv_get_vp_cpuid_values_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_get_vp_cpuid_values_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_get_vp_cpuid_values_flags__bindgen_ty_1"]
        [::std::mem::size_of::<hv_get_vp_cpuid_values_flags__bindgen_ty_1>() - 4usize];
    ["Alignment of hv_get_vp_cpuid_values_flags__bindgen_ty_1"]
        [::std::mem::align_of::<hv_get_vp_cpuid_values_flags__bindgen_ty_1>() - 1usize];
};
impl hv_get_vp_cpuid_values_flags__bindgen_ty_1 {
    #[inline]
    pub fn use_vp_xfem_xss(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_vp_xfem_xss(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_vp_xfem_xss_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_vp_xfem_xss_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apply_registered_values(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apply_registered_values(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apply_registered_values_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_apply_registered_values_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_vp_xfem_xss: __u32,
        apply_registered_values: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_vp_xfem_xss: u32 = unsafe { ::std::mem::transmute(use_vp_xfem_xss) };
            use_vp_xfem_xss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let apply_registered_values: u32 =
                unsafe { ::std::mem::transmute(apply_registered_values) };
            apply_registered_values as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_get_vp_cpuid_values_flags"]
        [::std::mem::size_of::<hv_get_vp_cpuid_values_flags>() - 4usize];
    ["Alignment of hv_get_vp_cpuid_values_flags"]
        [::std::mem::align_of::<hv_get_vp_cpuid_values_flags>() - 1usize];
    ["Offset of field: hv_get_vp_cpuid_values_flags::as_uint32"]
        [::std::mem::offset_of!(hv_get_vp_cpuid_values_flags, as_uint32) - 0usize];
};
impl Default for hv_get_vp_cpuid_values_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_get_vp_cpuid_values {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub flags: hv_get_vp_cpuid_values_flags,
    pub reserved: __u32,
    pub padding: __u32,
    pub cpuid_leaf_info: __IncompleteArrayField<hv_cpuid_leaf_info>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_get_vp_cpuid_values"]
        [::std::mem::size_of::<hv_input_get_vp_cpuid_values>() - 24usize];
    ["Alignment of hv_input_get_vp_cpuid_values"]
        [::std::mem::align_of::<hv_input_get_vp_cpuid_values>() - 1usize];
    ["Offset of field: hv_input_get_vp_cpuid_values::partition_id"]
        [::std::mem::offset_of!(hv_input_get_vp_cpuid_values, partition_id) - 0usize];
    ["Offset of field: hv_input_get_vp_cpuid_values::vp_index"]
        [::std::mem::offset_of!(hv_input_get_vp_cpuid_values, vp_index) - 8usize];
    ["Offset of field: hv_input_get_vp_cpuid_values::flags"]
        [::std::mem::offset_of!(hv_input_get_vp_cpuid_values, flags) - 12usize];
    ["Offset of field: hv_input_get_vp_cpuid_values::reserved"]
        [::std::mem::offset_of!(hv_input_get_vp_cpuid_values, reserved) - 16usize];
    ["Offset of field: hv_input_get_vp_cpuid_values::padding"]
        [::std::mem::offset_of!(hv_input_get_vp_cpuid_values, padding) - 20usize];
    ["Offset of field: hv_input_get_vp_cpuid_values::cpuid_leaf_info"]
        [::std::mem::offset_of!(hv_input_get_vp_cpuid_values, cpuid_leaf_info) - 24usize];
};
impl Default for hv_input_get_vp_cpuid_values {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_output_get_vp_cpuid_values {
    pub as_uint32: [__u32; 4usize],
    pub __bindgen_anon_1: hv_output_get_vp_cpuid_values__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_get_vp_cpuid_values__bindgen_ty_1 {
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_output_get_vp_cpuid_values__bindgen_ty_1"]
        [::std::mem::size_of::<hv_output_get_vp_cpuid_values__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_output_get_vp_cpuid_values__bindgen_ty_1"]
        [::std::mem::align_of::<hv_output_get_vp_cpuid_values__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_output_get_vp_cpuid_values__bindgen_ty_1::eax"]
        [::std::mem::offset_of!(hv_output_get_vp_cpuid_values__bindgen_ty_1, eax) - 0usize];
    ["Offset of field: hv_output_get_vp_cpuid_values__bindgen_ty_1::ebx"]
        [::std::mem::offset_of!(hv_output_get_vp_cpuid_values__bindgen_ty_1, ebx) - 4usize];
    ["Offset of field: hv_output_get_vp_cpuid_values__bindgen_ty_1::ecx"]
        [::std::mem::offset_of!(hv_output_get_vp_cpuid_values__bindgen_ty_1, ecx) - 8usize];
    ["Offset of field: hv_output_get_vp_cpuid_values__bindgen_ty_1::edx"]
        [::std::mem::offset_of!(hv_output_get_vp_cpuid_values__bindgen_ty_1, edx) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_output_get_vp_cpuid_values"]
        [::std::mem::size_of::<hv_output_get_vp_cpuid_values>() - 16usize];
    ["Alignment of hv_output_get_vp_cpuid_values"]
        [::std::mem::align_of::<hv_output_get_vp_cpuid_values>() - 4usize];
    ["Offset of field: hv_output_get_vp_cpuid_values::as_uint32"]
        [::std::mem::offset_of!(hv_output_get_vp_cpuid_values, as_uint32) - 0usize];
};
impl Default for hv_output_get_vp_cpuid_values {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_SUCCESS: hv_translate_gva_result_code = 0;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_PAGE_NOT_PRESENT:
    hv_translate_gva_result_code = 1;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_PRIVILEGE_VIOLATION:
    hv_translate_gva_result_code = 2;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_INVALIDE_PAGE_TABLE_FLAGS:
    hv_translate_gva_result_code = 3;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_UNMAPPED: hv_translate_gva_result_code =
    4;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_NO_READ_ACCESS:
    hv_translate_gva_result_code = 5;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_NO_WRITE_ACCESS:
    hv_translate_gva_result_code = 6;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_ILLEGAL_OVERLAY_ACCESS:
    hv_translate_gva_result_code = 7;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_INTERCEPT: hv_translate_gva_result_code = 8;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_UNACCEPTED:
    hv_translate_gva_result_code = 9;
pub type hv_translate_gva_result_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_translate_gva_result {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_translate_gva_result__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_translate_gva_result__bindgen_ty_1 {
    pub result_code: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_translate_gva_result__bindgen_ty_1"]
        [::std::mem::size_of::<hv_translate_gva_result__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_translate_gva_result__bindgen_ty_1"]
        [::std::mem::align_of::<hv_translate_gva_result__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_translate_gva_result__bindgen_ty_1::result_code"]
        [::std::mem::offset_of!(hv_translate_gva_result__bindgen_ty_1, result_code) - 0usize];
};
impl hv_translate_gva_result__bindgen_ty_1 {
    #[inline]
    pub fn cache_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cache_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cache_type_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cache_type_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overlay_page(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlay_page(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overlay_page_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overlay_page_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache_type: __u32,
        overlay_page: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cache_type: u32 = unsafe { ::std::mem::transmute(cache_type) };
            cache_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let overlay_page: u32 = unsafe { ::std::mem::transmute(overlay_page) };
            overlay_page as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_translate_gva_result"][::std::mem::size_of::<hv_translate_gva_result>() - 8usize];
    ["Alignment of hv_translate_gva_result"]
        [::std::mem::align_of::<hv_translate_gva_result>() - 8usize];
    ["Offset of field: hv_translate_gva_result::as_uint64"]
        [::std::mem::offset_of!(hv_translate_gva_result, as_uint64) - 0usize];
};
impl Default for hv_translate_gva_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_apic_eoi_message {
    pub vp_index: __u32,
    pub interrupt_vector: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_x64_apic_eoi_message"][::std::mem::size_of::<hv_x64_apic_eoi_message>() - 8usize];
    ["Alignment of hv_x64_apic_eoi_message"]
        [::std::mem::align_of::<hv_x64_apic_eoi_message>() - 1usize];
    ["Offset of field: hv_x64_apic_eoi_message::vp_index"]
        [::std::mem::offset_of!(hv_x64_apic_eoi_message, vp_index) - 0usize];
    ["Offset of field: hv_x64_apic_eoi_message::interrupt_vector"]
        [::std::mem::offset_of!(hv_x64_apic_eoi_message, interrupt_vector) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_opaque_intercept_message {
    pub vp_index: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_opaque_intercept_message"]
        [::std::mem::size_of::<hv_opaque_intercept_message>() - 4usize];
    ["Alignment of hv_opaque_intercept_message"]
        [::std::mem::align_of::<hv_opaque_intercept_message>() - 1usize];
    ["Offset of field: hv_opaque_intercept_message::vp_index"]
        [::std::mem::offset_of!(hv_opaque_intercept_message, vp_index) - 0usize];
};
pub const hv_port_type_HV_PORT_TYPE_MESSAGE: hv_port_type = 1;
pub const hv_port_type_HV_PORT_TYPE_EVENT: hv_port_type = 2;
pub const hv_port_type_HV_PORT_TYPE_MONITOR: hv_port_type = 3;
pub const hv_port_type_HV_PORT_TYPE_DOORBELL: hv_port_type = 4;
pub type hv_port_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_port_info {
    pub port_type: __u32,
    pub padding: __u32,
    pub __bindgen_anon_1: hv_port_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_port_info__bindgen_ty_1 {
    pub message_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_1,
    pub event_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_2,
    pub monitor_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_3,
    pub doorbell_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_1 {
    pub target_sint: __u32,
    pub target_vp: __u32,
    pub rsvdz: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_info__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_port_info__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_1::target_sint"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_1, target_sint) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_1::target_vp"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_1, target_vp) - 4usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_1::rsvdz"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_1, rsvdz) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_2 {
    pub target_sint: __u32,
    pub target_vp: __u32,
    pub base_flag_number: __u16,
    pub flag_count: __u16,
    pub rsvdz: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_info__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of hv_port_info__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_2::target_sint"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_2, target_sint) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_2::target_vp"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_2, target_vp) - 4usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_2::base_flag_number"][::std::mem::offset_of!(
        hv_port_info__bindgen_ty_1__bindgen_ty_2,
        base_flag_number
    ) - 8usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_2::flag_count"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_2, flag_count) - 10usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_2::rsvdz"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_2, rsvdz) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_3 {
    pub monitor_address: __u64,
    pub rsvdz: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_info__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of hv_port_info__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_3::monitor_address"][::std::mem::offset_of!(
        hv_port_info__bindgen_ty_1__bindgen_ty_3,
        monitor_address
    ) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_3::rsvdz"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_3, rsvdz) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_sint: __u32,
    pub target_vp: __u32,
    pub rsvdz: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_info__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_4>() - 16usize];
    ["Alignment of hv_port_info__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_4::target_sint"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_4, target_sint) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_4::target_vp"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_4, target_vp) - 4usize];
    ["Offset of field: hv_port_info__bindgen_ty_1__bindgen_ty_4::rsvdz"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1__bindgen_ty_4, rsvdz) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_info__bindgen_ty_1"]
        [::std::mem::size_of::<hv_port_info__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_port_info__bindgen_ty_1"]
        [::std::mem::align_of::<hv_port_info__bindgen_ty_1>() - 8usize];
    ["Offset of field: hv_port_info__bindgen_ty_1::message_port_info"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1, message_port_info) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1::event_port_info"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1, event_port_info) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1::monitor_port_info"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1, monitor_port_info) - 0usize];
    ["Offset of field: hv_port_info__bindgen_ty_1::doorbell_port_info"]
        [::std::mem::offset_of!(hv_port_info__bindgen_ty_1, doorbell_port_info) - 0usize];
};
impl Default for hv_port_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_port_info"][::std::mem::size_of::<hv_port_info>() - 24usize];
    ["Alignment of hv_port_info"][::std::mem::align_of::<hv_port_info>() - 1usize];
    ["Offset of field: hv_port_info::port_type"]
        [::std::mem::offset_of!(hv_port_info, port_type) - 0usize];
    ["Offset of field: hv_port_info::padding"]
        [::std::mem::offset_of!(hv_port_info, padding) - 4usize];
};
impl Default for hv_port_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_interrupt_control {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_interrupt_control__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_interrupt_control__bindgen_ty_1 {
    pub interrupt_type: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_interrupt_control__bindgen_ty_1"]
        [::std::mem::size_of::<hv_interrupt_control__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_interrupt_control__bindgen_ty_1"]
        [::std::mem::align_of::<hv_interrupt_control__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_interrupt_control__bindgen_ty_1::interrupt_type"]
        [::std::mem::offset_of!(hv_interrupt_control__bindgen_ty_1, interrupt_type) - 0usize];
};
impl hv_interrupt_control__bindgen_ty_1 {
    #[inline]
    pub fn level_triggered(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_triggered(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn level_triggered_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_level_triggered_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn logical_dest_mode(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest_mode(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn logical_dest_mode_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_logical_dest_mode_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn asserted(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_asserted(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn asserted_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_asserted_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        level_triggered: __u32,
        logical_dest_mode: __u32,
        asserted: __u32,
        rsvd: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let level_triggered: u32 = unsafe { ::std::mem::transmute(level_triggered) };
            level_triggered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let logical_dest_mode: u32 = unsafe { ::std::mem::transmute(logical_dest_mode) };
            logical_dest_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let asserted: u32 = unsafe { ::std::mem::transmute(asserted) };
            asserted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let rsvd: u32 = unsafe { ::std::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_interrupt_control"][::std::mem::size_of::<hv_interrupt_control>() - 8usize];
    ["Alignment of hv_interrupt_control"][::std::mem::align_of::<hv_interrupt_control>() - 8usize];
    ["Offset of field: hv_interrupt_control::as_uint64"]
        [::std::mem::offset_of!(hv_interrupt_control, as_uint64) - 0usize];
};
impl Default for hv_interrupt_control {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stimer_state {
    pub flags: hv_stimer_state__bindgen_ty_1,
    pub resvd: __u32,
    pub config: __u64,
    pub count: __u64,
    pub adjustment: __u64,
    pub undelivered_exp_time: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stimer_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_stimer_state__bindgen_ty_1"]
        [::std::mem::size_of::<hv_stimer_state__bindgen_ty_1>() - 4usize];
    ["Alignment of hv_stimer_state__bindgen_ty_1"]
        [::std::mem::align_of::<hv_stimer_state__bindgen_ty_1>() - 1usize];
};
impl hv_stimer_state__bindgen_ty_1 {
    #[inline]
    pub fn undelivered_msg_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_undelivered_msg_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn undelivered_msg_pending_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_undelivered_msg_pending_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        undelivered_msg_pending: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let undelivered_msg_pending: u32 =
                unsafe { ::std::mem::transmute(undelivered_msg_pending) };
            undelivered_msg_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_stimer_state"][::std::mem::size_of::<hv_stimer_state>() - 40usize];
    ["Alignment of hv_stimer_state"][::std::mem::align_of::<hv_stimer_state>() - 1usize];
    ["Offset of field: hv_stimer_state::flags"]
        [::std::mem::offset_of!(hv_stimer_state, flags) - 0usize];
    ["Offset of field: hv_stimer_state::resvd"]
        [::std::mem::offset_of!(hv_stimer_state, resvd) - 4usize];
    ["Offset of field: hv_stimer_state::config"]
        [::std::mem::offset_of!(hv_stimer_state, config) - 8usize];
    ["Offset of field: hv_stimer_state::count"]
        [::std::mem::offset_of!(hv_stimer_state, count) - 16usize];
    ["Offset of field: hv_stimer_state::adjustment"]
        [::std::mem::offset_of!(hv_stimer_state, adjustment) - 24usize];
    ["Offset of field: hv_stimer_state::undelivered_exp_time"]
        [::std::mem::offset_of!(hv_stimer_state, undelivered_exp_time) - 32usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synthetic_timers_state {
    pub timers: [hv_stimer_state; 4usize],
    pub reserved: [__u64; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_synthetic_timers_state"]
        [::std::mem::size_of::<hv_synthetic_timers_state>() - 200usize];
    ["Alignment of hv_synthetic_timers_state"]
        [::std::mem::align_of::<hv_synthetic_timers_state>() - 1usize];
    ["Offset of field: hv_synthetic_timers_state::timers"]
        [::std::mem::offset_of!(hv_synthetic_timers_state, timers) - 0usize];
    ["Offset of field: hv_synthetic_timers_state::reserved"]
        [::std::mem::offset_of!(hv_synthetic_timers_state, reserved) - 160usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_arm64_vp_execution_state {
    pub as_uint16: __u16,
    pub __bindgen_anon_1: hv_arm64_vp_execution_state__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_arm64_vp_execution_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_vp_execution_state__bindgen_ty_1"]
        [::std::mem::size_of::<hv_arm64_vp_execution_state__bindgen_ty_1>() - 2usize];
    ["Alignment of hv_arm64_vp_execution_state__bindgen_ty_1"]
        [::std::mem::align_of::<hv_arm64_vp_execution_state__bindgen_ty_1>() - 1usize];
};
impl hv_arm64_vp_execution_state__bindgen_ty_1 {
    #[inline]
    pub fn cpl(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cpl(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cpl_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_cpl_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn debug_active(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_debug_active(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn debug_active_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_debug_active_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn interruption_pending(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_interruption_pending(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interruption_pending_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_interruption_pending_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vtl(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_vtl(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vtl_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_vtl_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn virtualization_fault_active(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_virtualization_fault_active(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn virtualization_fault_active_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_virtualization_fault_active_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                7u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpl: __u16,
        debug_active: __u16,
        interruption_pending: __u16,
        vtl: __u16,
        virtualization_fault_active: __u16,
        reserved: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cpl: u16 = unsafe { ::std::mem::transmute(cpl) };
            cpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let debug_active: u16 = unsafe { ::std::mem::transmute(debug_active) };
            debug_active as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let interruption_pending: u16 = unsafe { ::std::mem::transmute(interruption_pending) };
            interruption_pending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let vtl: u16 = unsafe { ::std::mem::transmute(vtl) };
            vtl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let virtualization_fault_active: u16 =
                unsafe { ::std::mem::transmute(virtualization_fault_active) };
            virtualization_fault_active as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_vp_execution_state"]
        [::std::mem::size_of::<hv_arm64_vp_execution_state>() - 2usize];
    ["Alignment of hv_arm64_vp_execution_state"]
        [::std::mem::align_of::<hv_arm64_vp_execution_state>() - 1usize];
    ["Offset of field: hv_arm64_vp_execution_state::as_uint16"]
        [::std::mem::offset_of!(hv_arm64_vp_execution_state, as_uint16) - 0usize];
};
impl Default for hv_arm64_vp_execution_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_arm64_intercept_message_header {
    pub vp_index: __u32,
    pub instruction_length: __u8,
    pub intercept_access_type: __u8,
    pub execution_state: hv_arm64_vp_execution_state,
    pub pc: __u64,
    pub cpsr: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_intercept_message_header"]
        [::std::mem::size_of::<hv_arm64_intercept_message_header>() - 24usize];
    ["Alignment of hv_arm64_intercept_message_header"]
        [::std::mem::align_of::<hv_arm64_intercept_message_header>() - 1usize];
    ["Offset of field: hv_arm64_intercept_message_header::vp_index"]
        [::std::mem::offset_of!(hv_arm64_intercept_message_header, vp_index) - 0usize];
    ["Offset of field: hv_arm64_intercept_message_header::instruction_length"]
        [::std::mem::offset_of!(hv_arm64_intercept_message_header, instruction_length) - 4usize];
    ["Offset of field: hv_arm64_intercept_message_header::intercept_access_type"]
        [::std::mem::offset_of!(hv_arm64_intercept_message_header, intercept_access_type) - 5usize];
    ["Offset of field: hv_arm64_intercept_message_header::execution_state"]
        [::std::mem::offset_of!(hv_arm64_intercept_message_header, execution_state) - 6usize];
    ["Offset of field: hv_arm64_intercept_message_header::pc"]
        [::std::mem::offset_of!(hv_arm64_intercept_message_header, pc) - 8usize];
    ["Offset of field: hv_arm64_intercept_message_header::cpsr"]
        [::std::mem::offset_of!(hv_arm64_intercept_message_header, cpsr) - 16usize];
};
impl Default for hv_arm64_intercept_message_header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_arm64_register_access_info {
    pub source_value: hv_register_value,
    pub destination_register: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_register_access_info"]
        [::std::mem::size_of::<hv_arm64_register_access_info>() - 16usize];
    ["Alignment of hv_arm64_register_access_info"]
        [::std::mem::align_of::<hv_arm64_register_access_info>() - 1usize];
    ["Offset of field: hv_arm64_register_access_info::source_value"]
        [::std::mem::offset_of!(hv_arm64_register_access_info, source_value) - 0usize];
    ["Offset of field: hv_arm64_register_access_info::destination_register"]
        [::std::mem::offset_of!(hv_arm64_register_access_info, destination_register) - 0usize];
};
impl Default for hv_arm64_register_access_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_arm64_register_intercept_message {
    pub Header: hv_arm64_intercept_message_header,
    pub __bindgen_anon_1: hv_arm64_register_intercept_message__bindgen_ty_1,
    pub reserved8: __u8,
    pub reserved16: __u16,
    pub register_name: __u32,
    pub access_info: hv_arm64_register_access_info,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_arm64_register_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_register_intercept_message__bindgen_ty_1"]
        [::std::mem::size_of::<hv_arm64_register_intercept_message__bindgen_ty_1>() - 1usize];
    ["Alignment of hv_arm64_register_intercept_message__bindgen_ty_1"]
        [::std::mem::align_of::<hv_arm64_register_intercept_message__bindgen_ty_1>() - 1usize];
};
impl hv_arm64_register_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn is_memory_op(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_memory_op(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_memory_op_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_memory_op_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_memory_op: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_memory_op: u8 = unsafe { ::std::mem::transmute(is_memory_op) };
            is_memory_op as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_register_intercept_message"]
        [::std::mem::size_of::<hv_arm64_register_intercept_message>() - 48usize];
    ["Alignment of hv_arm64_register_intercept_message"]
        [::std::mem::align_of::<hv_arm64_register_intercept_message>() - 1usize];
    ["Offset of field: hv_arm64_register_intercept_message::Header"]
        [::std::mem::offset_of!(hv_arm64_register_intercept_message, Header) - 0usize];
    ["Offset of field: hv_arm64_register_intercept_message::reserved8"]
        [::std::mem::offset_of!(hv_arm64_register_intercept_message, reserved8) - 25usize];
    ["Offset of field: hv_arm64_register_intercept_message::reserved16"]
        [::std::mem::offset_of!(hv_arm64_register_intercept_message, reserved16) - 26usize];
    ["Offset of field: hv_arm64_register_intercept_message::register_name"]
        [::std::mem::offset_of!(hv_arm64_register_intercept_message, register_name) - 28usize];
    ["Offset of field: hv_arm64_register_intercept_message::access_info"]
        [::std::mem::offset_of!(hv_arm64_register_intercept_message, access_info) - 32usize];
};
impl Default for hv_arm64_register_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_arm64_memory_access_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_arm64_memory_access_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_arm64_memory_access_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_memory_access_info__bindgen_ty_1"]
        [::std::mem::size_of::<hv_arm64_memory_access_info__bindgen_ty_1>() - 1usize];
    ["Alignment of hv_arm64_memory_access_info__bindgen_ty_1"]
        [::std::mem::align_of::<hv_arm64_memory_access_info__bindgen_ty_1>() - 1usize];
};
impl hv_arm64_memory_access_info__bindgen_ty_1 {
    #[inline]
    pub fn gva_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gva_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gva_valid_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_gva_valid_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gva_gpa_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gva_gpa_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gva_gpa_valid_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_gva_gpa_valid_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hypercall_output_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hypercall_output_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hypercall_output_pending_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hypercall_output_pending_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gva_valid: __u8,
        gva_gpa_valid: __u8,
        hypercall_output_pending: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gva_valid: u8 = unsafe { ::std::mem::transmute(gva_valid) };
            gva_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gva_gpa_valid: u8 = unsafe { ::std::mem::transmute(gva_gpa_valid) };
            gva_gpa_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hypercall_output_pending: u8 =
                unsafe { ::std::mem::transmute(hypercall_output_pending) };
            hypercall_output_pending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_memory_access_info"]
        [::std::mem::size_of::<hv_arm64_memory_access_info>() - 1usize];
    ["Alignment of hv_arm64_memory_access_info"]
        [::std::mem::align_of::<hv_arm64_memory_access_info>() - 1usize];
    ["Offset of field: hv_arm64_memory_access_info::as_uint8"]
        [::std::mem::offset_of!(hv_arm64_memory_access_info, as_uint8) - 0usize];
};
impl Default for hv_arm64_memory_access_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_arm64_memory_intercept_message {
    pub header: hv_arm64_intercept_message_header,
    pub cache_type: __u32,
    pub instruction_byte_count: __u8,
    pub memory_access_info: hv_arm64_memory_access_info,
    pub reserved1: __u16,
    pub instruction_bytes: [__u8; 4usize],
    pub reserved2: __u32,
    pub guest_virtual_address: __u64,
    pub guest_physical_address: __u64,
    pub syndrome: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_arm64_memory_intercept_message"]
        [::std::mem::size_of::<hv_arm64_memory_intercept_message>() - 64usize];
    ["Alignment of hv_arm64_memory_intercept_message"]
        [::std::mem::align_of::<hv_arm64_memory_intercept_message>() - 1usize];
    ["Offset of field: hv_arm64_memory_intercept_message::header"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, header) - 0usize];
    ["Offset of field: hv_arm64_memory_intercept_message::cache_type"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, cache_type) - 24usize];
    ["Offset of field: hv_arm64_memory_intercept_message::instruction_byte_count"][::std::mem::offset_of!(
        hv_arm64_memory_intercept_message,
        instruction_byte_count
    ) - 28usize];
    ["Offset of field: hv_arm64_memory_intercept_message::memory_access_info"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, memory_access_info) - 29usize];
    ["Offset of field: hv_arm64_memory_intercept_message::reserved1"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, reserved1) - 30usize];
    ["Offset of field: hv_arm64_memory_intercept_message::instruction_bytes"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, instruction_bytes) - 32usize];
    ["Offset of field: hv_arm64_memory_intercept_message::reserved2"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, reserved2) - 36usize];
    ["Offset of field: hv_arm64_memory_intercept_message::guest_virtual_address"][::std::mem::offset_of!(
        hv_arm64_memory_intercept_message,
        guest_virtual_address
    ) - 40usize];
    ["Offset of field: hv_arm64_memory_intercept_message::guest_physical_address"][::std::mem::offset_of!(
        hv_arm64_memory_intercept_message,
        guest_physical_address
    ) - 48usize];
    ["Offset of field: hv_arm64_memory_intercept_message::syndrome"]
        [::std::mem::offset_of!(hv_arm64_memory_intercept_message, syndrome) - 56usize];
};
impl Default for hv_arm64_memory_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_translate_virtual_address {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub padding: __u32,
    pub control_flags: __u64,
    pub gva_page: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_translate_virtual_address"]
        [::std::mem::size_of::<hv_input_translate_virtual_address>() - 32usize];
    ["Alignment of hv_input_translate_virtual_address"]
        [::std::mem::align_of::<hv_input_translate_virtual_address>() - 1usize];
    ["Offset of field: hv_input_translate_virtual_address::partition_id"]
        [::std::mem::offset_of!(hv_input_translate_virtual_address, partition_id) - 0usize];
    ["Offset of field: hv_input_translate_virtual_address::vp_index"]
        [::std::mem::offset_of!(hv_input_translate_virtual_address, vp_index) - 8usize];
    ["Offset of field: hv_input_translate_virtual_address::padding"]
        [::std::mem::offset_of!(hv_input_translate_virtual_address, padding) - 12usize];
    ["Offset of field: hv_input_translate_virtual_address::control_flags"]
        [::std::mem::offset_of!(hv_input_translate_virtual_address, control_flags) - 16usize];
    ["Offset of field: hv_input_translate_virtual_address::gva_page"]
        [::std::mem::offset_of!(hv_input_translate_virtual_address, gva_page) - 24usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_translate_virtual_address {
    pub translation_result: hv_translate_gva_result,
    pub gpa_page: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_output_translate_virtual_address"]
        [::std::mem::size_of::<hv_output_translate_virtual_address>() - 16usize];
    ["Alignment of hv_output_translate_virtual_address"]
        [::std::mem::align_of::<hv_output_translate_virtual_address>() - 1usize];
    ["Offset of field: hv_output_translate_virtual_address::translation_result"]
        [::std::mem::offset_of!(hv_output_translate_virtual_address, translation_result) - 0usize];
    ["Offset of field: hv_output_translate_virtual_address::gpa_page"]
        [::std::mem::offset_of!(hv_output_translate_virtual_address, gpa_page) - 8usize];
};
impl Default for hv_output_translate_virtual_address {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_psp_cpuid_leaf {
    pub eax_in: __u32,
    pub ecx_in: __u32,
    pub xfem_in: __u64,
    pub xss_in: __u64,
    pub eax_out: __u32,
    pub ebx_out: __u32,
    pub ecx_out: __u32,
    pub edx_out: __u32,
    pub reserved_z: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_psp_cpuid_leaf"][::std::mem::size_of::<hv_psp_cpuid_leaf>() - 48usize];
    ["Alignment of hv_psp_cpuid_leaf"][::std::mem::align_of::<hv_psp_cpuid_leaf>() - 1usize];
    ["Offset of field: hv_psp_cpuid_leaf::eax_in"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, eax_in) - 0usize];
    ["Offset of field: hv_psp_cpuid_leaf::ecx_in"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, ecx_in) - 4usize];
    ["Offset of field: hv_psp_cpuid_leaf::xfem_in"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, xfem_in) - 8usize];
    ["Offset of field: hv_psp_cpuid_leaf::xss_in"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, xss_in) - 16usize];
    ["Offset of field: hv_psp_cpuid_leaf::eax_out"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, eax_out) - 24usize];
    ["Offset of field: hv_psp_cpuid_leaf::ebx_out"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, ebx_out) - 28usize];
    ["Offset of field: hv_psp_cpuid_leaf::ecx_out"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, ecx_out) - 32usize];
    ["Offset of field: hv_psp_cpuid_leaf::edx_out"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, edx_out) - 36usize];
    ["Offset of field: hv_psp_cpuid_leaf::reserved_z"]
        [::std::mem::offset_of!(hv_psp_cpuid_leaf, reserved_z) - 40usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_psp_cpuid_page {
    pub count: __u32,
    pub reserved_z1: __u32,
    pub reserved_z2: __u64,
    pub cpuid_leaf_info: [hv_psp_cpuid_leaf; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_psp_cpuid_page"][::std::mem::size_of::<hv_psp_cpuid_page>() - 3088usize];
    ["Alignment of hv_psp_cpuid_page"][::std::mem::align_of::<hv_psp_cpuid_page>() - 1usize];
    ["Offset of field: hv_psp_cpuid_page::count"]
        [::std::mem::offset_of!(hv_psp_cpuid_page, count) - 0usize];
    ["Offset of field: hv_psp_cpuid_page::reserved_z1"]
        [::std::mem::offset_of!(hv_psp_cpuid_page, reserved_z1) - 4usize];
    ["Offset of field: hv_psp_cpuid_page::reserved_z2"]
        [::std::mem::offset_of!(hv_psp_cpuid_page, reserved_z2) - 8usize];
    ["Offset of field: hv_psp_cpuid_page::cpuid_leaf_info"]
        [::std::mem::offset_of!(hv_psp_cpuid_page, cpuid_leaf_info) - 16usize];
};
impl Default for hv_psp_cpuid_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_NORMAL: hv_isolated_page_type = 0;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_VMSA: hv_isolated_page_type = 1;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_ZERO: hv_isolated_page_type = 2;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_UNMEASURED: hv_isolated_page_type = 3;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_SECRETS: hv_isolated_page_type = 4;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_CPUID: hv_isolated_page_type = 5;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_COUNT: hv_isolated_page_type = 6;
pub type hv_isolated_page_type = ::std::os::raw::c_uint;
pub const hv_isolated_page_size_HV_ISOLATED_PAGE_SIZE_4KB: hv_isolated_page_size = 0;
pub const hv_isolated_page_size_HV_ISOLATED_PAGE_SIZE_2MB: hv_isolated_page_size = 1;
pub type hv_isolated_page_size = ::std::os::raw::c_uint;
#[repr(C, packed)]
pub struct hv_input_import_isolated_pages {
    pub partition_id: __u64,
    pub page_type: __u32,
    pub page_size: __u32,
    pub page_number: __IncompleteArrayField<__u64>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_import_isolated_pages"]
        [::std::mem::size_of::<hv_input_import_isolated_pages>() - 16usize];
    ["Alignment of hv_input_import_isolated_pages"]
        [::std::mem::align_of::<hv_input_import_isolated_pages>() - 1usize];
    ["Offset of field: hv_input_import_isolated_pages::partition_id"]
        [::std::mem::offset_of!(hv_input_import_isolated_pages, partition_id) - 0usize];
    ["Offset of field: hv_input_import_isolated_pages::page_type"]
        [::std::mem::offset_of!(hv_input_import_isolated_pages, page_type) - 8usize];
    ["Offset of field: hv_input_import_isolated_pages::page_size"]
        [::std::mem::offset_of!(hv_input_import_isolated_pages, page_size) - 12usize];
    ["Offset of field: hv_input_import_isolated_pages::page_number"]
        [::std::mem::offset_of!(hv_input_import_isolated_pages, page_number) - 16usize];
};
impl Default for hv_input_import_isolated_pages {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_sev_vmgexit_offload {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_sev_vmgexit_offload__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_sev_vmgexit_offload__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_sev_vmgexit_offload__bindgen_ty_1"]
        [::std::mem::size_of::<hv_sev_vmgexit_offload__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_sev_vmgexit_offload__bindgen_ty_1"]
        [::std::mem::align_of::<hv_sev_vmgexit_offload__bindgen_ty_1>() - 1usize];
};
impl hv_sev_vmgexit_offload__bindgen_ty_1 {
    #[inline]
    pub fn nae_rdtsc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_rdtsc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_rdtsc_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_rdtsc_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_cpuid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_cpuid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_cpuid_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_cpuid_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_reserved_io_port(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_reserved_io_port(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_reserved_io_port_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_reserved_io_port_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_rdmsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_rdmsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_rdmsr_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_rdmsr_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_wrmsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_wrmsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_wrmsr_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_wrmsr_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_vmmcall(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_vmmcall(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_vmmcall_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_vmmcall_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_wbinvd(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_wbinvd(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_wbinvd_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_wbinvd_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nae_snp_page_state_change(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_snp_page_state_change(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nae_snp_page_state_change_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_nae_snp_page_state_change_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved0(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved0_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved0_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn msr_cpuid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_msr_cpuid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msr_cpuid_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_msr_cpuid_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn msr_snp_page_state_change(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_msr_snp_page_state_change(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn msr_snp_page_state_change_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_msr_snp_page_state_change_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                30u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nae_rdtsc: __u64,
        nae_cpuid: __u64,
        nae_reserved_io_port: __u64,
        nae_rdmsr: __u64,
        nae_wrmsr: __u64,
        nae_vmmcall: __u64,
        nae_wbinvd: __u64,
        nae_snp_page_state_change: __u64,
        reserved0: __u64,
        msr_cpuid: __u64,
        msr_snp_page_state_change: __u64,
        reserved1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nae_rdtsc: u64 = unsafe { ::std::mem::transmute(nae_rdtsc) };
            nae_rdtsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nae_cpuid: u64 = unsafe { ::std::mem::transmute(nae_cpuid) };
            nae_cpuid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nae_reserved_io_port: u64 = unsafe { ::std::mem::transmute(nae_reserved_io_port) };
            nae_reserved_io_port as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nae_rdmsr: u64 = unsafe { ::std::mem::transmute(nae_rdmsr) };
            nae_rdmsr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nae_wrmsr: u64 = unsafe { ::std::mem::transmute(nae_wrmsr) };
            nae_wrmsr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nae_vmmcall: u64 = unsafe { ::std::mem::transmute(nae_vmmcall) };
            nae_vmmcall as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let nae_wbinvd: u64 = unsafe { ::std::mem::transmute(nae_wbinvd) };
            nae_wbinvd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nae_snp_page_state_change: u64 =
                unsafe { ::std::mem::transmute(nae_snp_page_state_change) };
            nae_snp_page_state_change as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved0: u64 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let msr_cpuid: u64 = unsafe { ::std::mem::transmute(msr_cpuid) };
            msr_cpuid as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let msr_snp_page_state_change: u64 =
                unsafe { ::std::mem::transmute(msr_snp_page_state_change) };
            msr_snp_page_state_change as u64
        });
        __bindgen_bitfield_unit.set(34usize, 30u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_sev_vmgexit_offload"][::std::mem::size_of::<hv_sev_vmgexit_offload>() - 8usize];
    ["Alignment of hv_sev_vmgexit_offload"]
        [::std::mem::align_of::<hv_sev_vmgexit_offload>() - 8usize];
    ["Offset of field: hv_sev_vmgexit_offload::as_uint64"]
        [::std::mem::offset_of!(hv_sev_vmgexit_offload, as_uint64) - 0usize];
};
impl Default for hv_sev_vmgexit_offload {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_SUCCESS: hv_access_gpa_result_code = 0;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_UNMAPPED: hv_access_gpa_result_code = 1;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_READ_INTERCEPT: hv_access_gpa_result_code = 2;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_WRITE_INTERCEPT: hv_access_gpa_result_code = 3;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_ILLEGAL_OVERLAY_ACCESS:
    hv_access_gpa_result_code = 4;
pub type hv_access_gpa_result_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_access_gpa_result {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_access_gpa_result__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_access_gpa_result__bindgen_ty_1 {
    pub result_code: __u32,
    pub reserved: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_access_gpa_result__bindgen_ty_1"]
        [::std::mem::size_of::<hv_access_gpa_result__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_access_gpa_result__bindgen_ty_1"]
        [::std::mem::align_of::<hv_access_gpa_result__bindgen_ty_1>() - 1usize];
    ["Offset of field: hv_access_gpa_result__bindgen_ty_1::result_code"]
        [::std::mem::offset_of!(hv_access_gpa_result__bindgen_ty_1, result_code) - 0usize];
    ["Offset of field: hv_access_gpa_result__bindgen_ty_1::reserved"]
        [::std::mem::offset_of!(hv_access_gpa_result__bindgen_ty_1, reserved) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_access_gpa_result"][::std::mem::size_of::<hv_access_gpa_result>() - 8usize];
    ["Alignment of hv_access_gpa_result"][::std::mem::align_of::<hv_access_gpa_result>() - 8usize];
    ["Offset of field: hv_access_gpa_result::as_uint64"]
        [::std::mem::offset_of!(hv_access_gpa_result, as_uint64) - 0usize];
};
impl Default for hv_access_gpa_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_access_gpa_control_flags {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_access_gpa_control_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_access_gpa_control_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_access_gpa_control_flags__bindgen_ty_1"]
        [::std::mem::size_of::<hv_access_gpa_control_flags__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_access_gpa_control_flags__bindgen_ty_1"]
        [::std::mem::align_of::<hv_access_gpa_control_flags__bindgen_ty_1>() - 1usize];
};
impl hv_access_gpa_control_flags__bindgen_ty_1 {
    #[inline]
    pub fn cache_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_cache_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cache_type_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_cache_type_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache_type: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cache_type: u64 = unsafe { ::std::mem::transmute(cache_type) };
            cache_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_access_gpa_control_flags"]
        [::std::mem::size_of::<hv_access_gpa_control_flags>() - 8usize];
    ["Alignment of hv_access_gpa_control_flags"]
        [::std::mem::align_of::<hv_access_gpa_control_flags>() - 8usize];
    ["Offset of field: hv_access_gpa_control_flags::as_uint64"]
        [::std::mem::offset_of!(hv_access_gpa_control_flags, as_uint64) - 0usize];
};
impl Default for hv_access_gpa_control_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_read_gpa {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub byte_count: __u32,
    pub base_gpa: __u64,
    pub control_flags: hv_access_gpa_control_flags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_read_gpa"][::std::mem::size_of::<hv_input_read_gpa>() - 32usize];
    ["Alignment of hv_input_read_gpa"][::std::mem::align_of::<hv_input_read_gpa>() - 1usize];
    ["Offset of field: hv_input_read_gpa::partition_id"]
        [::std::mem::offset_of!(hv_input_read_gpa, partition_id) - 0usize];
    ["Offset of field: hv_input_read_gpa::vp_index"]
        [::std::mem::offset_of!(hv_input_read_gpa, vp_index) - 8usize];
    ["Offset of field: hv_input_read_gpa::byte_count"]
        [::std::mem::offset_of!(hv_input_read_gpa, byte_count) - 12usize];
    ["Offset of field: hv_input_read_gpa::base_gpa"]
        [::std::mem::offset_of!(hv_input_read_gpa, base_gpa) - 16usize];
    ["Offset of field: hv_input_read_gpa::control_flags"]
        [::std::mem::offset_of!(hv_input_read_gpa, control_flags) - 24usize];
};
impl Default for hv_input_read_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_read_gpa {
    pub access_result: hv_access_gpa_result,
    pub data: [__u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_output_read_gpa"][::std::mem::size_of::<hv_output_read_gpa>() - 24usize];
    ["Alignment of hv_output_read_gpa"][::std::mem::align_of::<hv_output_read_gpa>() - 1usize];
    ["Offset of field: hv_output_read_gpa::access_result"]
        [::std::mem::offset_of!(hv_output_read_gpa, access_result) - 0usize];
    ["Offset of field: hv_output_read_gpa::data"]
        [::std::mem::offset_of!(hv_output_read_gpa, data) - 8usize];
};
impl Default for hv_output_read_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_write_gpa {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub byte_count: __u32,
    pub base_gpa: __u64,
    pub control_flags: hv_access_gpa_control_flags,
    pub data: [__u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_write_gpa"][::std::mem::size_of::<hv_input_write_gpa>() - 48usize];
    ["Alignment of hv_input_write_gpa"][::std::mem::align_of::<hv_input_write_gpa>() - 1usize];
    ["Offset of field: hv_input_write_gpa::partition_id"]
        [::std::mem::offset_of!(hv_input_write_gpa, partition_id) - 0usize];
    ["Offset of field: hv_input_write_gpa::vp_index"]
        [::std::mem::offset_of!(hv_input_write_gpa, vp_index) - 8usize];
    ["Offset of field: hv_input_write_gpa::byte_count"]
        [::std::mem::offset_of!(hv_input_write_gpa, byte_count) - 12usize];
    ["Offset of field: hv_input_write_gpa::base_gpa"]
        [::std::mem::offset_of!(hv_input_write_gpa, base_gpa) - 16usize];
    ["Offset of field: hv_input_write_gpa::control_flags"]
        [::std::mem::offset_of!(hv_input_write_gpa, control_flags) - 24usize];
    ["Offset of field: hv_input_write_gpa::data"]
        [::std::mem::offset_of!(hv_input_write_gpa, data) - 32usize];
};
impl Default for hv_input_write_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_write_gpa {
    pub access_result: hv_access_gpa_result,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_output_write_gpa"][::std::mem::size_of::<hv_output_write_gpa>() - 8usize];
    ["Alignment of hv_output_write_gpa"][::std::mem::align_of::<hv_output_write_gpa>() - 1usize];
    ["Offset of field: hv_output_write_gpa::access_result"]
        [::std::mem::offset_of!(hv_output_write_gpa, access_result) - 0usize];
};
impl Default for hv_output_write_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_issue_psp_guest_request {
    pub partition_id: __u64,
    pub request_page: __u64,
    pub response_page: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_input_issue_psp_guest_request"]
        [::std::mem::size_of::<hv_input_issue_psp_guest_request>() - 24usize];
    ["Alignment of hv_input_issue_psp_guest_request"]
        [::std::mem::align_of::<hv_input_issue_psp_guest_request>() - 1usize];
    ["Offset of field: hv_input_issue_psp_guest_request::partition_id"]
        [::std::mem::offset_of!(hv_input_issue_psp_guest_request, partition_id) - 0usize];
    ["Offset of field: hv_input_issue_psp_guest_request::request_page"]
        [::std::mem::offset_of!(hv_input_issue_psp_guest_request, request_page) - 8usize];
    ["Offset of field: hv_input_issue_psp_guest_request::response_page"]
        [::std::mem::offset_of!(hv_input_issue_psp_guest_request, response_page) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_processor_xsave_features {
    pub __bindgen_anon_1: hv_partition_processor_xsave_features__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_processor_xsave_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_processor_xsave_features__bindgen_ty_1"]
        [::std::mem::size_of::<hv_partition_processor_xsave_features__bindgen_ty_1>() - 8usize];
    ["Alignment of hv_partition_processor_xsave_features__bindgen_ty_1"]
        [::std::mem::align_of::<hv_partition_processor_xsave_features__bindgen_ty_1>() - 1usize];
};
impl hv_partition_processor_xsave_features__bindgen_ty_1 {
    #[inline]
    pub fn xsave_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsave_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xsave_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xsave_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xsaveopt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsaveopt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xsaveopt_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xsaveopt_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx2_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx2_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx2_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx2_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fma_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fma_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fma_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fma_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mpx_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mpx_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mpx_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_dq_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_dq_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_dq_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_dq_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_cd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_cd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_cd_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_cd_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_bw_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_bw_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_bw_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_bw_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_vl_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_vl_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_vl_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_vl_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xsave_comp_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsave_comp_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xsave_comp_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xsave_comp_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xsave_supervisor_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsave_supervisor_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xsave_supervisor_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xsave_supervisor_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xcr1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xcr1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xcr1_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xcr1_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_bitalg_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_bitalg_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_bitalg_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_bitalg_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_i_fma_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_i_fma_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_i_fma_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_i_fma_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_v_bmi_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_v_bmi_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_v_bmi_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_v_bmi_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_v_bmi2_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_v_bmi2_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_v_bmi2_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_v_bmi2_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_vnni_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_vnni_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_vnni_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_vnni_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gfni_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_gfni_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gfni_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_gfni_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vaes_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vaes_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vaes_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_vaes_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_v_popcntdq_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_v_popcntdq_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_v_popcntdq_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_v_popcntdq_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vpclmulqdq_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vpclmulqdq_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vpclmulqdq_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_vpclmulqdq_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_bf16_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_bf16_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_bf16_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_bf16_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_vp2_intersect_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_vp2_intersect_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_vp2_intersect_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_vp2_intersect_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx512_fp16_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx512_fp16_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx512_fp16_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx512_fp16_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xfd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xfd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xfd_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_xfd_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn amx_tile_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amx_tile_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn amx_tile_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_amx_tile_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn amx_bf16_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amx_bf16_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn amx_bf16_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_amx_bf16_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn amx_int8_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amx_int8_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn amx_int8_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_amx_int8_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_vnni_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_vnni_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_vnni_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_vnni_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_ifma_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_ifma_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_ifma_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_ifma_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_ne_convert_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_ne_convert_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_ne_convert_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_ne_convert_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_vnni_int8_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_vnni_int8_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_vnni_int8_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_vnni_int8_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx_vnni_int16_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_vnni_int16_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx_vnni_int16_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx_vnni_int16_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx10_1_256_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx10_1_256_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx10_1_256_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx10_1_256_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avx10_1_512_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx10_1_512_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avx10_1_512_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_avx10_1_512_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn amx_fp16_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amx_fp16_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn amx_fp16_support_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_amx_fp16_support_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 26u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                26u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xsave_support: __u64,
        xsaveopt_support: __u64,
        avx_support: __u64,
        avx2_support: __u64,
        fma_support: __u64,
        mpx_support: __u64,
        avx512_support: __u64,
        avx512_dq_support: __u64,
        avx512_cd_support: __u64,
        avx512_bw_support: __u64,
        avx512_vl_support: __u64,
        xsave_comp_support: __u64,
        xsave_supervisor_support: __u64,
        xcr1_support: __u64,
        avx512_bitalg_support: __u64,
        avx512_i_fma_support: __u64,
        avx512_v_bmi_support: __u64,
        avx512_v_bmi2_support: __u64,
        avx512_vnni_support: __u64,
        gfni_support: __u64,
        vaes_support: __u64,
        avx512_v_popcntdq_support: __u64,
        vpclmulqdq_support: __u64,
        avx512_bf16_support: __u64,
        avx512_vp2_intersect_support: __u64,
        avx512_fp16_support: __u64,
        xfd_support: __u64,
        amx_tile_support: __u64,
        amx_bf16_support: __u64,
        amx_int8_support: __u64,
        avx_vnni_support: __u64,
        avx_ifma_support: __u64,
        avx_ne_convert_support: __u64,
        avx_vnni_int8_support: __u64,
        avx_vnni_int16_support: __u64,
        avx10_1_256_support: __u64,
        avx10_1_512_support: __u64,
        amx_fp16_support: __u64,
        reserved1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xsave_support: u64 = unsafe { ::std::mem::transmute(xsave_support) };
            xsave_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xsaveopt_support: u64 = unsafe { ::std::mem::transmute(xsaveopt_support) };
            xsaveopt_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let avx_support: u64 = unsafe { ::std::mem::transmute(avx_support) };
            avx_support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let avx2_support: u64 = unsafe { ::std::mem::transmute(avx2_support) };
            avx2_support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fma_support: u64 = unsafe { ::std::mem::transmute(fma_support) };
            fma_support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mpx_support: u64 = unsafe { ::std::mem::transmute(mpx_support) };
            mpx_support as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let avx512_support: u64 = unsafe { ::std::mem::transmute(avx512_support) };
            avx512_support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let avx512_dq_support: u64 = unsafe { ::std::mem::transmute(avx512_dq_support) };
            avx512_dq_support as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let avx512_cd_support: u64 = unsafe { ::std::mem::transmute(avx512_cd_support) };
            avx512_cd_support as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let avx512_bw_support: u64 = unsafe { ::std::mem::transmute(avx512_bw_support) };
            avx512_bw_support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let avx512_vl_support: u64 = unsafe { ::std::mem::transmute(avx512_vl_support) };
            avx512_vl_support as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let xsave_comp_support: u64 = unsafe { ::std::mem::transmute(xsave_comp_support) };
            xsave_comp_support as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let xsave_supervisor_support: u64 =
                unsafe { ::std::mem::transmute(xsave_supervisor_support) };
            xsave_supervisor_support as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let xcr1_support: u64 = unsafe { ::std::mem::transmute(xcr1_support) };
            xcr1_support as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let avx512_bitalg_support: u64 =
                unsafe { ::std::mem::transmute(avx512_bitalg_support) };
            avx512_bitalg_support as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let avx512_i_fma_support: u64 = unsafe { ::std::mem::transmute(avx512_i_fma_support) };
            avx512_i_fma_support as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let avx512_v_bmi_support: u64 = unsafe { ::std::mem::transmute(avx512_v_bmi_support) };
            avx512_v_bmi_support as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let avx512_v_bmi2_support: u64 =
                unsafe { ::std::mem::transmute(avx512_v_bmi2_support) };
            avx512_v_bmi2_support as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let avx512_vnni_support: u64 = unsafe { ::std::mem::transmute(avx512_vnni_support) };
            avx512_vnni_support as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let gfni_support: u64 = unsafe { ::std::mem::transmute(gfni_support) };
            gfni_support as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let vaes_support: u64 = unsafe { ::std::mem::transmute(vaes_support) };
            vaes_support as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let avx512_v_popcntdq_support: u64 =
                unsafe { ::std::mem::transmute(avx512_v_popcntdq_support) };
            avx512_v_popcntdq_support as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let vpclmulqdq_support: u64 = unsafe { ::std::mem::transmute(vpclmulqdq_support) };
            vpclmulqdq_support as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let avx512_bf16_support: u64 = unsafe { ::std::mem::transmute(avx512_bf16_support) };
            avx512_bf16_support as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let avx512_vp2_intersect_support: u64 =
                unsafe { ::std::mem::transmute(avx512_vp2_intersect_support) };
            avx512_vp2_intersect_support as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let avx512_fp16_support: u64 = unsafe { ::std::mem::transmute(avx512_fp16_support) };
            avx512_fp16_support as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let xfd_support: u64 = unsafe { ::std::mem::transmute(xfd_support) };
            xfd_support as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let amx_tile_support: u64 = unsafe { ::std::mem::transmute(amx_tile_support) };
            amx_tile_support as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let amx_bf16_support: u64 = unsafe { ::std::mem::transmute(amx_bf16_support) };
            amx_bf16_support as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let amx_int8_support: u64 = unsafe { ::std::mem::transmute(amx_int8_support) };
            amx_int8_support as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let avx_vnni_support: u64 = unsafe { ::std::mem::transmute(avx_vnni_support) };
            avx_vnni_support as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let avx_ifma_support: u64 = unsafe { ::std::mem::transmute(avx_ifma_support) };
            avx_ifma_support as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let avx_ne_convert_support: u64 =
                unsafe { ::std::mem::transmute(avx_ne_convert_support) };
            avx_ne_convert_support as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let avx_vnni_int8_support: u64 =
                unsafe { ::std::mem::transmute(avx_vnni_int8_support) };
            avx_vnni_int8_support as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let avx_vnni_int16_support: u64 =
                unsafe { ::std::mem::transmute(avx_vnni_int16_support) };
            avx_vnni_int16_support as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let avx10_1_256_support: u64 = unsafe { ::std::mem::transmute(avx10_1_256_support) };
            avx10_1_256_support as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let avx10_1_512_support: u64 = unsafe { ::std::mem::transmute(avx10_1_512_support) };
            avx10_1_512_support as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let amx_fp16_support: u64 = unsafe { ::std::mem::transmute(amx_fp16_support) };
            amx_fp16_support as u64
        });
        __bindgen_bitfield_unit.set(38usize, 26u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_processor_xsave_features"]
        [::std::mem::size_of::<hv_partition_processor_xsave_features>() - 8usize];
    ["Alignment of hv_partition_processor_xsave_features"]
        [::std::mem::align_of::<hv_partition_processor_xsave_features>() - 8usize];
    ["Offset of field: hv_partition_processor_xsave_features::as_uint64"]
        [::std::mem::offset_of!(hv_partition_processor_xsave_features, as_uint64) - 0usize];
};
impl Default for hv_partition_processor_xsave_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_processor_features {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_partition_processor_features__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_processor_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_processor_features__bindgen_ty_1"]
        [::std::mem::size_of::<hv_partition_processor_features__bindgen_ty_1>() - 16usize];
    ["Alignment of hv_partition_processor_features__bindgen_ty_1"]
        [::std::mem::align_of::<hv_partition_processor_features__bindgen_ty_1>() - 1usize];
};
impl hv_partition_processor_features__bindgen_ty_1 {
    #[inline]
    pub fn asid16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_asid16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn asid16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_asid16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn t_gran16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_t_gran16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn t_gran16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_t_gran16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn t_gran64(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_t_gran64(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn t_gran64_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_t_gran64_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn haf(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_haf(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn haf_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_haf_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hdbs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hdbs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hdbs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_hdbs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pan(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pan(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pan_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pan_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn at_s1e1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_at_s1e1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn at_s1e1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_at_s1e1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uao(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_uao(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uao_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_uao_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn el0_aarch32(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_el0_aarch32(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn el0_aarch32_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_el0_aarch32_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fp_hp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fp_hp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fp_hp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fp_hp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn adv_simd(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_adv_simd(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn adv_simd_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_adv_simd_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn adv_simd_hp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_adv_simd_hp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn adv_simd_hp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_adv_simd_hp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gic_v3v4(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_gic_v3v4(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gic_v3v4_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_gic_v3v4_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gic_v4p1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_gic_v4p1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gic_v4p1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_gic_v4p1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ras(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ras(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ras_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ras_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pmu_v3(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pmu_v3(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pmu_v3_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pmu_v3_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pmu_v3_arm_v81(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pmu_v3_arm_v81(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pmu_v3_arm_v81_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pmu_v3_arm_v81_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pmu_v3_arm_v84(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pmu_v3_arm_v84(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pmu_v3_arm_v84_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pmu_v3_arm_v84_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pmu_v3_arm_v85(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pmu_v3_arm_v85(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pmu_v3_arm_v85_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pmu_v3_arm_v85_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aes(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_aes(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aes_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_aes_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn poly_mul(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_poly_mul(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn poly_mul_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_poly_mul_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sha1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sha1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sha1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sha1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sha256(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sha256(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sha256_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sha256_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sha512(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sha512(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sha512_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sha512_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn crc32(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_crc32(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn crc32_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_crc32_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn atomic(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_atomic(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn atomic_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_atomic_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rdm(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rdm_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rdm_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sha3(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sha3(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sha3_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sha3_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sm3(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sm3(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sm3_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sm3_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sm4(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sm4(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sm4_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sm4_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fhm(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fhm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fhm_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fhm_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dc_cvap(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dc_cvap(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dc_cvap_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dc_cvap_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dc_cvadp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dc_cvadp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dc_cvadp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dc_cvadp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apa_base(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_apa_base(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apa_base_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_apa_base_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apa_ep(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_apa_ep(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apa_ep_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_apa_ep_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apa_ep2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_apa_ep2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apa_ep2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_apa_ep2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apa_ep2_fp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_apa_ep2_fp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apa_ep2_fp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_apa_ep2_fp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn apa_ep2_fpc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_apa_ep2_fpc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apa_ep2_fpc_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_apa_ep2_fpc_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jscvt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_jscvt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jscvt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_jscvt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fcma(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fcma(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fcma_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fcma_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rcpc_v83(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rcpc_v83(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rcpc_v83_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rcpc_v83_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rcpc_v84(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rcpc_v84(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rcpc_v84_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rcpc_v84_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gpa(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_gpa(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gpa_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_gpa_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l1ip_pipt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l1ip_pipt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l1ip_pipt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l1ip_pipt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dz_permitted(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dz_permitted(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dz_permitted_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dz_permitted_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssbs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssbs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssbs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ssbs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssbs_rw(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssbs_rw(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssbs_rw_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ssbs_rw_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smccc_w1_supported(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smccc_w1_supported(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smccc_w1_supported_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_smccc_w1_supported_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smccc_w1_mitigated(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smccc_w1_mitigated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smccc_w1_mitigated_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                50usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_smccc_w1_mitigated_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smccc_w2_supported(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smccc_w2_supported(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smccc_w2_supported_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_smccc_w2_supported_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smccc_w2_mitigated(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smccc_w2_mitigated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smccc_w2_mitigated_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_smccc_w2_mitigated_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csv2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_csv2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csv2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_csv2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn csv3(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_csv3(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn csv3_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_csv3_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sb_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sb_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_idc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idc_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_idc_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dic(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dic(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dic_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dic_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tlbi_os(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tlbi_os(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tlbi_os_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tlbi_os_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tlbi_os_range(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tlbi_os_range(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tlbi_os_range_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tlbi_os_range_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flags_m(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_flags_m(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flags_m_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_flags_m_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flags_m2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_flags_m2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flags_m2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_flags_m2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bf16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bf16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bf16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_bf16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ebf16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ebf16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ebf16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ebf16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_bf16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_bf16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_bf16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_bf16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_ebf16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_ebf16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_ebf16_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                65usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_ebf16_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                65usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn i8mm(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_i8mm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn i8mm_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                66usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_i8mm_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                66usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_i8mm(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_i8mm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_i8mm_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                67usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_i8mm_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                67usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frintts(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_frintts(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frintts_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                68usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_frintts_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                68usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn specres(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(69usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_specres(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(69usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn specres_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                69usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_specres_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                69usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mtpmu(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(70usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mtpmu(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(70usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mtpmu_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                70usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mtpmu_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                70usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rpres(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rpres(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rpres_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                71usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rpres_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                71usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn exs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn exs_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                72usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_exs_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                72usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spec_sei(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(73usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_spec_sei(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(73usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spec_sei_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                73usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_spec_sei_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                73usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ets(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ets(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ets_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                74usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ets_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                74usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn afp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_afp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn afp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                75usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_afp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                75usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn iesb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_iesb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iesb_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                76usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_iesb_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                76usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rng(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rng(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rng_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                77usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rng_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                77usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lse2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lse2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lse2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                78usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_lse2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                78usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idst(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_idst(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idst_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                79usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_idst_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                79usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ras_v1p1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ras_v1p1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ras_v1p1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                80usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ras_v1p1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                80usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ras_frac_v1p1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ras_frac_v1p1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ras_frac_v1p1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                81usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ras_frac_v1p1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                81usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sel2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sel2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sel2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                82usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sel2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                82usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn amu_v1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amu_v1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn amu_v1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                83usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_amu_v1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                83usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn amu_v1p1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amu_v1p1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn amu_v1p1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                84usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_amu_v1p1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                84usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dit(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dit(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dit_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                85usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dit_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                85usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ccidx(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ccidx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ccidx_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                86usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ccidx_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                86usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fgt_for_intercepts(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fgt_for_intercepts(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fgt_for_intercepts_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                87usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_fgt_for_intercepts_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                87usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l1ip_vpipt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l1ip_vpipt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l1ip_vpipt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                88usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l1ip_vpipt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                88usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l1ip_vipt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l1ip_vipt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l1ip_vipt_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                89usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l1ip_vipt_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                89usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn debug_v8(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_debug_v8(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn debug_v8_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                90usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_debug_v8_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                90usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn debug_v8p2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_debug_v8p2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn debug_v8p2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                91usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_debug_v8p2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                91usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn debug_v8p4(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(92usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_debug_v8p4(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(92usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn debug_v8p4_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                92usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_debug_v8p4_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                92usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pmu_v3_arm_v87(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(93usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pmu_v3_arm_v87(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(93usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pmu_v3_arm_v87_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                93usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_pmu_v3_arm_v87_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                93usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn double_lock(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(94usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_double_lock(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(94usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn double_lock_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                94usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_double_lock_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                94usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clrbhb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(95usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clrbhb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(95usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clrbhb_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                95usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_clrbhb_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                95usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spe(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_spe(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spe_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_spe_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spe_v1p1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(97usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_spe_v1p1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(97usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spe_v1p1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                97usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_spe_v1p1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                97usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spe_v1p2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(98usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_spe_v1p2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(98usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spe_v1p2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                98usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_spe_v1p2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                98usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tt_cnp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(99usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tt_cnp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(99usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tt_cnp_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                99usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tt_cnp_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                99usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hpds(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(100usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hpds(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(100usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hpds_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                100usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_hpds_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                100usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(101usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(101usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                101usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                101usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_v2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(102usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_v2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(102usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_v2_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                102usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_v2_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                102usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_v2p1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(103usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_v2p1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(103usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_v2p1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                103usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_v2p1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                103usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spec_fpacc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_spec_fpacc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spec_fpacc_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                104usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_spec_fpacc_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                104usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_aes(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(105usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_aes(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(105usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_aes_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                105usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_aes_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                105usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_bit_perm(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(106usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_bit_perm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(106usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_bit_perm_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                106usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_bit_perm_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                106usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_sha3(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(107usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_sha3(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(107usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_sha3_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                107usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_sha3_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                107usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sve_sm4(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(108usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sve_sm4(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(108usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sve_sm4_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                108usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sve_sm4_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                108usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn e0_pd(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(109usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_e0_pd(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(109usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn e0_pd_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                109usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_e0_pd_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                109usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_bank1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(110usize, 18u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_bank1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(110usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_bank1_raw(this: *const Self) -> __u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                110usize,
                18u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_bank1_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                110usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        asid16: __u64,
        t_gran16: __u64,
        t_gran64: __u64,
        haf: __u64,
        hdbs: __u64,
        pan: __u64,
        at_s1e1: __u64,
        uao: __u64,
        el0_aarch32: __u64,
        fp: __u64,
        fp_hp: __u64,
        adv_simd: __u64,
        adv_simd_hp: __u64,
        gic_v3v4: __u64,
        gic_v4p1: __u64,
        ras: __u64,
        pmu_v3: __u64,
        pmu_v3_arm_v81: __u64,
        pmu_v3_arm_v84: __u64,
        pmu_v3_arm_v85: __u64,
        aes: __u64,
        poly_mul: __u64,
        sha1: __u64,
        sha256: __u64,
        sha512: __u64,
        crc32: __u64,
        atomic: __u64,
        rdm: __u64,
        sha3: __u64,
        sm3: __u64,
        sm4: __u64,
        dp: __u64,
        fhm: __u64,
        dc_cvap: __u64,
        dc_cvadp: __u64,
        apa_base: __u64,
        apa_ep: __u64,
        apa_ep2: __u64,
        apa_ep2_fp: __u64,
        apa_ep2_fpc: __u64,
        jscvt: __u64,
        fcma: __u64,
        rcpc_v83: __u64,
        rcpc_v84: __u64,
        gpa: __u64,
        l1ip_pipt: __u64,
        dz_permitted: __u64,
        ssbs: __u64,
        ssbs_rw: __u64,
        smccc_w1_supported: __u64,
        smccc_w1_mitigated: __u64,
        smccc_w2_supported: __u64,
        smccc_w2_mitigated: __u64,
        csv2: __u64,
        csv3: __u64,
        sb: __u64,
        idc: __u64,
        dic: __u64,
        tlbi_os: __u64,
        tlbi_os_range: __u64,
        flags_m: __u64,
        flags_m2: __u64,
        bf16: __u64,
        ebf16: __u64,
        sve_bf16: __u64,
        sve_ebf16: __u64,
        i8mm: __u64,
        sve_i8mm: __u64,
        frintts: __u64,
        specres: __u64,
        mtpmu: __u64,
        rpres: __u64,
        exs: __u64,
        spec_sei: __u64,
        ets: __u64,
        afp: __u64,
        iesb: __u64,
        rng: __u64,
        lse2: __u64,
        idst: __u64,
        ras_v1p1: __u64,
        ras_frac_v1p1: __u64,
        sel2: __u64,
        amu_v1: __u64,
        amu_v1p1: __u64,
        dit: __u64,
        ccidx: __u64,
        fgt_for_intercepts: __u64,
        l1ip_vpipt: __u64,
        l1ip_vipt: __u64,
        debug_v8: __u64,
        debug_v8p2: __u64,
        debug_v8p4: __u64,
        pmu_v3_arm_v87: __u64,
        double_lock: __u64,
        clrbhb: __u64,
        spe: __u64,
        spe_v1p1: __u64,
        spe_v1p2: __u64,
        tt_cnp: __u64,
        hpds: __u64,
        sve: __u64,
        sve_v2: __u64,
        sve_v2p1: __u64,
        spec_fpacc: __u64,
        sve_aes: __u64,
        sve_bit_perm: __u64,
        sve_sha3: __u64,
        sve_sm4: __u64,
        e0_pd: __u64,
        reserved_bank1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let asid16: u64 = unsafe { ::std::mem::transmute(asid16) };
            asid16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let t_gran16: u64 = unsafe { ::std::mem::transmute(t_gran16) };
            t_gran16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let t_gran64: u64 = unsafe { ::std::mem::transmute(t_gran64) };
            t_gran64 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let haf: u64 = unsafe { ::std::mem::transmute(haf) };
            haf as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hdbs: u64 = unsafe { ::std::mem::transmute(hdbs) };
            hdbs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pan: u64 = unsafe { ::std::mem::transmute(pan) };
            pan as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let at_s1e1: u64 = unsafe { ::std::mem::transmute(at_s1e1) };
            at_s1e1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let uao: u64 = unsafe { ::std::mem::transmute(uao) };
            uao as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let el0_aarch32: u64 = unsafe { ::std::mem::transmute(el0_aarch32) };
            el0_aarch32 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fp: u64 = unsafe { ::std::mem::transmute(fp) };
            fp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let fp_hp: u64 = unsafe { ::std::mem::transmute(fp_hp) };
            fp_hp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let adv_simd: u64 = unsafe { ::std::mem::transmute(adv_simd) };
            adv_simd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let adv_simd_hp: u64 = unsafe { ::std::mem::transmute(adv_simd_hp) };
            adv_simd_hp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let gic_v3v4: u64 = unsafe { ::std::mem::transmute(gic_v3v4) };
            gic_v3v4 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let gic_v4p1: u64 = unsafe { ::std::mem::transmute(gic_v4p1) };
            gic_v4p1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ras: u64 = unsafe { ::std::mem::transmute(ras) };
            ras as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pmu_v3: u64 = unsafe { ::std::mem::transmute(pmu_v3) };
            pmu_v3 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pmu_v3_arm_v81: u64 = unsafe { ::std::mem::transmute(pmu_v3_arm_v81) };
            pmu_v3_arm_v81 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pmu_v3_arm_v84: u64 = unsafe { ::std::mem::transmute(pmu_v3_arm_v84) };
            pmu_v3_arm_v84 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let pmu_v3_arm_v85: u64 = unsafe { ::std::mem::transmute(pmu_v3_arm_v85) };
            pmu_v3_arm_v85 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let aes: u64 = unsafe { ::std::mem::transmute(aes) };
            aes as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let poly_mul: u64 = unsafe { ::std::mem::transmute(poly_mul) };
            poly_mul as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sha1: u64 = unsafe { ::std::mem::transmute(sha1) };
            sha1 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sha256: u64 = unsafe { ::std::mem::transmute(sha256) };
            sha256 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sha512: u64 = unsafe { ::std::mem::transmute(sha512) };
            sha512 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let crc32: u64 = unsafe { ::std::mem::transmute(crc32) };
            crc32 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let atomic: u64 = unsafe { ::std::mem::transmute(atomic) };
            atomic as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rdm: u64 = unsafe { ::std::mem::transmute(rdm) };
            rdm as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sha3: u64 = unsafe { ::std::mem::transmute(sha3) };
            sha3 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sm3: u64 = unsafe { ::std::mem::transmute(sm3) };
            sm3 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let sm4: u64 = unsafe { ::std::mem::transmute(sm4) };
            sm4 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dp: u64 = unsafe { ::std::mem::transmute(dp) };
            dp as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let fhm: u64 = unsafe { ::std::mem::transmute(fhm) };
            fhm as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dc_cvap: u64 = unsafe { ::std::mem::transmute(dc_cvap) };
            dc_cvap as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let dc_cvadp: u64 = unsafe { ::std::mem::transmute(dc_cvadp) };
            dc_cvadp as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let apa_base: u64 = unsafe { ::std::mem::transmute(apa_base) };
            apa_base as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let apa_ep: u64 = unsafe { ::std::mem::transmute(apa_ep) };
            apa_ep as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let apa_ep2: u64 = unsafe { ::std::mem::transmute(apa_ep2) };
            apa_ep2 as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let apa_ep2_fp: u64 = unsafe { ::std::mem::transmute(apa_ep2_fp) };
            apa_ep2_fp as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let apa_ep2_fpc: u64 = unsafe { ::std::mem::transmute(apa_ep2_fpc) };
            apa_ep2_fpc as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let jscvt: u64 = unsafe { ::std::mem::transmute(jscvt) };
            jscvt as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let fcma: u64 = unsafe { ::std::mem::transmute(fcma) };
            fcma as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let rcpc_v83: u64 = unsafe { ::std::mem::transmute(rcpc_v83) };
            rcpc_v83 as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let rcpc_v84: u64 = unsafe { ::std::mem::transmute(rcpc_v84) };
            rcpc_v84 as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let gpa: u64 = unsafe { ::std::mem::transmute(gpa) };
            gpa as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let l1ip_pipt: u64 = unsafe { ::std::mem::transmute(l1ip_pipt) };
            l1ip_pipt as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let dz_permitted: u64 = unsafe { ::std::mem::transmute(dz_permitted) };
            dz_permitted as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let ssbs: u64 = unsafe { ::std::mem::transmute(ssbs) };
            ssbs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let ssbs_rw: u64 = unsafe { ::std::mem::transmute(ssbs_rw) };
            ssbs_rw as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let smccc_w1_supported: u64 = unsafe { ::std::mem::transmute(smccc_w1_supported) };
            smccc_w1_supported as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let smccc_w1_mitigated: u64 = unsafe { ::std::mem::transmute(smccc_w1_mitigated) };
            smccc_w1_mitigated as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let smccc_w2_supported: u64 = unsafe { ::std::mem::transmute(smccc_w2_supported) };
            smccc_w2_supported as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let smccc_w2_mitigated: u64 = unsafe { ::std::mem::transmute(smccc_w2_mitigated) };
            smccc_w2_mitigated as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let csv2: u64 = unsafe { ::std::mem::transmute(csv2) };
            csv2 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let csv3: u64 = unsafe { ::std::mem::transmute(csv3) };
            csv3 as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let sb: u64 = unsafe { ::std::mem::transmute(sb) };
            sb as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let idc: u64 = unsafe { ::std::mem::transmute(idc) };
            idc as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let dic: u64 = unsafe { ::std::mem::transmute(dic) };
            dic as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let tlbi_os: u64 = unsafe { ::std::mem::transmute(tlbi_os) };
            tlbi_os as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let tlbi_os_range: u64 = unsafe { ::std::mem::transmute(tlbi_os_range) };
            tlbi_os_range as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let flags_m: u64 = unsafe { ::std::mem::transmute(flags_m) };
            flags_m as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let flags_m2: u64 = unsafe { ::std::mem::transmute(flags_m2) };
            flags_m2 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let bf16: u64 = unsafe { ::std::mem::transmute(bf16) };
            bf16 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ebf16: u64 = unsafe { ::std::mem::transmute(ebf16) };
            ebf16 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let sve_bf16: u64 = unsafe { ::std::mem::transmute(sve_bf16) };
            sve_bf16 as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let sve_ebf16: u64 = unsafe { ::std::mem::transmute(sve_ebf16) };
            sve_ebf16 as u64
        });
        __bindgen_bitfield_unit.set(66usize, 1u8, {
            let i8mm: u64 = unsafe { ::std::mem::transmute(i8mm) };
            i8mm as u64
        });
        __bindgen_bitfield_unit.set(67usize, 1u8, {
            let sve_i8mm: u64 = unsafe { ::std::mem::transmute(sve_i8mm) };
            sve_i8mm as u64
        });
        __bindgen_bitfield_unit.set(68usize, 1u8, {
            let frintts: u64 = unsafe { ::std::mem::transmute(frintts) };
            frintts as u64
        });
        __bindgen_bitfield_unit.set(69usize, 1u8, {
            let specres: u64 = unsafe { ::std::mem::transmute(specres) };
            specres as u64
        });
        __bindgen_bitfield_unit.set(70usize, 1u8, {
            let mtpmu: u64 = unsafe { ::std::mem::transmute(mtpmu) };
            mtpmu as u64
        });
        __bindgen_bitfield_unit.set(71usize, 1u8, {
            let rpres: u64 = unsafe { ::std::mem::transmute(rpres) };
            rpres as u64
        });
        __bindgen_bitfield_unit.set(72usize, 1u8, {
            let exs: u64 = unsafe { ::std::mem::transmute(exs) };
            exs as u64
        });
        __bindgen_bitfield_unit.set(73usize, 1u8, {
            let spec_sei: u64 = unsafe { ::std::mem::transmute(spec_sei) };
            spec_sei as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let ets: u64 = unsafe { ::std::mem::transmute(ets) };
            ets as u64
        });
        __bindgen_bitfield_unit.set(75usize, 1u8, {
            let afp: u64 = unsafe { ::std::mem::transmute(afp) };
            afp as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let iesb: u64 = unsafe { ::std::mem::transmute(iesb) };
            iesb as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let rng: u64 = unsafe { ::std::mem::transmute(rng) };
            rng as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let lse2: u64 = unsafe { ::std::mem::transmute(lse2) };
            lse2 as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let idst: u64 = unsafe { ::std::mem::transmute(idst) };
            idst as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let ras_v1p1: u64 = unsafe { ::std::mem::transmute(ras_v1p1) };
            ras_v1p1 as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let ras_frac_v1p1: u64 = unsafe { ::std::mem::transmute(ras_frac_v1p1) };
            ras_frac_v1p1 as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let sel2: u64 = unsafe { ::std::mem::transmute(sel2) };
            sel2 as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let amu_v1: u64 = unsafe { ::std::mem::transmute(amu_v1) };
            amu_v1 as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let amu_v1p1: u64 = unsafe { ::std::mem::transmute(amu_v1p1) };
            amu_v1p1 as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let dit: u64 = unsafe { ::std::mem::transmute(dit) };
            dit as u64
        });
        __bindgen_bitfield_unit.set(86usize, 1u8, {
            let ccidx: u64 = unsafe { ::std::mem::transmute(ccidx) };
            ccidx as u64
        });
        __bindgen_bitfield_unit.set(87usize, 1u8, {
            let fgt_for_intercepts: u64 = unsafe { ::std::mem::transmute(fgt_for_intercepts) };
            fgt_for_intercepts as u64
        });
        __bindgen_bitfield_unit.set(88usize, 1u8, {
            let l1ip_vpipt: u64 = unsafe { ::std::mem::transmute(l1ip_vpipt) };
            l1ip_vpipt as u64
        });
        __bindgen_bitfield_unit.set(89usize, 1u8, {
            let l1ip_vipt: u64 = unsafe { ::std::mem::transmute(l1ip_vipt) };
            l1ip_vipt as u64
        });
        __bindgen_bitfield_unit.set(90usize, 1u8, {
            let debug_v8: u64 = unsafe { ::std::mem::transmute(debug_v8) };
            debug_v8 as u64
        });
        __bindgen_bitfield_unit.set(91usize, 1u8, {
            let debug_v8p2: u64 = unsafe { ::std::mem::transmute(debug_v8p2) };
            debug_v8p2 as u64
        });
        __bindgen_bitfield_unit.set(92usize, 1u8, {
            let debug_v8p4: u64 = unsafe { ::std::mem::transmute(debug_v8p4) };
            debug_v8p4 as u64
        });
        __bindgen_bitfield_unit.set(93usize, 1u8, {
            let pmu_v3_arm_v87: u64 = unsafe { ::std::mem::transmute(pmu_v3_arm_v87) };
            pmu_v3_arm_v87 as u64
        });
        __bindgen_bitfield_unit.set(94usize, 1u8, {
            let double_lock: u64 = unsafe { ::std::mem::transmute(double_lock) };
            double_lock as u64
        });
        __bindgen_bitfield_unit.set(95usize, 1u8, {
            let clrbhb: u64 = unsafe { ::std::mem::transmute(clrbhb) };
            clrbhb as u64
        });
        __bindgen_bitfield_unit.set(96usize, 1u8, {
            let spe: u64 = unsafe { ::std::mem::transmute(spe) };
            spe as u64
        });
        __bindgen_bitfield_unit.set(97usize, 1u8, {
            let spe_v1p1: u64 = unsafe { ::std::mem::transmute(spe_v1p1) };
            spe_v1p1 as u64
        });
        __bindgen_bitfield_unit.set(98usize, 1u8, {
            let spe_v1p2: u64 = unsafe { ::std::mem::transmute(spe_v1p2) };
            spe_v1p2 as u64
        });
        __bindgen_bitfield_unit.set(99usize, 1u8, {
            let tt_cnp: u64 = unsafe { ::std::mem::transmute(tt_cnp) };
            tt_cnp as u64
        });
        __bindgen_bitfield_unit.set(100usize, 1u8, {
            let hpds: u64 = unsafe { ::std::mem::transmute(hpds) };
            hpds as u64
        });
        __bindgen_bitfield_unit.set(101usize, 1u8, {
            let sve: u64 = unsafe { ::std::mem::transmute(sve) };
            sve as u64
        });
        __bindgen_bitfield_unit.set(102usize, 1u8, {
            let sve_v2: u64 = unsafe { ::std::mem::transmute(sve_v2) };
            sve_v2 as u64
        });
        __bindgen_bitfield_unit.set(103usize, 1u8, {
            let sve_v2p1: u64 = unsafe { ::std::mem::transmute(sve_v2p1) };
            sve_v2p1 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 1u8, {
            let spec_fpacc: u64 = unsafe { ::std::mem::transmute(spec_fpacc) };
            spec_fpacc as u64
        });
        __bindgen_bitfield_unit.set(105usize, 1u8, {
            let sve_aes: u64 = unsafe { ::std::mem::transmute(sve_aes) };
            sve_aes as u64
        });
        __bindgen_bitfield_unit.set(106usize, 1u8, {
            let sve_bit_perm: u64 = unsafe { ::std::mem::transmute(sve_bit_perm) };
            sve_bit_perm as u64
        });
        __bindgen_bitfield_unit.set(107usize, 1u8, {
            let sve_sha3: u64 = unsafe { ::std::mem::transmute(sve_sha3) };
            sve_sha3 as u64
        });
        __bindgen_bitfield_unit.set(108usize, 1u8, {
            let sve_sm4: u64 = unsafe { ::std::mem::transmute(sve_sm4) };
            sve_sm4 as u64
        });
        __bindgen_bitfield_unit.set(109usize, 1u8, {
            let e0_pd: u64 = unsafe { ::std::mem::transmute(e0_pd) };
            e0_pd as u64
        });
        __bindgen_bitfield_unit.set(110usize, 18u8, {
            let reserved_bank1: u64 = unsafe { ::std::mem::transmute(reserved_bank1) };
            reserved_bank1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hv_partition_processor_features"]
        [::std::mem::size_of::<hv_partition_processor_features>() - 16usize];
    ["Alignment of hv_partition_processor_features"]
        [::std::mem::align_of::<hv_partition_processor_features>() - 8usize];
    ["Offset of field: hv_partition_processor_features::as_uint64"]
        [::std::mem::offset_of!(hv_partition_processor_features, as_uint64) - 0usize];
};
impl Default for hv_partition_processor_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_vp_registers {
    pub count: ::std::os::raw::c_int,
    pub regs: *mut hv_register_assoc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_vp_registers"][::std::mem::size_of::<mshv_vp_registers>() - 16usize];
    ["Alignment of mshv_vp_registers"][::std::mem::align_of::<mshv_vp_registers>() - 8usize];
    ["Offset of field: mshv_vp_registers::count"]
        [::std::mem::offset_of!(mshv_vp_registers, count) - 0usize];
    ["Offset of field: mshv_vp_registers::regs"]
        [::std::mem::offset_of!(mshv_vp_registers, regs) - 8usize];
};
impl Default for mshv_vp_registers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_install_intercept {
    pub access_type_mask: __u32,
    pub intercept_type: hv_intercept_type,
    pub intercept_parameter: hv_intercept_parameters,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_install_intercept"][::std::mem::size_of::<mshv_install_intercept>() - 16usize];
    ["Alignment of mshv_install_intercept"]
        [::std::mem::align_of::<mshv_install_intercept>() - 8usize];
    ["Offset of field: mshv_install_intercept::access_type_mask"]
        [::std::mem::offset_of!(mshv_install_intercept, access_type_mask) - 0usize];
    ["Offset of field: mshv_install_intercept::intercept_type"]
        [::std::mem::offset_of!(mshv_install_intercept, intercept_type) - 4usize];
    ["Offset of field: mshv_install_intercept::intercept_parameter"]
        [::std::mem::offset_of!(mshv_install_intercept, intercept_parameter) - 8usize];
};
impl Default for mshv_install_intercept {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_assert_interrupt {
    pub control: hv_interrupt_control,
    pub dest_addr: __u64,
    pub vector: __u32,
    pub rsvd: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_assert_interrupt"][::std::mem::size_of::<mshv_assert_interrupt>() - 24usize];
    ["Alignment of mshv_assert_interrupt"]
        [::std::mem::align_of::<mshv_assert_interrupt>() - 8usize];
    ["Offset of field: mshv_assert_interrupt::control"]
        [::std::mem::offset_of!(mshv_assert_interrupt, control) - 0usize];
    ["Offset of field: mshv_assert_interrupt::dest_addr"]
        [::std::mem::offset_of!(mshv_assert_interrupt, dest_addr) - 8usize];
    ["Offset of field: mshv_assert_interrupt::vector"]
        [::std::mem::offset_of!(mshv_assert_interrupt, vector) - 16usize];
    ["Offset of field: mshv_assert_interrupt::rsvd"]
        [::std::mem::offset_of!(mshv_assert_interrupt, rsvd) - 20usize];
};
impl Default for mshv_assert_interrupt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_translate_gva {
    pub gva: __u64,
    pub flags: __u64,
    pub result: *mut hv_translate_gva_result,
    pub gpa: *mut __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_translate_gva"][::std::mem::size_of::<mshv_translate_gva>() - 32usize];
    ["Alignment of mshv_translate_gva"][::std::mem::align_of::<mshv_translate_gva>() - 8usize];
    ["Offset of field: mshv_translate_gva::gva"]
        [::std::mem::offset_of!(mshv_translate_gva, gva) - 0usize];
    ["Offset of field: mshv_translate_gva::flags"]
        [::std::mem::offset_of!(mshv_translate_gva, flags) - 8usize];
    ["Offset of field: mshv_translate_gva::result"]
        [::std::mem::offset_of!(mshv_translate_gva, result) - 16usize];
    ["Offset of field: mshv_translate_gva::gpa"]
        [::std::mem::offset_of!(mshv_translate_gva, gpa) - 24usize];
};
impl Default for mshv_translate_gva {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_signal_event_direct {
    pub vp: __u32,
    pub vtl: __u8,
    pub sint: __u8,
    pub flag: __u16,
    pub newly_signaled: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_signal_event_direct"]
        [::std::mem::size_of::<mshv_signal_event_direct>() - 12usize];
    ["Alignment of mshv_signal_event_direct"]
        [::std::mem::align_of::<mshv_signal_event_direct>() - 4usize];
    ["Offset of field: mshv_signal_event_direct::vp"]
        [::std::mem::offset_of!(mshv_signal_event_direct, vp) - 0usize];
    ["Offset of field: mshv_signal_event_direct::vtl"]
        [::std::mem::offset_of!(mshv_signal_event_direct, vtl) - 4usize];
    ["Offset of field: mshv_signal_event_direct::sint"]
        [::std::mem::offset_of!(mshv_signal_event_direct, sint) - 5usize];
    ["Offset of field: mshv_signal_event_direct::flag"]
        [::std::mem::offset_of!(mshv_signal_event_direct, flag) - 6usize];
    ["Offset of field: mshv_signal_event_direct::newly_signaled"]
        [::std::mem::offset_of!(mshv_signal_event_direct, newly_signaled) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_post_message_direct {
    pub vp: __u32,
    pub vtl: __u8,
    pub sint: __u8,
    pub length: __u16,
    pub message: *const __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_post_message_direct"]
        [::std::mem::size_of::<mshv_post_message_direct>() - 16usize];
    ["Alignment of mshv_post_message_direct"]
        [::std::mem::align_of::<mshv_post_message_direct>() - 8usize];
    ["Offset of field: mshv_post_message_direct::vp"]
        [::std::mem::offset_of!(mshv_post_message_direct, vp) - 0usize];
    ["Offset of field: mshv_post_message_direct::vtl"]
        [::std::mem::offset_of!(mshv_post_message_direct, vtl) - 4usize];
    ["Offset of field: mshv_post_message_direct::sint"]
        [::std::mem::offset_of!(mshv_post_message_direct, sint) - 5usize];
    ["Offset of field: mshv_post_message_direct::length"]
        [::std::mem::offset_of!(mshv_post_message_direct, length) - 6usize];
    ["Offset of field: mshv_post_message_direct::message"]
        [::std::mem::offset_of!(mshv_post_message_direct, message) - 8usize];
};
impl Default for mshv_post_message_direct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_register_deliverabilty_notifications {
    pub vp: __u32,
    pub pad: __u32,
    pub flag: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_register_deliverabilty_notifications"]
        [::std::mem::size_of::<mshv_register_deliverabilty_notifications>() - 16usize];
    ["Alignment of mshv_register_deliverabilty_notifications"]
        [::std::mem::align_of::<mshv_register_deliverabilty_notifications>() - 8usize];
    ["Offset of field: mshv_register_deliverabilty_notifications::vp"]
        [::std::mem::offset_of!(mshv_register_deliverabilty_notifications, vp) - 0usize];
    ["Offset of field: mshv_register_deliverabilty_notifications::pad"]
        [::std::mem::offset_of!(mshv_register_deliverabilty_notifications, pad) - 4usize];
    ["Offset of field: mshv_register_deliverabilty_notifications::flag"]
        [::std::mem::offset_of!(mshv_register_deliverabilty_notifications, flag) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_get_vp_cpuid_values {
    pub function: __u32,
    pub index: __u32,
    pub xfem: __u64,
    pub xss: __u64,
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_get_vp_cpuid_values"]
        [::std::mem::size_of::<mshv_get_vp_cpuid_values>() - 40usize];
    ["Alignment of mshv_get_vp_cpuid_values"]
        [::std::mem::align_of::<mshv_get_vp_cpuid_values>() - 8usize];
    ["Offset of field: mshv_get_vp_cpuid_values::function"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, function) - 0usize];
    ["Offset of field: mshv_get_vp_cpuid_values::index"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, index) - 4usize];
    ["Offset of field: mshv_get_vp_cpuid_values::xfem"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, xfem) - 8usize];
    ["Offset of field: mshv_get_vp_cpuid_values::xss"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, xss) - 16usize];
    ["Offset of field: mshv_get_vp_cpuid_values::eax"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, eax) - 24usize];
    ["Offset of field: mshv_get_vp_cpuid_values::ebx"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, ebx) - 28usize];
    ["Offset of field: mshv_get_vp_cpuid_values::ecx"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, ecx) - 32usize];
    ["Offset of field: mshv_get_vp_cpuid_values::edx"]
        [::std::mem::offset_of!(mshv_get_vp_cpuid_values, edx) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_read_write_gpa {
    pub base_gpa: __u64,
    pub byte_count: __u32,
    pub flags: __u32,
    pub data: [__u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_read_write_gpa"][::std::mem::size_of::<mshv_read_write_gpa>() - 32usize];
    ["Alignment of mshv_read_write_gpa"][::std::mem::align_of::<mshv_read_write_gpa>() - 8usize];
    ["Offset of field: mshv_read_write_gpa::base_gpa"]
        [::std::mem::offset_of!(mshv_read_write_gpa, base_gpa) - 0usize];
    ["Offset of field: mshv_read_write_gpa::byte_count"]
        [::std::mem::offset_of!(mshv_read_write_gpa, byte_count) - 8usize];
    ["Offset of field: mshv_read_write_gpa::flags"]
        [::std::mem::offset_of!(mshv_read_write_gpa, flags) - 12usize];
    ["Offset of field: mshv_read_write_gpa::data"]
        [::std::mem::offset_of!(mshv_read_write_gpa, data) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_sev_snp_ap_create {
    pub vp_id: __u64,
    pub vmsa_gpa: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_sev_snp_ap_create"][::std::mem::size_of::<mshv_sev_snp_ap_create>() - 16usize];
    ["Alignment of mshv_sev_snp_ap_create"]
        [::std::mem::align_of::<mshv_sev_snp_ap_create>() - 8usize];
    ["Offset of field: mshv_sev_snp_ap_create::vp_id"]
        [::std::mem::offset_of!(mshv_sev_snp_ap_create, vp_id) - 0usize];
    ["Offset of field: mshv_sev_snp_ap_create::vmsa_gpa"]
        [::std::mem::offset_of!(mshv_sev_snp_ap_create, vmsa_gpa) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_issue_psp_guest_request {
    pub req_gpa: __u64,
    pub rsp_gpa: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_issue_psp_guest_request"]
        [::std::mem::size_of::<mshv_issue_psp_guest_request>() - 16usize];
    ["Alignment of mshv_issue_psp_guest_request"]
        [::std::mem::align_of::<mshv_issue_psp_guest_request>() - 8usize];
    ["Offset of field: mshv_issue_psp_guest_request::req_gpa"]
        [::std::mem::offset_of!(mshv_issue_psp_guest_request, req_gpa) - 0usize];
    ["Offset of field: mshv_issue_psp_guest_request::rsp_gpa"]
        [::std::mem::offset_of!(mshv_issue_psp_guest_request, rsp_gpa) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_complete_isolated_import {
    pub import_data: hv_partition_complete_isolated_import_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_complete_isolated_import"]
        [::std::mem::size_of::<mshv_complete_isolated_import>() - 3334usize];
    ["Alignment of mshv_complete_isolated_import"]
        [::std::mem::align_of::<mshv_complete_isolated_import>() - 1usize];
    ["Offset of field: mshv_complete_isolated_import::import_data"]
        [::std::mem::offset_of!(mshv_complete_isolated_import, import_data) - 0usize];
};
impl Default for mshv_complete_isolated_import {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSHV_VTL_CAP_BIT_REGISTER_PAGE: _bindgen_ty_1 = 0;
pub const MSHV_VTL_CAP_BIT_RETURN_ACTION: _bindgen_ty_1 = 1;
pub const MSHV_VTL_CAP_BIT_DR6_SHARED: _bindgen_ty_1 = 2;
pub const MSHV_VTL_CAP_BIT_COUNT: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_vtl_capabilities {
    pub bits: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_vtl_capabilities"][::std::mem::size_of::<mshv_vtl_capabilities>() - 8usize];
    ["Alignment of mshv_vtl_capabilities"]
        [::std::mem::align_of::<mshv_vtl_capabilities>() - 8usize];
    ["Offset of field: mshv_vtl_capabilities::bits"]
        [::std::mem::offset_of!(mshv_vtl_capabilities, bits) - 0usize];
};
pub const MSHV_PT_BIT_LAPIC: _bindgen_ty_2 = 0;
pub const MSHV_PT_BIT_X2APIC: _bindgen_ty_2 = 1;
pub const MSHV_PT_BIT_GPA_SUPER_PAGES: _bindgen_ty_2 = 2;
pub const MSHV_PT_BIT_CPU_AND_XSAVE_FEATURES: _bindgen_ty_2 = 3;
pub const MSHV_PT_BIT_COUNT: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const MSHV_PT_ISOLATION_NONE: _bindgen_ty_3 = 0;
pub const MSHV_PT_ISOLATION_SNP: _bindgen_ty_3 = 1;
pub const MSHV_PT_ISOLATION_COUNT: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_create_partition {
    pub pt_flags: __u64,
    pub pt_isolation: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_create_partition"][::std::mem::size_of::<mshv_create_partition>() - 16usize];
    ["Alignment of mshv_create_partition"]
        [::std::mem::align_of::<mshv_create_partition>() - 8usize];
    ["Offset of field: mshv_create_partition::pt_flags"]
        [::std::mem::offset_of!(mshv_create_partition, pt_flags) - 0usize];
    ["Offset of field: mshv_create_partition::pt_isolation"]
        [::std::mem::offset_of!(mshv_create_partition, pt_isolation) - 8usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_create_partition_v2 {
    pub pt_flags: __u64,
    pub pt_isolation: __u64,
    pub pt_num_cpu_fbanks: __u16,
    pub pt_rsvd: [__u8; 6usize],
    pub pt_cpu_fbanks: [__u64; 2usize],
    pub pt_rsvd1: [__u64; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_create_partition_v2"]
        [::std::mem::size_of::<mshv_create_partition_v2>() - 56usize];
    ["Alignment of mshv_create_partition_v2"]
        [::std::mem::align_of::<mshv_create_partition_v2>() - 1usize];
    ["Offset of field: mshv_create_partition_v2::pt_flags"]
        [::std::mem::offset_of!(mshv_create_partition_v2, pt_flags) - 0usize];
    ["Offset of field: mshv_create_partition_v2::pt_isolation"]
        [::std::mem::offset_of!(mshv_create_partition_v2, pt_isolation) - 8usize];
    ["Offset of field: mshv_create_partition_v2::pt_num_cpu_fbanks"]
        [::std::mem::offset_of!(mshv_create_partition_v2, pt_num_cpu_fbanks) - 16usize];
    ["Offset of field: mshv_create_partition_v2::pt_rsvd"]
        [::std::mem::offset_of!(mshv_create_partition_v2, pt_rsvd) - 18usize];
    ["Offset of field: mshv_create_partition_v2::pt_cpu_fbanks"]
        [::std::mem::offset_of!(mshv_create_partition_v2, pt_cpu_fbanks) - 24usize];
    ["Offset of field: mshv_create_partition_v2::pt_rsvd1"]
        [::std::mem::offset_of!(mshv_create_partition_v2, pt_rsvd1) - 40usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_partition_property {
    pub property_code: __u64,
    pub property_value: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_partition_property"][::std::mem::size_of::<mshv_partition_property>() - 16usize];
    ["Alignment of mshv_partition_property"]
        [::std::mem::align_of::<mshv_partition_property>() - 8usize];
    ["Offset of field: mshv_partition_property::property_code"]
        [::std::mem::offset_of!(mshv_partition_property, property_code) - 0usize];
    ["Offset of field: mshv_partition_property::property_value"]
        [::std::mem::offset_of!(mshv_partition_property, property_value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_create_vp {
    pub vp_index: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_create_vp"][::std::mem::size_of::<mshv_create_vp>() - 4usize];
    ["Alignment of mshv_create_vp"][::std::mem::align_of::<mshv_create_vp>() - 4usize];
    ["Offset of field: mshv_create_vp::vp_index"]
        [::std::mem::offset_of!(mshv_create_vp, vp_index) - 0usize];
};
pub const MSHV_SET_MEM_BIT_WRITABLE: _bindgen_ty_4 = 0;
pub const MSHV_SET_MEM_BIT_EXECUTABLE: _bindgen_ty_4 = 1;
pub const MSHV_SET_MEM_BIT_UNMAP: _bindgen_ty_4 = 2;
pub const MSHV_SET_MEM_BIT_COUNT: _bindgen_ty_4 = 3;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_user_mem_region {
    pub size: __u64,
    pub guest_pfn: __u64,
    pub userspace_addr: __u64,
    pub flags: __u8,
    pub rsvd: [__u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_user_mem_region"][::std::mem::size_of::<mshv_user_mem_region>() - 32usize];
    ["Alignment of mshv_user_mem_region"][::std::mem::align_of::<mshv_user_mem_region>() - 8usize];
    ["Offset of field: mshv_user_mem_region::size"]
        [::std::mem::offset_of!(mshv_user_mem_region, size) - 0usize];
    ["Offset of field: mshv_user_mem_region::guest_pfn"]
        [::std::mem::offset_of!(mshv_user_mem_region, guest_pfn) - 8usize];
    ["Offset of field: mshv_user_mem_region::userspace_addr"]
        [::std::mem::offset_of!(mshv_user_mem_region, userspace_addr) - 16usize];
    ["Offset of field: mshv_user_mem_region::flags"]
        [::std::mem::offset_of!(mshv_user_mem_region, flags) - 24usize];
    ["Offset of field: mshv_user_mem_region::rsvd"]
        [::std::mem::offset_of!(mshv_user_mem_region, rsvd) - 25usize];
};
pub const MSHV_IRQFD_BIT_DEASSIGN: _bindgen_ty_5 = 0;
pub const MSHV_IRQFD_BIT_RESAMPLE: _bindgen_ty_5 = 1;
pub const MSHV_IRQFD_BIT_COUNT: _bindgen_ty_5 = 2;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_user_irqfd {
    pub fd: __s32,
    pub resamplefd: __s32,
    pub gsi: __u32,
    pub flags: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_user_irqfd"][::std::mem::size_of::<mshv_user_irqfd>() - 16usize];
    ["Alignment of mshv_user_irqfd"][::std::mem::align_of::<mshv_user_irqfd>() - 4usize];
    ["Offset of field: mshv_user_irqfd::fd"][::std::mem::offset_of!(mshv_user_irqfd, fd) - 0usize];
    ["Offset of field: mshv_user_irqfd::resamplefd"]
        [::std::mem::offset_of!(mshv_user_irqfd, resamplefd) - 4usize];
    ["Offset of field: mshv_user_irqfd::gsi"]
        [::std::mem::offset_of!(mshv_user_irqfd, gsi) - 8usize];
    ["Offset of field: mshv_user_irqfd::flags"]
        [::std::mem::offset_of!(mshv_user_irqfd, flags) - 12usize];
};
pub const MSHV_IOEVENTFD_BIT_DATAMATCH: _bindgen_ty_6 = 0;
pub const MSHV_IOEVENTFD_BIT_PIO: _bindgen_ty_6 = 1;
pub const MSHV_IOEVENTFD_BIT_DEASSIGN: _bindgen_ty_6 = 2;
pub const MSHV_IOEVENTFD_BIT_COUNT: _bindgen_ty_6 = 3;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_user_ioeventfd {
    pub datamatch: __u64,
    pub addr: __u64,
    pub len: __u32,
    pub fd: __s32,
    pub flags: __u32,
    pub rsvd: [__u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_user_ioeventfd"][::std::mem::size_of::<mshv_user_ioeventfd>() - 32usize];
    ["Alignment of mshv_user_ioeventfd"][::std::mem::align_of::<mshv_user_ioeventfd>() - 8usize];
    ["Offset of field: mshv_user_ioeventfd::datamatch"]
        [::std::mem::offset_of!(mshv_user_ioeventfd, datamatch) - 0usize];
    ["Offset of field: mshv_user_ioeventfd::addr"]
        [::std::mem::offset_of!(mshv_user_ioeventfd, addr) - 8usize];
    ["Offset of field: mshv_user_ioeventfd::len"]
        [::std::mem::offset_of!(mshv_user_ioeventfd, len) - 16usize];
    ["Offset of field: mshv_user_ioeventfd::fd"]
        [::std::mem::offset_of!(mshv_user_ioeventfd, fd) - 20usize];
    ["Offset of field: mshv_user_ioeventfd::flags"]
        [::std::mem::offset_of!(mshv_user_ioeventfd, flags) - 24usize];
    ["Offset of field: mshv_user_ioeventfd::rsvd"]
        [::std::mem::offset_of!(mshv_user_ioeventfd, rsvd) - 28usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_user_irq_entry {
    pub gsi: __u32,
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_user_irq_entry"][::std::mem::size_of::<mshv_user_irq_entry>() - 16usize];
    ["Alignment of mshv_user_irq_entry"][::std::mem::align_of::<mshv_user_irq_entry>() - 4usize];
    ["Offset of field: mshv_user_irq_entry::gsi"]
        [::std::mem::offset_of!(mshv_user_irq_entry, gsi) - 0usize];
    ["Offset of field: mshv_user_irq_entry::address_lo"]
        [::std::mem::offset_of!(mshv_user_irq_entry, address_lo) - 4usize];
    ["Offset of field: mshv_user_irq_entry::address_hi"]
        [::std::mem::offset_of!(mshv_user_irq_entry, address_hi) - 8usize];
    ["Offset of field: mshv_user_irq_entry::data"]
        [::std::mem::offset_of!(mshv_user_irq_entry, data) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default)]
pub struct mshv_user_irq_table {
    pub nr: __u32,
    pub rsvd: __u32,
    pub entries: __IncompleteArrayField<mshv_user_irq_entry>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_user_irq_table"][::std::mem::size_of::<mshv_user_irq_table>() - 8usize];
    ["Alignment of mshv_user_irq_table"][::std::mem::align_of::<mshv_user_irq_table>() - 4usize];
    ["Offset of field: mshv_user_irq_table::nr"]
        [::std::mem::offset_of!(mshv_user_irq_table, nr) - 0usize];
    ["Offset of field: mshv_user_irq_table::rsvd"]
        [::std::mem::offset_of!(mshv_user_irq_table, rsvd) - 4usize];
    ["Offset of field: mshv_user_irq_table::entries"]
        [::std::mem::offset_of!(mshv_user_irq_table, entries) - 8usize];
};
pub const MSHV_GPAP_ACCESS_TYPE_ACCESSED: _bindgen_ty_7 = 0;
pub const MSHV_GPAP_ACCESS_TYPE_DIRTY: _bindgen_ty_7 = 1;
pub const MSHV_GPAP_ACCESS_TYPE_COUNT: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const MSHV_GPAP_ACCESS_OP_NOOP: _bindgen_ty_8 = 0;
pub const MSHV_GPAP_ACCESS_OP_CLEAR: _bindgen_ty_8 = 1;
pub const MSHV_GPAP_ACCESS_OP_SET: _bindgen_ty_8 = 2;
pub const MSHV_GPAP_ACCESS_OP_COUNT: _bindgen_ty_8 = 3;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_gpap_access_bitmap {
    pub access_type: __u8,
    pub access_op: __u8,
    pub rsvd: [__u8; 6usize],
    pub page_count: __u64,
    pub gpap_base: __u64,
    pub bitmap_ptr: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_gpap_access_bitmap"][::std::mem::size_of::<mshv_gpap_access_bitmap>() - 32usize];
    ["Alignment of mshv_gpap_access_bitmap"]
        [::std::mem::align_of::<mshv_gpap_access_bitmap>() - 8usize];
    ["Offset of field: mshv_gpap_access_bitmap::access_type"]
        [::std::mem::offset_of!(mshv_gpap_access_bitmap, access_type) - 0usize];
    ["Offset of field: mshv_gpap_access_bitmap::access_op"]
        [::std::mem::offset_of!(mshv_gpap_access_bitmap, access_op) - 1usize];
    ["Offset of field: mshv_gpap_access_bitmap::rsvd"]
        [::std::mem::offset_of!(mshv_gpap_access_bitmap, rsvd) - 2usize];
    ["Offset of field: mshv_gpap_access_bitmap::page_count"]
        [::std::mem::offset_of!(mshv_gpap_access_bitmap, page_count) - 8usize];
    ["Offset of field: mshv_gpap_access_bitmap::gpap_base"]
        [::std::mem::offset_of!(mshv_gpap_access_bitmap, gpap_base) - 16usize];
    ["Offset of field: mshv_gpap_access_bitmap::bitmap_ptr"]
        [::std::mem::offset_of!(mshv_gpap_access_bitmap, bitmap_ptr) - 24usize];
};
pub const MSHV_GPA_HOST_ACCESS_BIT_ACQUIRE: _bindgen_ty_9 = 0;
pub const MSHV_GPA_HOST_ACCESS_BIT_READABLE: _bindgen_ty_9 = 1;
pub const MSHV_GPA_HOST_ACCESS_BIT_WRITABLE: _bindgen_ty_9 = 2;
pub const MSHV_GPA_HOST_ACCESS_BIT_LARGE_PAGE: _bindgen_ty_9 = 3;
pub const MSHV_GPA_HOST_ACCESS_BIT_COUNT: _bindgen_ty_9 = 4;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct mshv_modify_gpa_host_access {
    pub flags: __u8,
    pub rsvd: [__u8; 7usize],
    pub page_count: __u64,
    pub guest_pfns: __IncompleteArrayField<__u64>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_modify_gpa_host_access"]
        [::std::mem::size_of::<mshv_modify_gpa_host_access>() - 16usize];
    ["Alignment of mshv_modify_gpa_host_access"]
        [::std::mem::align_of::<mshv_modify_gpa_host_access>() - 8usize];
    ["Offset of field: mshv_modify_gpa_host_access::flags"]
        [::std::mem::offset_of!(mshv_modify_gpa_host_access, flags) - 0usize];
    ["Offset of field: mshv_modify_gpa_host_access::rsvd"]
        [::std::mem::offset_of!(mshv_modify_gpa_host_access, rsvd) - 1usize];
    ["Offset of field: mshv_modify_gpa_host_access::page_count"]
        [::std::mem::offset_of!(mshv_modify_gpa_host_access, page_count) - 8usize];
    ["Offset of field: mshv_modify_gpa_host_access::guest_pfns"]
        [::std::mem::offset_of!(mshv_modify_gpa_host_access, guest_pfns) - 16usize];
};
pub const MSHV_ISOLATED_PAGE_NORMAL: _bindgen_ty_10 = 0;
pub const MSHV_ISOLATED_PAGE_VMSA: _bindgen_ty_10 = 1;
pub const MSHV_ISOLATED_PAGE_ZERO: _bindgen_ty_10 = 2;
pub const MSHV_ISOLATED_PAGE_UNMEASURED: _bindgen_ty_10 = 3;
pub const MSHV_ISOLATED_PAGE_SECRETS: _bindgen_ty_10 = 4;
pub const MSHV_ISOLATED_PAGE_CPUID: _bindgen_ty_10 = 5;
pub const MSHV_ISOLATED_PAGE_COUNT: _bindgen_ty_10 = 6;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct mshv_import_isolated_pages {
    pub page_type: __u8,
    pub rsvd: [__u8; 7usize],
    pub page_count: __u64,
    pub guest_pfns: __IncompleteArrayField<__u64>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_import_isolated_pages"]
        [::std::mem::size_of::<mshv_import_isolated_pages>() - 16usize];
    ["Alignment of mshv_import_isolated_pages"]
        [::std::mem::align_of::<mshv_import_isolated_pages>() - 8usize];
    ["Offset of field: mshv_import_isolated_pages::page_type"]
        [::std::mem::offset_of!(mshv_import_isolated_pages, page_type) - 0usize];
    ["Offset of field: mshv_import_isolated_pages::rsvd"]
        [::std::mem::offset_of!(mshv_import_isolated_pages, rsvd) - 1usize];
    ["Offset of field: mshv_import_isolated_pages::page_count"]
        [::std::mem::offset_of!(mshv_import_isolated_pages, page_count) - 8usize];
    ["Offset of field: mshv_import_isolated_pages::guest_pfns"]
        [::std::mem::offset_of!(mshv_import_isolated_pages, guest_pfns) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_root_hvcall {
    pub code: __u16,
    pub reps: __u16,
    pub in_sz: __u16,
    pub out_sz: __u16,
    pub status: __u16,
    pub rsvd: [__u8; 6usize],
    pub in_ptr: __u64,
    pub out_ptr: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_root_hvcall"][::std::mem::size_of::<mshv_root_hvcall>() - 32usize];
    ["Alignment of mshv_root_hvcall"][::std::mem::align_of::<mshv_root_hvcall>() - 8usize];
    ["Offset of field: mshv_root_hvcall::code"]
        [::std::mem::offset_of!(mshv_root_hvcall, code) - 0usize];
    ["Offset of field: mshv_root_hvcall::reps"]
        [::std::mem::offset_of!(mshv_root_hvcall, reps) - 2usize];
    ["Offset of field: mshv_root_hvcall::in_sz"]
        [::std::mem::offset_of!(mshv_root_hvcall, in_sz) - 4usize];
    ["Offset of field: mshv_root_hvcall::out_sz"]
        [::std::mem::offset_of!(mshv_root_hvcall, out_sz) - 6usize];
    ["Offset of field: mshv_root_hvcall::status"]
        [::std::mem::offset_of!(mshv_root_hvcall, status) - 8usize];
    ["Offset of field: mshv_root_hvcall::rsvd"]
        [::std::mem::offset_of!(mshv_root_hvcall, rsvd) - 10usize];
    ["Offset of field: mshv_root_hvcall::in_ptr"]
        [::std::mem::offset_of!(mshv_root_hvcall, in_ptr) - 16usize];
    ["Offset of field: mshv_root_hvcall::out_ptr"]
        [::std::mem::offset_of!(mshv_root_hvcall, out_ptr) - 24usize];
};
pub const MSHV_VP_MMAP_OFFSET_REGISTERS: _bindgen_ty_11 = 0;
pub const MSHV_VP_MMAP_OFFSET_INTERCEPT_MESSAGE: _bindgen_ty_11 = 1;
pub const MSHV_VP_MMAP_OFFSET_GHCB: _bindgen_ty_11 = 2;
pub const MSHV_VP_MMAP_OFFSET_COUNT: _bindgen_ty_11 = 3;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_run_vp {
    pub msg_buf: [__u8; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_run_vp"][::std::mem::size_of::<mshv_run_vp>() - 256usize];
    ["Alignment of mshv_run_vp"][::std::mem::align_of::<mshv_run_vp>() - 1usize];
    ["Offset of field: mshv_run_vp::msg_buf"]
        [::std::mem::offset_of!(mshv_run_vp, msg_buf) - 0usize];
};
impl Default for mshv_run_vp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSHV_DEV_TYPE_VFIO: _bindgen_ty_12 = 0;
pub const MSHV_DEV_TYPE_MAX: _bindgen_ty_12 = 1;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_create_device {
    pub type_: __u32,
    pub fd: __u32,
    pub flags: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_create_device"][::std::mem::size_of::<mshv_create_device>() - 12usize];
    ["Alignment of mshv_create_device"][::std::mem::align_of::<mshv_create_device>() - 4usize];
    ["Offset of field: mshv_create_device::type_"]
        [::std::mem::offset_of!(mshv_create_device, type_) - 0usize];
    ["Offset of field: mshv_create_device::fd"]
        [::std::mem::offset_of!(mshv_create_device, fd) - 4usize];
    ["Offset of field: mshv_create_device::flags"]
        [::std::mem::offset_of!(mshv_create_device, flags) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_device_attr {
    pub flags: __u32,
    pub group: __u32,
    pub attr: __u64,
    pub addr: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_device_attr"][::std::mem::size_of::<mshv_device_attr>() - 24usize];
    ["Alignment of mshv_device_attr"][::std::mem::align_of::<mshv_device_attr>() - 8usize];
    ["Offset of field: mshv_device_attr::flags"]
        [::std::mem::offset_of!(mshv_device_attr, flags) - 0usize];
    ["Offset of field: mshv_device_attr::group"]
        [::std::mem::offset_of!(mshv_device_attr, group) - 4usize];
    ["Offset of field: mshv_device_attr::attr"]
        [::std::mem::offset_of!(mshv_device_attr, attr) - 8usize];
    ["Offset of field: mshv_device_attr::addr"]
        [::std::mem::offset_of!(mshv_device_attr, addr) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_trace_config {
    pub mode: __u32,
    pub max_buffers_count: __u32,
    pub pages_per_buffer: __u32,
    pub buffers_threshold: __u32,
    pub time_basis: __u32,
    pub system_time: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mshv_trace_config"][::std::mem::size_of::<mshv_trace_config>() - 32usize];
    ["Alignment of mshv_trace_config"][::std::mem::align_of::<mshv_trace_config>() - 8usize];
    ["Offset of field: mshv_trace_config::mode"]
        [::std::mem::offset_of!(mshv_trace_config, mode) - 0usize];
    ["Offset of field: mshv_trace_config::max_buffers_count"]
        [::std::mem::offset_of!(mshv_trace_config, max_buffers_count) - 4usize];
    ["Offset of field: mshv_trace_config::pages_per_buffer"]
        [::std::mem::offset_of!(mshv_trace_config, pages_per_buffer) - 8usize];
    ["Offset of field: mshv_trace_config::buffers_threshold"]
        [::std::mem::offset_of!(mshv_trace_config, buffers_threshold) - 12usize];
    ["Offset of field: mshv_trace_config::time_basis"]
        [::std::mem::offset_of!(mshv_trace_config, time_basis) - 16usize];
    ["Offset of field: mshv_trace_config::system_time"]
        [::std::mem::offset_of!(mshv_trace_config, system_time) - 24usize];
};
