/* automatically generated by rust-bindgen 0.69.4 */
/*
 * Kernel (uapi) headers used for these bindings are as follows:
 * include/hyperv/hvgdk_mini.h
 * include/hyperv/hvgdk.h
 * include/hyperv/hvhdk_mini.h
 * include/hyperv/hvhdk.h
 * include/linux/mshv.h
 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const HVGDK_MINI_H_VERSION: u32 = 25294;
pub const HV_STATUS_SUCCESS: u32 = 0;
pub const HV_STATUS_INVALID_HYPERCALL_CODE: u32 = 2;
pub const HV_STATUS_INVALID_HYPERCALL_INPUT: u32 = 3;
pub const HV_STATUS_INVALID_ALIGNMENT: u32 = 4;
pub const HV_STATUS_INVALID_PARAMETER: u32 = 5;
pub const HV_STATUS_ACCESS_DENIED: u32 = 6;
pub const HV_STATUS_INVALID_PARTITION_STATE: u32 = 7;
pub const HV_STATUS_OPERATION_DENIED: u32 = 8;
pub const HV_STATUS_UNKNOWN_PROPERTY: u32 = 9;
pub const HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE: u32 = 10;
pub const HV_STATUS_INSUFFICIENT_MEMORY: u32 = 11;
pub const HV_STATUS_INVALID_PARTITION_ID: u32 = 13;
pub const HV_STATUS_INVALID_VP_INDEX: u32 = 14;
pub const HV_STATUS_NOT_FOUND: u32 = 16;
pub const HV_STATUS_INVALID_PORT_ID: u32 = 17;
pub const HV_STATUS_INVALID_CONNECTION_ID: u32 = 18;
pub const HV_STATUS_INSUFFICIENT_BUFFERS: u32 = 19;
pub const HV_STATUS_NOT_ACKNOWLEDGED: u32 = 20;
pub const HV_STATUS_INVALID_VP_STATE: u32 = 21;
pub const HV_STATUS_NO_RESOURCES: u32 = 29;
pub const HV_STATUS_PROCESSOR_FEATURE_NOT_SUPPORTED: u32 = 32;
pub const HV_STATUS_INVALID_LP_INDEX: u32 = 65;
pub const HV_STATUS_INVALID_REGISTER_VALUE: u32 = 80;
pub const HV_STATUS_OPERATION_FAILED: u32 = 113;
pub const HV_STATUS_CALL_PENDING: u32 = 121;
pub const HV_LINUX_VENDOR_ID: u32 = 33024;
pub const HV_HYP_PAGE_SHIFT: u32 = 12;
pub const HV_HYP_PAGE_SIZE: u32 = 4096;
pub const HV_HYP_PAGE_MASK: i32 = -4096;
pub const HV_HYP_LARGE_PAGE_SHIFT: u32 = 21;
pub const HV_X64_MSR_GUEST_OS_ID: u32 = 1073741824;
pub const HV_X64_MSR_HYPERCALL: u32 = 1073741825;
pub const HV_X64_MSR_VP_INDEX: u32 = 1073741826;
pub const HV_X64_MSR_RESET: u32 = 1073741827;
pub const HV_X64_MSR_VP_RUNTIME: u32 = 1073741840;
pub const HV_X64_MSR_TIME_REF_COUNT: u32 = 1073741856;
pub const HV_X64_MSR_REFERENCE_TSC: u32 = 1073741857;
pub const HV_X64_MSR_TSC_FREQUENCY: u32 = 1073741858;
pub const HV_X64_MSR_APIC_FREQUENCY: u32 = 1073741859;
pub const HV_X64_MSR_EOI: u32 = 1073741936;
pub const HV_X64_MSR_ICR: u32 = 1073741937;
pub const HV_X64_MSR_TPR: u32 = 1073741938;
pub const HV_X64_MSR_VP_ASSIST_PAGE: u32 = 1073741939;
pub const HV_X64_MSR_SCONTROL: u32 = 1073741952;
pub const HV_X64_MSR_SVERSION: u32 = 1073741953;
pub const HV_X64_MSR_SIEFP: u32 = 1073741954;
pub const HV_X64_MSR_SIMP: u32 = 1073741955;
pub const HV_X64_MSR_EOM: u32 = 1073741956;
pub const HV_X64_MSR_SIRBP: u32 = 1073741957;
pub const HV_X64_MSR_SINT0: u32 = 1073741968;
pub const HV_X64_MSR_SINT1: u32 = 1073741969;
pub const HV_X64_MSR_SINT2: u32 = 1073741970;
pub const HV_X64_MSR_SINT3: u32 = 1073741971;
pub const HV_X64_MSR_SINT4: u32 = 1073741972;
pub const HV_X64_MSR_SINT5: u32 = 1073741973;
pub const HV_X64_MSR_SINT6: u32 = 1073741974;
pub const HV_X64_MSR_SINT7: u32 = 1073741975;
pub const HV_X64_MSR_SINT8: u32 = 1073741976;
pub const HV_X64_MSR_SINT9: u32 = 1073741977;
pub const HV_X64_MSR_SINT10: u32 = 1073741978;
pub const HV_X64_MSR_SINT11: u32 = 1073741979;
pub const HV_X64_MSR_SINT12: u32 = 1073741980;
pub const HV_X64_MSR_SINT13: u32 = 1073741981;
pub const HV_X64_MSR_SINT14: u32 = 1073741982;
pub const HV_X64_MSR_SINT15: u32 = 1073741983;
pub const HV_X64_MSR_NESTED_SCONTROL: u32 = 1073746048;
pub const HV_X64_MSR_NESTED_SVERSION: u32 = 1073746049;
pub const HV_X64_MSR_NESTED_SIEFP: u32 = 1073746050;
pub const HV_X64_MSR_NESTED_SIMP: u32 = 1073746051;
pub const HV_X64_MSR_NESTED_EOM: u32 = 1073746052;
pub const HV_X64_MSR_NESTED_SINT0: u32 = 1073746064;
pub const HV_X64_MSR_STIMER0_CONFIG: u32 = 1073742000;
pub const HV_X64_MSR_STIMER0_COUNT: u32 = 1073742001;
pub const HV_X64_MSR_STIMER1_CONFIG: u32 = 1073742002;
pub const HV_X64_MSR_STIMER1_COUNT: u32 = 1073742003;
pub const HV_X64_MSR_STIMER2_CONFIG: u32 = 1073742004;
pub const HV_X64_MSR_STIMER2_COUNT: u32 = 1073742005;
pub const HV_X64_MSR_STIMER3_CONFIG: u32 = 1073742006;
pub const HV_X64_MSR_STIMER3_COUNT: u32 = 1073742007;
pub const HV_X64_MSR_GUEST_IDLE: u32 = 1073742064;
pub const HV_X64_MSR_CRASH_P0: u32 = 1073742080;
pub const HV_X64_MSR_CRASH_P1: u32 = 1073742081;
pub const HV_X64_MSR_CRASH_P2: u32 = 1073742082;
pub const HV_X64_MSR_CRASH_P3: u32 = 1073742083;
pub const HV_X64_MSR_CRASH_P4: u32 = 1073742084;
pub const HV_X64_MSR_CRASH_CTL: u32 = 1073742085;
pub const HV_IPI_LOW_VECTOR: u32 = 16;
pub const HV_IPI_HIGH_VECTOR: u32 = 255;
pub const HV_X64_MSR_REENLIGHTENMENT_CONTROL: u32 = 1073742086;
pub const HV_X64_MSR_TSC_EMULATION_CONTROL: u32 = 1073742087;
pub const HV_X64_MSR_TSC_EMULATION_STATUS: u32 = 1073742088;
pub const HV_X64_MSR_TSC_INVARIANT_CONTROL: u32 = 1073742104;
pub const HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS: u32 = 1073741824;
pub const HYPERV_CPUID_INTERFACE: u32 = 1073741825;
pub const HYPERV_CPUID_VERSION: u32 = 1073741826;
pub const HYPERV_CPUID_FEATURES: u32 = 1073741827;
pub const HYPERV_CPUID_ENLIGHTMENT_INFO: u32 = 1073741828;
pub const HYPERV_CPUID_IMPLEMENT_LIMITS: u32 = 1073741829;
pub const HYPERV_CPUID_CPU_MANAGEMENT_FEATURES: u32 = 1073741831;
pub const HYPERV_CPUID_NESTED_FEATURES: u32 = 1073741834;
pub const HYPERV_CPUID_ISOLATION_CONFIG: u32 = 1073741836;
pub const HYPERV_CPUID_VIRT_STACK_INTERFACE: u32 = 1073741953;
pub const HYPERV_VS_INTERFACE_EAX_SIGNATURE: u32 = 824398678;
pub const HYPERV_CPUID_VIRT_STACK_PROPERTIES: u32 = 1073741954;
pub const HYPERV_VS_PROPERTIES_EAX_EXTENDED_IOAPIC_RTE: u32 = 4;
pub const HYPERV_HYPERVISOR_PRESENT_BIT: u32 = 2147483648;
pub const HYPERV_CPUID_MIN: u32 = 1073741829;
pub const HYPERV_CPUID_MAX: u32 = 1073807359;
pub const HV_MSR_VP_RUNTIME_AVAILABLE: u32 = 1;
pub const HV_MSR_TIME_REF_COUNT_AVAILABLE: u32 = 2;
pub const HV_MSR_SYNIC_AVAILABLE: u32 = 4;
pub const HV_MSR_SYNTIMER_AVAILABLE: u32 = 8;
pub const HV_MSR_APIC_ACCESS_AVAILABLE: u32 = 16;
pub const HV_MSR_HYPERCALL_AVAILABLE: u32 = 32;
pub const HV_MSR_VP_INDEX_AVAILABLE: u32 = 64;
pub const HV_MSR_RESET_AVAILABLE: u32 = 128;
pub const HV_MSR_STAT_PAGES_AVAILABLE: u32 = 256;
pub const HV_MSR_REFERENCE_TSC_AVAILABLE: u32 = 512;
pub const HV_MSR_GUEST_IDLE_AVAILABLE: u32 = 1024;
pub const HV_ACCESS_FREQUENCY_MSRS: u32 = 2048;
pub const HV_ACCESS_REENLIGHTENMENT: u32 = 8192;
pub const HV_ACCESS_TSC_INVARIANT: u32 = 32768;
pub const HV_CREATE_PARTITIONS: u32 = 1;
pub const HV_ACCESS_PARTITION_ID: u32 = 2;
pub const HV_ACCESS_MEMORY_POOL: u32 = 4;
pub const HV_ADJUST_MESSAGE_BUFFERS: u32 = 8;
pub const HV_POST_MESSAGES: u32 = 16;
pub const HV_SIGNAL_EVENTS: u32 = 32;
pub const HV_CREATE_PORT: u32 = 64;
pub const HV_CONNECT_PORT: u32 = 128;
pub const HV_ACCESS_STATS: u32 = 256;
pub const HV_DEBUGGING: u32 = 2048;
pub const HV_CPU_MANAGEMENT: u32 = 4096;
pub const HV_ENABLE_EXTENDED_HYPERCALLS: u32 = 1048576;
pub const HV_ISOLATION: u32 = 4194304;
pub const HV_X64_MWAIT_AVAILABLE: u32 = 1;
pub const HV_X64_GUEST_DEBUGGING_AVAILABLE: u32 = 2;
pub const HV_X64_PERF_MONITOR_AVAILABLE: u32 = 4;
pub const HV_X64_CPU_DYNAMIC_PARTITIONING_AVAILABLE: u32 = 8;
pub const HV_X64_HYPERCALL_XMM_INPUT_AVAILABLE: u32 = 16;
pub const HV_X64_GUEST_IDLE_STATE_AVAILABLE: u32 = 32;
pub const HV_FEATURE_FREQUENCY_MSRS_AVAILABLE: u32 = 256;
pub const HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE: u32 = 1024;
pub const HV_FEATURE_DEBUG_MSRS_AVAILABLE: u32 = 2048;
pub const HV_X64_HYPERCALL_XMM_OUTPUT_AVAILABLE: u32 = 32768;
pub const HV_STIMER_DIRECT_MODE_AVAILABLE: u32 = 524288;
pub const HV_DEVICE_DOMAIN_AVAILABLE: u32 = 16777216;
pub const HV_S1_DEVICE_DOMAIN_AVAILABLE: u32 = 33554432;
pub const HV_X64_AS_SWITCH_RECOMMENDED: u32 = 1;
pub const HV_X64_LOCAL_TLB_FLUSH_RECOMMENDED: u32 = 2;
pub const HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED: u32 = 4;
pub const HV_X64_APIC_ACCESS_RECOMMENDED: u32 = 8;
pub const HV_X64_SYSTEM_RESET_RECOMMENDED: u32 = 16;
pub const HV_X64_RELAXED_TIMING_RECOMMENDED: u32 = 32;
pub const HV_DEPRECATING_AEOI_RECOMMENDED: u32 = 512;
pub const HV_X64_CLUSTER_IPI_RECOMMENDED: u32 = 1024;
pub const HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED: u32 = 2048;
pub const HV_X64_HYPERV_NESTED: u32 = 4096;
pub const HV_X64_ENLIGHTENED_VMCS_RECOMMENDED: u32 = 16384;
pub const HV_SHARED_GPA_BOUNDARY_ACTIVE: u32 = 32;
pub const HV_MAXIMUM_PROCESSORS: u32 = 2048;
pub const HV_MAX_VP_INDEX: u32 = 2047;
pub const HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE: u32 = 2;
pub const HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST: u32 = 3;
pub const HVCALL_GET_LOGICAL_PROCESSOR_RUN_TIME: u32 = 4;
pub const HVCALL_NOTIFY_LONG_SPIN_WAIT: u32 = 8;
pub const HVCALL_SEND_IPI: u32 = 11;
pub const HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX: u32 = 19;
pub const HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX: u32 = 20;
pub const HVCALL_SEND_IPI_EX: u32 = 21;
pub const HVCALL_CREATE_PARTITION: u32 = 64;
pub const HVCALL_INITIALIZE_PARTITION: u32 = 65;
pub const HVCALL_FINALIZE_PARTITION: u32 = 66;
pub const HVCALL_DELETE_PARTITION: u32 = 67;
pub const HVCALL_GET_PARTITION_PROPERTY: u32 = 68;
pub const HVCALL_SET_PARTITION_PROPERTY: u32 = 69;
pub const HVCALL_GET_PARTITION_ID: u32 = 70;
pub const HVCALL_DEPOSIT_MEMORY: u32 = 72;
pub const HVCALL_WITHDRAW_MEMORY: u32 = 73;
pub const HVCALL_MAP_GPA_PAGES: u32 = 75;
pub const HVCALL_UNMAP_GPA_PAGES: u32 = 76;
pub const HVCALL_INSTALL_INTERCEPT: u32 = 77;
pub const HVCALL_CREATE_VP: u32 = 78;
pub const HVCALL_DELETE_VP: u32 = 79;
pub const HVCALL_GET_VP_REGISTERS: u32 = 80;
pub const HVCALL_SET_VP_REGISTERS: u32 = 81;
pub const HVCALL_TRANSLATE_VIRTUAL_ADDRESS: u32 = 82;
pub const HVCALL_READ_GPA: u32 = 83;
pub const HVCALL_WRITE_GPA: u32 = 84;
pub const HVCALL_CLEAR_VIRTUAL_INTERRUPT: u32 = 86;
pub const HVCALL_DELETE_PORT: u32 = 88;
pub const HVCALL_DISCONNECT_PORT: u32 = 91;
pub const HVCALL_POST_MESSAGE: u32 = 92;
pub const HVCALL_SIGNAL_EVENT: u32 = 93;
pub const HVCALL_INITIALIZE_EVENT_LOG_BUFFER_GROUP: u32 = 96;
pub const HVCALL_FINALIZE_EVENT_LOG_BUFFER_GROUP: u32 = 97;
pub const HVCALL_CREATE_EVENT_LOG_BUFFER: u32 = 98;
pub const HVCALL_DELETE_EVENT_LOG_BUFFER: u32 = 99;
pub const HVCALL_MAP_EVENT_LOG_BUFFER: u32 = 100;
pub const HVCALL_UNMAP_EVENT_LOG_BUFFER: u32 = 101;
pub const HVCALL_SET_EVENT_LOG_GROUP_SOURCES: u32 = 102;
pub const HVCALL_RELEASE_EVENT_LOG_BUFFER: u32 = 103;
pub const HVCALL_FLUSH_EVENT_LOG_BUFFER: u32 = 104;
pub const HVCALL_POST_DEBUG_DATA: u32 = 105;
pub const HVCALL_RETRIEVE_DEBUG_DATA: u32 = 106;
pub const HVCALL_RESET_DEBUG_SESSION: u32 = 107;
pub const HVCALL_MAP_STATS_PAGE: u32 = 108;
pub const HVCALL_UNMAP_STATS_PAGE: u32 = 109;
pub const HVCALL_SET_SYSTEM_PROPERTY: u32 = 111;
pub const HVCALL_ADD_LOGICAL_PROCESSOR: u32 = 118;
pub const HVCALL_GET_SYSTEM_PROPERTY: u32 = 123;
pub const HVCALL_MAP_DEVICE_INTERRUPT: u32 = 124;
pub const HVCALL_UNMAP_DEVICE_INTERRUPT: u32 = 125;
pub const HVCALL_RETARGET_INTERRUPT: u32 = 126;
pub const HVCALL_ATTACH_DEVICE: u32 = 130;
pub const HVCALL_DETACH_DEVICE: u32 = 131;
pub const HVCALL_ENTER_SLEEP_STATE: u32 = 132;
pub const HVCALL_NOTIFY_PARTITION_EVENT: u32 = 135;
pub const HVCALL_NOTIFY_PORT_RING_EMPTY: u32 = 139;
pub const HVCALL_REGISTER_INTERCEPT_RESULT: u32 = 145;
pub const HVCALL_ASSERT_VIRTUAL_INTERRUPT: u32 = 148;
pub const HVCALL_CREATE_PORT: u32 = 149;
pub const HVCALL_CONNECT_PORT: u32 = 150;
pub const HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE: u32 = 175;
pub const HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_LIST: u32 = 176;
pub const HVCALL_CREATE_DEVICE_DOMAIN: u32 = 177;
pub const HVCALL_ATTACH_DEVICE_DOMAIN: u32 = 178;
pub const HVCALL_MAP_DEVICE_GPA_PAGES: u32 = 179;
pub const HVCALL_UNMAP_DEVICE_GPA_PAGES: u32 = 180;
pub const HVCALL_SIGNAL_EVENT_DIRECT: u32 = 192;
pub const HVCALL_POST_MESSAGE_DIRECT: u32 = 193;
pub const HVCALL_DISPATCH_VP: u32 = 194;
pub const HVCALL_DETACH_DEVICE_DOMAIN: u32 = 196;
pub const HVCALL_DELETE_DEVICE_DOMAIN: u32 = 197;
pub const HVCALL_QUERY_DEVICE_DOMAIN: u32 = 198;
pub const HVCALL_MAP_SPARSE_DEVICE_GPA_PAGES: u32 = 199;
pub const HVCALL_UNMAP_SPARSE_DEVICE_GPA_PAGES: u32 = 200;
pub const HVCALL_GET_GPA_PAGES_ACCESS_STATES: u32 = 201;
pub const HVCALL_CONFIGURE_DEVICE_DOMAIN: u32 = 206;
pub const HVCALL_FLUSH_DEVICE_DOMAIN: u32 = 208;
pub const HVCALL_ACQUIRE_SPARSE_SPA_PAGE_HOST_ACCESS: u32 = 215;
pub const HVCALL_RELEASE_SPARSE_SPA_PAGE_HOST_ACCESS: u32 = 216;
pub const HVCALL_MAP_VP_STATE_PAGE: u32 = 225;
pub const HVCALL_UNMAP_VP_STATE_PAGE: u32 = 226;
pub const HVCALL_GET_VP_STATE: u32 = 227;
pub const HVCALL_SET_VP_STATE: u32 = 228;
pub const HVCALL_IMPORT_ISOLATED_PAGES: u32 = 239;
pub const HVCALL_COMPLETE_ISOLATED_IMPORT: u32 = 241;
pub const HVCALL_ISSUE_SNP_PSP_GUEST_REQUEST: u32 = 242;
pub const HVCALL_GET_VP_CPUID_VALUES: u32 = 244;
pub const HVCALL_LOG_HYPERVISOR_SYSTEM_CONFIG: u32 = 248;
pub const HVCALL_DISABLE_HYP_EX: u32 = 271;
pub const HV_MAX_FLUSH_PAGES: u32 = 2048;
pub const HV_GPA_PAGE_RANGE_PAGE_SIZE_2MB: u32 = 0;
pub const HV_GPA_PAGE_RANGE_PAGE_SIZE_1GB: u32 = 1;
pub const HV_FLUSH_ALL_PROCESSORS: u32 = 1;
pub const HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES: u32 = 2;
pub const HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY: u32 = 4;
pub const HV_FLUSH_USE_EXTENDED_RANGE_FORMAT: u32 = 8;
pub const HV_SYNIC_SINT_COUNT: u32 = 16;
pub const HV_SYNIC_INTERCEPTION_SINT_INDEX: u32 = 0;
pub const HV_SYNIC_IOMMU_FAULT_SINT_INDEX: u32 = 1;
pub const HV_SYNIC_VMBUS_SINT_INDEX: u32 = 2;
pub const HV_SYNIC_HAL_HV_TIMER_SINT_INDEX: u32 = 3;
pub const HV_SYNIC_HVL_SHARED_SINT_INDEX: u32 = 4;
pub const HV_SYNIC_FIRST_UNUSED_SINT_INDEX: u32 = 5;
pub const HV_SYNIC_DOORBELL_SINT_INDEX: u32 = 5;
pub const HV_INTERRUPT_VECTOR_NONE: u32 = 4294967295;
pub const HV_SYNIC_STIMER_COUNT: u32 = 4;
pub const HV_MESSAGE_SIZE: u32 = 256;
pub const HV_MESSAGE_PAYLOAD_BYTE_COUNT: u32 = 240;
pub const HV_MESSAGE_PAYLOAD_QWORD_COUNT: u32 = 30;
pub const HV_MSR_CRASH_P0: u32 = 1073742080;
pub const HV_MSR_CRASH_P1: u32 = 1073742081;
pub const HV_MSR_CRASH_P2: u32 = 1073742082;
pub const HV_MSR_CRASH_P3: u32 = 1073742083;
pub const HV_MSR_CRASH_P4: u32 = 1073742084;
pub const HV_MSR_CRASH_CTL: u32 = 1073742085;
pub const HV_MSR_VP_INDEX: u32 = 1073741826;
pub const HV_MSR_TIME_REF_COUNT: u32 = 1073741856;
pub const HV_MSR_REFERENCE_TSC: u32 = 1073741857;
pub const HV_MSR_SINT0: u32 = 1073741968;
pub const HV_MSR_SVERSION: u32 = 1073741953;
pub const HV_MSR_SCONTROL: u32 = 1073741952;
pub const HV_MSR_SIEFP: u32 = 1073741954;
pub const HV_MSR_SIMP: u32 = 1073741955;
pub const HV_MSR_EOM: u32 = 1073741956;
pub const HV_MSR_SIRBP: u32 = 1073741957;
pub const HV_MSR_NESTED_SCONTROL: u32 = 1073746048;
pub const HV_MSR_NESTED_SVERSION: u32 = 1073746049;
pub const HV_MSR_NESTED_SIEFP: u32 = 1073746050;
pub const HV_MSR_NESTED_SIMP: u32 = 1073746051;
pub const HV_MSR_NESTED_EOM: u32 = 1073746052;
pub const HV_MSR_NESTED_SINT0: u32 = 1073746064;
pub const HV_MSR_STIMER0_CONFIG: u32 = 1073742000;
pub const HV_MSR_STIMER0_COUNT: u32 = 1073742001;
pub const HV_UNMAP_GPA_LARGE_PAGE: u32 = 2;
pub const HV_INTERCEPT_ACCESS_MASK_NONE: u32 = 0;
pub const HV_INTERCEPT_ACCESS_MASK_READ: u32 = 1;
pub const HV_INTERCEPT_ACCESS_MASK_WRITE: u32 = 2;
pub const HV_INTERCEPT_ACCESS_MASK_EXECUTE: u32 = 4;
pub const HV_INTERCEPT_ACCESS_READ: u32 = 0;
pub const HV_INTERCEPT_ACCESS_WRITE: u32 = 1;
pub const HV_INTERCEPT_ACCESS_EXECUTE: u32 = 2;
pub const HVGDK_H_VERSION: u32 = 25125;
pub const HVHVK_MINI_VERSION: u32 = 25294;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_MASK: u32 = 7;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_ANY: u32 = 0;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_BYTE: u32 = 1;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_WORD: u32 = 2;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_DWORD: u32 = 3;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_QWORD: u32 = 4;
pub const HV_DOORBELL_FLAG_TRIGGER_ANY_VALUE: u32 = 2147483648;
pub const HV_GENERIC_SET_SHIFT: u32 = 6;
pub const HV_GENERIC_SET_MASK: u32 = 63;
pub const HV_PFN_RNG_PAGEBITS: u32 = 24;
pub const HV_MAP_GPA_PERMISSIONS_NONE: u32 = 0;
pub const HV_MAP_GPA_READABLE: u32 = 1;
pub const HV_MAP_GPA_WRITABLE: u32 = 2;
pub const HV_MAP_GPA_KERNEL_EXECUTABLE: u32 = 4;
pub const HV_MAP_GPA_USER_EXECUTABLE: u32 = 8;
pub const HV_MAP_GPA_EXECUTABLE: u32 = 12;
pub const HV_MAP_GPA_PERMISSIONS_MASK: u32 = 15;
pub const HV_MAP_GPA_ADJUSTABLE: u32 = 32768;
pub const HV_MAP_GPA_NOT_CACHED: u32 = 2097152;
pub const HV_MAP_GPA_LARGE_PAGE: u32 = 2147483648;
pub const HV_SOURCE_SHADOW_NONE: u32 = 0;
pub const HV_SOURCE_SHADOW_BRIDGE_BUS_RANGE: u32 = 1;
pub const HV_DEVICE_DOMAIN_TYPE_S2: u32 = 0;
pub const HV_DEVICE_DOMAIN_TYPE_S1: u32 = 1;
pub const HV_DEVICE_DOMAIN_TYPE_SOC: u32 = 2;
pub const HV_DEVICE_DOMAIN_ID_S2_DEFAULT: u32 = 0;
pub const HV_DEVICE_DOMAIN_ID_S2_NULL: u32 = 4294967295;
pub const HVHDK_H_VERSION: u32 = 25212;
pub const HV_X64_REGISTER_CLASS_GENERAL: u32 = 0;
pub const HV_X64_REGISTER_CLASS_IP: u32 = 1;
pub const HV_X64_REGISTER_CLASS_XMM: u32 = 2;
pub const HV_X64_REGISTER_CLASS_SEGMENT: u32 = 3;
pub const HV_X64_REGISTER_CLASS_FLAGS: u32 = 4;
pub const HV_VP_REGISTER_PAGE_VERSION_1: u32 = 1;
pub const HV_PARTITION_PROCESSOR_FEATURES_BANKS: u32 = 2;
pub const HV_PARTITION_SYNTHETIC_PROCESSOR_FEATURES_BANKS: u32 = 1;
pub const HV_PARTITION_ISOLATION_TYPE_NONE: u32 = 0;
pub const HV_PARTITION_ISOLATION_TYPE_VBS: u32 = 1;
pub const HV_PARTITION_ISOLATION_TYPE_SNP: u32 = 2;
pub const HV_PARTITION_ISOLATION_TYPE_TDX: u32 = 3;
pub const HV_PARTITION_ISOLATION_HOST_TYPE_NONE: u32 = 0;
pub const HV_PARTITION_ISOLATION_HOST_TYPE_HARDWARE: u32 = 1;
pub const HV_PARTITION_ISOLATION_HOST_TYPE_RESERVED: u32 = 2;
pub const HV_PARTITION_CREATION_FLAG_EXO_PARTITION: u32 = 256;
pub const HV_PARTITION_CREATION_FLAG_LAPIC_ENABLED: u32 = 8192;
pub const HV_PARTITION_CREATION_FLAG_INTERCEPT_MESSAGE_PAGE_ENABLED: u32 = 524288;
pub const HV_PARTITION_CREATION_FLAG_X2APIC_CAPABLE: u32 = 4194304;
pub const HV_TRANSLATE_GVA_VALIDATE_READ: u32 = 1;
pub const HV_TRANSLATE_GVA_VALIDATE_WRITE: u32 = 2;
pub const HV_TRANSLATE_GVA_VALIDATE_EXECUTE: u32 = 4;
pub const HV_TRANSLATE_GVA_PRIVILEGE_EXEMPT: u32 = 8;
pub const HV_TRANSLATE_GVA_SET_PAGE_TABLE_BITS: u32 = 16;
pub const HV_TRANSLATE_GVA_TLB_FLUSH_INHIBIT: u32 = 32;
pub const HV_TRANSLATE_GVA_SUPERVISOR_ACCESS: u32 = 64;
pub const HV_TRANSLATE_GVA_USER_ACCESS: u32 = 128;
pub const HV_TRANSLATE_GVA_ENFORCE_SMAP: u32 = 256;
pub const HV_TRANSLATE_GVA_OVERRIDE_SMAP: u32 = 512;
pub const HV_TRANSLATE_GVA_SHADOW_STACK: u32 = 1024;
pub const HV_SYNIC_EVENT_RING_MESSAGE_COUNT: u32 = 63;
pub const HV_HYPERCALL_INTERCEPT_MAX_XMM_REGISTERS: u32 = 6;
pub const HV_UNSUPPORTED_FEATURE_INTERCEPT: u32 = 1;
pub const HV_UNSUPPORTED_FEATURE_TASK_SWITCH_TSS: u32 = 2;
pub const HV_X64_PENDING_INTERRUPT: u32 = 0;
pub const HV_X64_PENDING_NMI: u32 = 2;
pub const HV_X64_PENDING_EXCEPTION: u32 = 3;
pub const HV_GPA_ATTRIBUTE_INTERCEPT_MAX_RANGES: u32 = 29;
pub const HV_GET_SET_VP_STATE_TYPE_PFN: u32 = 2147483648;
pub const HV_ROOT_SCHEDULER_MAX_VPS_PER_CHILD_PARTITION: u32 = 1024;
pub const HV_EVENTLOG_BUFFER_INDEX_NONE: u32 = 4294967295;
pub const HV_DISPATCH_VP_FLAG_CLEAR_INTERCEPT_SUSPEND: u32 = 1;
pub const HV_DISPATCH_VP_FLAG_ENABLE_CALLER_INTERRUPTS: u32 = 2;
pub const HV_DISPATCH_VP_FLAG_SET_CALLER_SPEC_CTRL: u32 = 4;
pub const HV_DISPATCH_VP_FLAG_SKIP_VP_SPEC_FLUSH: u32 = 8;
pub const HV_DISPATCH_VP_FLAG_SKIP_CALLER_SPEC_FLUSH: u32 = 16;
pub const HV_DISPATCH_VP_FLAG_SKIP_CALLER_USER_SPEC_FLUSH: u32 = 32;
pub const HV_MODIFY_SPA_PAGE_HOST_ACCESS_MAKE_EXCLUSIVE: u32 = 1;
pub const HV_MODIFY_SPA_PAGE_HOST_ACCESS_MAKE_SHARED: u32 = 2;
pub const HV_MODIFY_SPA_PAGE_HOST_ACCESS_LARGE_PAGE: u32 = 4;
pub const HV_MODIFY_SPA_PAGE_HOST_ACCESS_HUGE_PAGE: u32 = 8;
pub const HV_PSP_CPUID_LEAF_COUNT_MAX: u32 = 64;
pub const HV_READ_WRITE_GPA_MAX_SIZE: u32 = 16;
pub const MSHV_API_VERSION: u32 = 0;
pub const MAX_RUN_MSG_SIZE: u32 = 256;
pub const MSHV_VP_MAX_REGISTERS: u32 = 128;
pub const MSHV_IRQFD_FLAG_DEASSIGN: u32 = 1;
pub const MSHV_IRQFD_FLAG_RESAMPLE: u32 = 2;
pub const MSHV_IOCTL: u32 = 184;
pub const MSHV_DIAG_IOCTL: u32 = 185;
pub const MSHV_TRACE_IOCTL: u32 = 186;
pub const MSHV_CREATE_DEVICE_TEST: u32 = 1;
pub const MSHV_DEV_VFIO_GROUP: u32 = 1;
pub const MSHV_DEV_VFIO_GROUP_ADD: u32 = 1;
pub const MSHV_DEV_VFIO_GROUP_DEL: u32 = 2;
pub type bool_ = bool;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type hv_nano100_time_t = __u64;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_u128 {
    pub low_part: __u64,
    pub high_part: __u64,
}
#[test]
fn bindgen_test_layout_hv_u128() {
    const UNINIT: ::std::mem::MaybeUninit<hv_u128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_u128>(),
        16usize,
        concat!("Size of: ", stringify!(hv_u128))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_u128>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_u128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_part) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_u128),
            "::",
            stringify!(low_part)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high_part) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_u128),
            "::",
            stringify!(high_part)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_reenlightenment_control {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_reenlightenment_control() {
    assert_eq!(
        ::std::mem::size_of::<hv_reenlightenment_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_reenlightenment_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_reenlightenment_control>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_reenlightenment_control))
    );
}
impl hv_reenlightenment_control {
    #[inline]
    pub fn vector(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn target_vp(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_target_vp(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: __u64,
        reserved1: __u64,
        enabled: __u64,
        reserved2: __u64,
        target_vp: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u64 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved2: u64 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let target_vp: u64 = unsafe { ::std::mem::transmute(target_vp) };
            target_vp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_tsc_emulation_status {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_tsc_emulation_status() {
    assert_eq!(
        ::std::mem::size_of::<hv_tsc_emulation_status>(),
        8usize,
        concat!("Size of: ", stringify!(hv_tsc_emulation_status))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_tsc_emulation_status>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_tsc_emulation_status))
    );
}
impl hv_tsc_emulation_status {
    #[inline]
    pub fn inprogress(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inprogress(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inprogress: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inprogress: u64 = unsafe { ::std::mem::transmute(inprogress) };
            inprogress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_tsc_emulation_control {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_tsc_emulation_control() {
    assert_eq!(
        ::std::mem::size_of::<hv_tsc_emulation_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_tsc_emulation_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_tsc_emulation_control>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_tsc_emulation_control))
    );
}
impl hv_tsc_emulation_control {
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: __u64, reserved: __u64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_get_partition_id {
    pub partition_id: __u64,
}
#[test]
fn bindgen_test_layout_hv_get_partition_id() {
    const UNINIT: ::std::mem::MaybeUninit<hv_get_partition_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_get_partition_id>(),
        8usize,
        concat!("Size of: ", stringify!(hv_get_partition_id))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_get_partition_id>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_get_partition_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_get_partition_id),
            "::",
            stringify!(partition_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_reference_tsc_msr {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_reference_tsc_msr__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_reference_tsc_msr__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_reference_tsc_msr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_reference_tsc_msr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_reference_tsc_msr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_reference_tsc_msr__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_reference_tsc_msr__bindgen_ty_1)
        )
    );
}
impl hv_reference_tsc_msr__bindgen_ty_1 {
    #[inline]
    pub fn enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn pfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_pfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: __u64,
        reserved: __u64,
        pfn: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u64 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let pfn: u64 = unsafe { ::std::mem::transmute(pfn) };
            pfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_reference_tsc_msr() {
    const UNINIT: ::std::mem::MaybeUninit<hv_reference_tsc_msr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_reference_tsc_msr>(),
        8usize,
        concat!("Size of: ", stringify!(hv_reference_tsc_msr))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_reference_tsc_msr>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_reference_tsc_msr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_reference_tsc_msr),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_reference_tsc_msr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_vpset {
    pub format: __u64,
    pub valid_bank_mask: __u64,
    pub bank_contents: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_vpset() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vpset> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vpset>(),
        16usize,
        concat!("Size of: ", stringify!(hv_vpset))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vpset>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vpset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vpset),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid_bank_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vpset),
            "::",
            stringify!(valid_bank_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bank_contents) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vpset),
            "::",
            stringify!(bank_contents)
        )
    );
}
impl Default for hv_vpset {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_hypervisor_version_info {
    pub __bindgen_anon_1: hv_hypervisor_version_info__bindgen_ty_1,
    pub __bindgen_anon_2: hv_hypervisor_version_info__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_hypervisor_version_info__bindgen_ty_1 {
    pub build_number: __u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub service_pack: __u32,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_hypervisor_version_info__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_hypervisor_version_info__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_hypervisor_version_info__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_hypervisor_version_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_1),
            "::",
            stringify!(build_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_pack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_1),
            "::",
            stringify!(service_pack)
        )
    );
}
impl hv_hypervisor_version_info__bindgen_ty_1 {
    #[inline]
    pub fn minor_version(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_minor_version(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn major_version(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_major_version(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minor_version: __u32,
        major_version: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let minor_version: u32 = unsafe { ::std::mem::transmute(minor_version) };
            minor_version as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let major_version: u32 = unsafe { ::std::mem::transmute(major_version) };
            major_version as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn service_number(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_service_number(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn service_branch(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_service_branch(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        service_number: __u32,
        service_branch: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let service_number: u32 = unsafe { ::std::mem::transmute(service_number) };
            service_number as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let service_branch: u32 = unsafe { ::std::mem::transmute(service_branch) };
            service_branch as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_hypervisor_version_info__bindgen_ty_2 {
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
}
#[test]
fn bindgen_test_layout_hv_hypervisor_version_info__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_hypervisor_version_info__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_hypervisor_version_info__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_hypervisor_version_info__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_2),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_2),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_2),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_hypervisor_version_info__bindgen_ty_2),
            "::",
            stringify!(edx)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_hypervisor_version_info() {
    assert_eq!(
        ::std::mem::size_of::<hv_hypervisor_version_info>(),
        16usize,
        concat!("Size of: ", stringify!(hv_hypervisor_version_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_hypervisor_version_info>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_hypervisor_version_info))
    );
}
impl Default for hv_hypervisor_version_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_isolation_type_HV_ISOLATION_TYPE_NONE: hv_isolation_type = 0;
pub const hv_isolation_type_HV_ISOLATION_TYPE_VBS: hv_isolation_type = 1;
pub const hv_isolation_type_HV_ISOLATION_TYPE_SNP: hv_isolation_type = 2;
pub type hv_isolation_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_msr_hypercall_contents {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_msr_hypercall_contents__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_msr_hypercall_contents__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_msr_hypercall_contents__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_hypercall_contents__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_msr_hypercall_contents__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_hypercall_contents__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_msr_hypercall_contents__bindgen_ty_1)
        )
    );
}
impl hv_x64_msr_hypercall_contents__bindgen_ty_1 {
    #[inline]
    pub fn enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn guest_physical_address(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_guest_physical_address(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: __u64,
        reserved: __u64,
        guest_physical_address: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u64 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let guest_physical_address: u64 =
                unsafe { ::std::mem::transmute(guest_physical_address) };
            guest_physical_address as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_msr_hypercall_contents() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_msr_hypercall_contents> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_hypercall_contents>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_msr_hypercall_contents))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_hypercall_contents>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_msr_hypercall_contents))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_hypercall_contents),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_msr_hypercall_contents {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_assist_msr_contents {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_vp_assist_msr_contents__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_assist_msr_contents__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_vp_assist_msr_contents__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_assist_msr_contents__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_assist_msr_contents__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_assist_msr_contents__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_assist_msr_contents__bindgen_ty_1)
        )
    );
}
impl hv_vp_assist_msr_contents__bindgen_ty_1 {
    #[inline]
    pub fn enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn pfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_pfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: __u64,
        reserved: __u64,
        pfn: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u64 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let pfn: u64 = unsafe { ::std::mem::transmute(pfn) };
            pfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_vp_assist_msr_contents() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_assist_msr_contents> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_assist_msr_contents>(),
        8usize,
        concat!("Size of: ", stringify!(hv_vp_assist_msr_contents))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_assist_msr_contents>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_vp_assist_msr_contents))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_msr_contents),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_vp_assist_msr_contents {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_guest_mapping_flush {
    pub address_space: __u64,
    pub flags: __u64,
}
#[test]
fn bindgen_test_layout_hv_guest_mapping_flush() {
    const UNINIT: ::std::mem::MaybeUninit<hv_guest_mapping_flush> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_guest_mapping_flush>(),
        16usize,
        concat!("Size of: ", stringify!(hv_guest_mapping_flush))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_guest_mapping_flush>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_guest_mapping_flush))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_guest_mapping_flush),
            "::",
            stringify!(address_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_guest_mapping_flush),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_gpa_page_range {
    pub address_space: __u64,
    pub page: hv_gpa_page_range__bindgen_ty_1,
    pub __bindgen_anon_1: hv_gpa_page_range__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_gpa_page_range__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_gpa_page_range__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_range__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_gpa_page_range__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_range__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_range__bindgen_ty_1))
    );
}
impl hv_gpa_page_range__bindgen_ty_1 {
    #[inline]
    pub fn additional_pages(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_additional_pages(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn largepage(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_largepage(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn basepfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_basepfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        additional_pages: __u64,
        largepage: __u64,
        basepfn: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let additional_pages: u64 = unsafe { ::std::mem::transmute(additional_pages) };
            additional_pages as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let largepage: u64 = unsafe { ::std::mem::transmute(largepage) };
            largepage as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let basepfn: u64 = unsafe { ::std::mem::transmute(basepfn) };
            basepfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_gpa_page_range__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_gpa_page_range__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_range__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(hv_gpa_page_range__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_range__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_range__bindgen_ty_2))
    );
}
impl hv_gpa_page_range__bindgen_ty_2 {
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn page_size(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_page_size(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn base_large_pfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 43u8) as u64) }
    }
    #[inline]
    pub fn set_base_large_pfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 43u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u64,
        page_size: __u64,
        reserved1: __u64,
        base_large_pfn: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let page_size: u64 = unsafe { ::std::mem::transmute(page_size) };
            page_size as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 43u8, {
            let base_large_pfn: u64 = unsafe { ::std::mem::transmute(base_large_pfn) };
            base_large_pfn as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_gpa_page_range() {
    const UNINIT: ::std::mem::MaybeUninit<hv_gpa_page_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_range>(),
        8usize,
        concat!("Size of: ", stringify!(hv_gpa_page_range))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_range>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_gpa_page_range),
            "::",
            stringify!(address_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_gpa_page_range),
            "::",
            stringify!(page)
        )
    );
}
impl Default for hv_gpa_page_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_FIXED: hv_interrupt_type = 0;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_LOWESTPRIORITY: hv_interrupt_type = 1;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_SMI: hv_interrupt_type = 2;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_REMOTEREAD: hv_interrupt_type = 3;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_NMI: hv_interrupt_type = 4;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_INIT: hv_interrupt_type = 5;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_SIPI: hv_interrupt_type = 6;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_EXTINT: hv_interrupt_type = 7;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_LOCALINT0: hv_interrupt_type = 8;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_LOCALINT1: hv_interrupt_type = 9;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_MAXIMUM: hv_interrupt_type = 10;
pub type hv_interrupt_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_synic_sint {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_synic_sint__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_sint__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_synic_sint__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_synic_sint__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_sint__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_sint__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_sint__bindgen_ty_1))
    );
}
impl hv_synic_sint__bindgen_ty_1 {
    #[inline]
    pub fn vector(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn masked(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_masked(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_eoi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_auto_eoi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polling(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_polling(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn as_intercept(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_as_intercept(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_proxy(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 43u8) as u64) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 43u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: __u64,
        reserved1: __u64,
        masked: __u64,
        auto_eoi: __u64,
        polling: __u64,
        as_intercept: __u64,
        proxy: __u64,
        reserved2: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u64 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let masked: u64 = unsafe { ::std::mem::transmute(masked) };
            masked as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let auto_eoi: u64 = unsafe { ::std::mem::transmute(auto_eoi) };
            auto_eoi as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let polling: u64 = unsafe { ::std::mem::transmute(polling) };
            polling as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let as_intercept: u64 = unsafe { ::std::mem::transmute(as_intercept) };
            as_intercept as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let proxy: u64 = unsafe { ::std::mem::transmute(proxy) };
            proxy as u64
        });
        __bindgen_bitfield_unit.set(21usize, 43u8, {
            let reserved2: u64 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_synic_sint() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_sint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_sint>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_sint))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_sint>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_synic_sint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_sint),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_synic_sint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_xsave_xfem_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_xsave_xfem_register__bindgen_ty_1,
    pub __bindgen_anon_2: hv_x64_xsave_xfem_register__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_xsave_xfem_register__bindgen_ty_1 {
    pub low_uint32: __u32,
    pub high_uint32: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_xsave_xfem_register__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_xsave_xfem_register__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xsave_xfem_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xsave_xfem_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1),
            "::",
            stringify!(low_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high_uint32) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1),
            "::",
            stringify!(high_uint32)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_xsave_xfem_register__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_xsave_xfem_register__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xsave_xfem_register__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xsave_xfem_register__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_2)
        )
    );
}
impl hv_x64_xsave_xfem_register__bindgen_ty_2 {
    #[inline]
    pub fn legacy_x87(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_legacy_x87(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn legacy_sse(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_legacy_sse(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpx_bndreg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_bndreg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpx_bndcsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_bndcsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_512_op_mask(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_op_mask(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_512_zmmhi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_zmmhi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_512_zmm16_31(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_zmm16_31(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd8_9(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd8_9(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pasid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pasid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_u(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_u(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_s(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_s(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd13_16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd13_16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn xtile_cfg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xtile_cfg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtile_data(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xtile_data(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd19_63(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 45u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd19_63(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 45u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        legacy_x87: __u64,
        legacy_sse: __u64,
        avx: __u64,
        mpx_bndreg: __u64,
        mpx_bndcsr: __u64,
        avx_512_op_mask: __u64,
        avx_512_zmmhi: __u64,
        avx_512_zmm16_31: __u64,
        rsvd8_9: __u64,
        pasid: __u64,
        cet_u: __u64,
        cet_s: __u64,
        rsvd13_16: __u64,
        xtile_cfg: __u64,
        xtile_data: __u64,
        rsvd19_63: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let legacy_x87: u64 = unsafe { ::std::mem::transmute(legacy_x87) };
            legacy_x87 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let legacy_sse: u64 = unsafe { ::std::mem::transmute(legacy_sse) };
            legacy_sse as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let avx: u64 = unsafe { ::std::mem::transmute(avx) };
            avx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mpx_bndreg: u64 = unsafe { ::std::mem::transmute(mpx_bndreg) };
            mpx_bndreg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mpx_bndcsr: u64 = unsafe { ::std::mem::transmute(mpx_bndcsr) };
            mpx_bndcsr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let avx_512_op_mask: u64 = unsafe { ::std::mem::transmute(avx_512_op_mask) };
            avx_512_op_mask as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let avx_512_zmmhi: u64 = unsafe { ::std::mem::transmute(avx_512_zmmhi) };
            avx_512_zmmhi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let avx_512_zmm16_31: u64 = unsafe { ::std::mem::transmute(avx_512_zmm16_31) };
            avx_512_zmm16_31 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let rsvd8_9: u64 = unsafe { ::std::mem::transmute(rsvd8_9) };
            rsvd8_9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let pasid: u64 = unsafe { ::std::mem::transmute(pasid) };
            pasid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cet_u: u64 = unsafe { ::std::mem::transmute(cet_u) };
            cet_u as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cet_s: u64 = unsafe { ::std::mem::transmute(cet_s) };
            cet_s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 4u8, {
            let rsvd13_16: u64 = unsafe { ::std::mem::transmute(rsvd13_16) };
            rsvd13_16 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let xtile_cfg: u64 = unsafe { ::std::mem::transmute(xtile_cfg) };
            xtile_cfg as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xtile_data: u64 = unsafe { ::std::mem::transmute(xtile_data) };
            xtile_data as u64
        });
        __bindgen_bitfield_unit.set(19usize, 45u8, {
            let rsvd19_63: u64 = unsafe { ::std::mem::transmute(rsvd19_63) };
            rsvd19_63 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_xsave_xfem_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_xsave_xfem_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xsave_xfem_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_xsave_xfem_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xsave_xfem_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_xsave_xfem_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xsave_xfem_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_xsave_xfem_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_stimer_config {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_stimer_config__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stimer_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_stimer_config__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_stimer_config__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_stimer_config__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stimer_config__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_stimer_config__bindgen_ty_1))
    );
}
impl hv_stimer_config__bindgen_ty_1 {
    #[inline]
    pub fn enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn periodic(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_periodic(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lazy(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lazy(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_auto_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apic_vector(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_apic_vector(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_mode(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_direct_mode(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z0(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sintx(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_sintx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 44u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 44u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: __u64,
        periodic: __u64,
        lazy: __u64,
        auto_enable: __u64,
        apic_vector: __u64,
        direct_mode: __u64,
        reserved_z0: __u64,
        sintx: __u64,
        reserved_z1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u64 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let periodic: u64 = unsafe { ::std::mem::transmute(periodic) };
            periodic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lazy: u64 = unsafe { ::std::mem::transmute(lazy) };
            lazy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let auto_enable: u64 = unsafe { ::std::mem::transmute(auto_enable) };
            auto_enable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let apic_vector: u64 = unsafe { ::std::mem::transmute(apic_vector) };
            apic_vector as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let direct_mode: u64 = unsafe { ::std::mem::transmute(direct_mode) };
            direct_mode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved_z0: u64 = unsafe { ::std::mem::transmute(reserved_z0) };
            reserved_z0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let sintx: u64 = unsafe { ::std::mem::transmute(sintx) };
            sintx as u64
        });
        __bindgen_bitfield_unit.set(20usize, 44u8, {
            let reserved_z1: u64 = unsafe { ::std::mem::transmute(reserved_z1) };
            reserved_z1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_stimer_config() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stimer_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stimer_config>(),
        8usize,
        concat!("Size of: ", stringify!(hv_stimer_config))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stimer_config>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_stimer_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_config),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_stimer_config {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_port_id {
    pub as__u32: __u32,
    pub u: hv_port_id__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_id__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_port_id__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_port_id__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_port_id__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_id__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_port_id__bindgen_ty_1))
    );
}
impl hv_port_id__bindgen_ty_1 {
    #[inline]
    pub fn id(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(id: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_port_id() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_id>(),
        4usize,
        concat!("Size of: ", stringify!(hv_port_id))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_id>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_port_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as__u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_id),
            "::",
            stringify!(as__u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_id),
            "::",
            stringify!(u)
        )
    );
}
impl Default for hv_port_id {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_message_type_HVMSG_NONE: hv_message_type = 0;
pub const hv_message_type_HVMSG_UNMAPPED_GPA: hv_message_type = 2147483648;
pub const hv_message_type_HVMSG_GPA_INTERCEPT: hv_message_type = 2147483649;
pub const hv_message_type_HVMSG_UNACCEPTED_GPA: hv_message_type = 2147483651;
pub const hv_message_type_HVMSG_GPA_ATTRIBUTE_INTERCEPT: hv_message_type = 2147483652;
pub const hv_message_type_HVMSG_TIMER_EXPIRED: hv_message_type = 2147483664;
pub const hv_message_type_HVMSG_INVALID_VP_REGISTER_VALUE: hv_message_type = 2147483680;
pub const hv_message_type_HVMSG_UNRECOVERABLE_EXCEPTION: hv_message_type = 2147483681;
pub const hv_message_type_HVMSG_UNSUPPORTED_FEATURE: hv_message_type = 2147483682;
pub const hv_message_type_HVMSG_OPAQUE_INTERCEPT: hv_message_type = 2147483711;
pub const hv_message_type_HVMSG_EVENTLOG_BUFFERCOMPLETE: hv_message_type = 2147483712;
pub const hv_message_type_HVMSG_HYPERCALL_INTERCEPT: hv_message_type = 2147483728;
pub const hv_message_type_HVMSG_SYNIC_EVENT_INTERCEPT: hv_message_type = 2147483744;
pub const hv_message_type_HVMSG_SYNIC_SINT_INTERCEPT: hv_message_type = 2147483745;
pub const hv_message_type_HVMSG_SYNIC_SINT_DELIVERABLE: hv_message_type = 2147483746;
pub const hv_message_type_HVMSG_ASYNC_CALL_COMPLETION: hv_message_type = 2147483760;
pub const hv_message_type_HVMSG_SCHEDULER_VP_SIGNAL_BITSET: hv_message_type = 2147483904;
pub const hv_message_type_HVMSG_SCHEDULER_VP_SIGNAL_PAIR: hv_message_type = 2147483905;
pub const hv_message_type_HVMSG_X64_IO_PORT_INTERCEPT: hv_message_type = 2147549184;
pub const hv_message_type_HVMSG_X64_MSR_INTERCEPT: hv_message_type = 2147549185;
pub const hv_message_type_HVMSG_X64_CPUID_INTERCEPT: hv_message_type = 2147549186;
pub const hv_message_type_HVMSG_X64_EXCEPTION_INTERCEPT: hv_message_type = 2147549187;
pub const hv_message_type_HVMSG_X64_APIC_EOI: hv_message_type = 2147549188;
pub const hv_message_type_HVMSG_X64_LEGACY_FP_ERROR: hv_message_type = 2147549189;
pub const hv_message_type_HVMSG_X64_IOMMU_PRQ: hv_message_type = 2147549190;
pub const hv_message_type_HVMSG_X64_HALT: hv_message_type = 2147549191;
pub const hv_message_type_HVMSG_X64_INTERRUPTION_DELIVERABLE: hv_message_type = 2147549192;
pub const hv_message_type_HVMSG_X64_SIPI_INTERCEPT: hv_message_type = 2147549193;
pub const hv_message_type_HVMSG_X64_SEV_VMGEXIT_INTERCEPT: hv_message_type = 2147549203;
pub type hv_message_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_synic_simp {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_synic_simp__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_simp__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_synic_simp__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_synic_simp__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_simp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_simp__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_simp__bindgen_ty_1))
    );
}
impl hv_synic_simp__bindgen_ty_1 {
    #[inline]
    pub fn simp_enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_simp_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_preserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn base_simp_gpa(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_base_simp_gpa(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        simp_enabled: __u64,
        preserved: __u64,
        base_simp_gpa: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let simp_enabled: u64 = unsafe { ::std::mem::transmute(simp_enabled) };
            simp_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let preserved: u64 = unsafe { ::std::mem::transmute(preserved) };
            preserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let base_simp_gpa: u64 = unsafe { ::std::mem::transmute(base_simp_gpa) };
            base_simp_gpa as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_synic_simp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_simp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_simp>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_simp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_simp>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_synic_simp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_simp),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_synic_simp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message_flags {
    pub asu8: __u8,
    pub __bindgen_anon_1: hv_message_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_message_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_message_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_message_flags__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(hv_message_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_flags__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_flags__bindgen_ty_1))
    );
}
impl hv_message_flags__bindgen_ty_1 {
    #[inline]
    pub fn msg_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_pending: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_pending: u8 = unsafe { ::std::mem::transmute(msg_pending) };
            msg_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_message_flags() {
    const UNINIT: ::std::mem::MaybeUninit<hv_message_flags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_message_flags>(),
        1usize,
        concat!("Size of: ", stringify!(hv_message_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asu8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_flags),
            "::",
            stringify!(asu8)
        )
    );
}
impl Default for hv_message_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message_header {
    pub message_type: __u32,
    pub payload_size: __u8,
    pub message_flags: hv_message_flags,
    pub reserved: [__u8; 2usize],
    pub __bindgen_anon_1: hv_message_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message_header__bindgen_ty_1 {
    pub sender: __u64,
    pub port: hv_port_id,
}
#[test]
fn bindgen_test_layout_hv_message_header__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_message_header__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_message_header__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_message_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_header__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_message_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header__bindgen_ty_1),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header__bindgen_ty_1),
            "::",
            stringify!(port)
        )
    );
}
impl Default for hv_message_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_message_header() {
    const UNINIT: ::std::mem::MaybeUninit<hv_message_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_message_header>(),
        16usize,
        concat!("Size of: ", stringify!(hv_message_header))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_header>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_flags) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(message_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hv_message_header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_notification_message_payload {
    pub sint_index: __u32,
}
#[test]
fn bindgen_test_layout_hv_notification_message_payload() {
    const UNINIT: ::std::mem::MaybeUninit<hv_notification_message_payload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_notification_message_payload>(),
        4usize,
        concat!("Size of: ", stringify!(hv_notification_message_payload))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_notification_message_payload>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_notification_message_payload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_notification_message_payload),
            "::",
            stringify!(sint_index)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message {
    pub header: hv_message_header,
    pub u: hv_message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message__bindgen_ty_1 {
    pub payload: [__u64; 30usize],
}
#[test]
fn bindgen_test_layout_hv_message__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_message__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_message__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(hv_message__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_message__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message__bindgen_ty_1),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for hv_message__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_message>(),
        256usize,
        concat!("Size of: ", stringify!(hv_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message),
            "::",
            stringify!(u)
        )
    );
}
impl Default for hv_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message_page {
    pub sint_message: [hv_message; 16usize],
}
#[test]
fn bindgen_test_layout_hv_message_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_message_page> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_message_page>(),
        4096usize,
        concat!("Size of: ", stringify!(hv_message_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_page),
            "::",
            stringify!(sint_message)
        )
    );
}
impl Default for hv_message_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_segment_register {
    pub base: __u64,
    pub limit: __u32,
    pub selector: __u16,
    pub __bindgen_anon_1: hv_x64_segment_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_segment_register__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1,
    pub attributes: __u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_type(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_segment_type(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn non_system_segment(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_non_system_segment(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn descriptor_privilege_level(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_descriptor_privilege_level(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn present(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_present(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn available(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_available(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _long(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__long(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _default(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__default(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn granularity(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_granularity(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_type: __u16,
        non_system_segment: __u16,
        descriptor_privilege_level: __u16,
        present: __u16,
        reserved: __u16,
        available: __u16,
        _long: __u16,
        _default: __u16,
        granularity: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let segment_type: u16 = unsafe { ::std::mem::transmute(segment_type) };
            segment_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let non_system_segment: u16 = unsafe { ::std::mem::transmute(non_system_segment) };
            non_system_segment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let descriptor_privilege_level: u16 =
                unsafe { ::std::mem::transmute(descriptor_privilege_level) };
            descriptor_privilege_level as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let present: u16 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let available: u16 = unsafe { ::std::mem::transmute(available) };
            available as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let _long: u16 = unsafe { ::std::mem::transmute(_long) };
            _long as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let _default: u16 = unsafe { ::std::mem::transmute(_default) };
            _default as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let granularity: u16 = unsafe { ::std::mem::transmute(granularity) };
            granularity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_segment_register__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_segment_register__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_segment_register__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_segment_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_segment_register__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_segment_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register__bindgen_ty_1),
            "::",
            stringify!(attributes)
        )
    );
}
impl Default for hv_x64_segment_register__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_segment_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_segment_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_segment_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_segment_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_segment_register>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_segment_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register),
            "::",
            stringify!(selector)
        )
    );
}
impl Default for hv_x64_segment_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_table_register {
    pub pad: [__u16; 3usize],
    pub limit: __u16,
    pub base: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_table_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_table_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_table_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_table_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_table_register>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_table_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_table_register),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_table_register),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_table_register),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_control_status_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_fp_control_status_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_fp_control_status_register__bindgen_ty_1 {
    pub fp_control: __u16,
    pub fp_status: __u16,
    pub fp_tag: __u8,
    pub reserved: __u8,
    pub last_fp_op: __u16,
    pub __bindgen_anon_1: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_rip: __u64,
    pub __bindgen_anon_1:
        hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_eip: __u32,
    pub last_fp_cs: __u16,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1()
{
    const UNINIT: ::std::mem::MaybeUninit<
        hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_eip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_eip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_cs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_rip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_rip)
        )
    );
}
impl Default for hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_fp_control_status_register__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_control_status_register__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_control_status_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_control) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(fp_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_status) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(fp_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_tag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(fp_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_op) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(last_fp_op)
        )
    );
}
impl Default for hv_x64_fp_control_status_register__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_fp_control_status_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_control_status_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_fp_control_status_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_control_status_register>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register),
            "::",
            stringify!(as_uint128)
        )
    );
}
impl Default for hv_x64_fp_control_status_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_xmm_control_status_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_xmm_control_status_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_xmm_control_status_register__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1,
    pub xmm_status_control: __u32,
    pub xmm_status_control_mask: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_rdp: __u64,
    pub __bindgen_anon_1:
        hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_dp: __u32,
    pub last_fp_ds: __u16,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_dp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(last_fp_dp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_ds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(last_fp_ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_fp_rdp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_rdp)
        )
    );
}
impl Default for hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_xmm_control_status_register__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xmm_control_status_register__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xmm_control_status_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm_status_control) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1),
            "::",
            stringify!(xmm_status_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm_status_control_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1),
            "::",
            stringify!(xmm_status_control_mask)
        )
    );
}
impl Default for hv_x64_xmm_control_status_register__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_xmm_control_status_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xmm_control_status_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_xmm_control_status_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xmm_control_status_register>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xmm_control_status_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register),
            "::",
            stringify!(as_uint128)
        )
    );
}
impl Default for hv_x64_xmm_control_status_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_fp_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_fp_register__bindgen_ty_1 {
    pub mantissa: __u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_fp_register__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_fp_register__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_register__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_fp_register__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mantissa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_register__bindgen_ty_1),
            "::",
            stringify!(mantissa)
        )
    );
}
impl hv_x64_fp_register__bindgen_ty_1 {
    #[inline]
    pub fn biased_exponent(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        biased_exponent: __u64,
        sign: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let biased_exponent: u64 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sign: u64 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_fp_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_fp_register> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_fp_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_register>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_fp_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_register),
            "::",
            stringify!(as_uint128)
        )
    );
}
impl Default for hv_x64_fp_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_msr_npiep_config_contents {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_msr_npiep_config_contents__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_msr_npiep_config_contents__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_msr_npiep_config_contents__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_npiep_config_contents__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_msr_npiep_config_contents__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_npiep_config_contents__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_msr_npiep_config_contents__bindgen_ty_1)
        )
    );
}
impl hv_x64_msr_npiep_config_contents__bindgen_ty_1 {
    #[inline]
    pub fn prevents_gdt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_gdt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevents_idt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_idt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevents_ldt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_ldt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevents_tr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_tr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prevents_gdt: __u64,
        prevents_idt: __u64,
        prevents_ldt: __u64,
        prevents_tr: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let prevents_gdt: u64 = unsafe { ::std::mem::transmute(prevents_gdt) };
            prevents_gdt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prevents_idt: u64 = unsafe { ::std::mem::transmute(prevents_idt) };
            prevents_idt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let prevents_ldt: u64 = unsafe { ::std::mem::transmute(prevents_ldt) };
            prevents_ldt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let prevents_tr: u64 = unsafe { ::std::mem::transmute(prevents_tr) };
            prevents_tr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_msr_npiep_config_contents() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_msr_npiep_config_contents> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_npiep_config_contents>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_msr_npiep_config_contents))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_npiep_config_contents>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_msr_npiep_config_contents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_npiep_config_contents),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_msr_npiep_config_contents {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_input_vtl {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_input_vtl__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_vtl__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_input_vtl__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_input_vtl__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(hv_input_vtl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_vtl__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_vtl__bindgen_ty_1))
    );
}
impl hv_input_vtl__bindgen_ty_1 {
    #[inline]
    pub fn target_vtl(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_target_vtl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn use_target_vtl(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_target_vtl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_z(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        target_vtl: __u8,
        use_target_vtl: __u8,
        reserved_z: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let target_vtl: u8 = unsafe { ::std::mem::transmute(target_vtl) };
            target_vtl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let use_target_vtl: u8 = unsafe { ::std::mem::transmute(use_target_vtl) };
            use_target_vtl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved_z: u8 = unsafe { ::std::mem::transmute(reserved_z) };
            reserved_z as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_input_vtl() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_vtl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_vtl>(),
        1usize,
        concat!("Size of: ", stringify!(hv_input_vtl))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_vtl>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_vtl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_vtl),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_input_vtl {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_register_vsm_partition_config {
    pub as_u64: __u64,
    pub __bindgen_anon_1: hv_register_vsm_partition_config__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_register_vsm_partition_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_register_vsm_partition_config__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_vsm_partition_config__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_vsm_partition_config__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_vsm_partition_config__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_vsm_partition_config__bindgen_ty_1)
        )
    );
}
impl hv_register_vsm_partition_config__bindgen_ty_1 {
    #[inline]
    pub fn enable_vtl_protection(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_vtl_protection(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_vtl_protection_mask(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_default_vtl_protection_mask(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zero_memory_on_reset(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_zero_memory_on_reset(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deny_lower_vtl_startup(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_deny_lower_vtl_startup(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_acceptance(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_acceptance(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_enable_vtl_protection(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_enable_vtl_protection(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_vp_startup(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_vp_startup(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_cpuid_unimplemented(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_cpuid_unimplemented(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_unrecoverable_exception(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_unrecoverable_exception(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_page(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_restore_partition_time(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_restore_partition_time(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_not_present(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intercept_not_present(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbz(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 49u8) as u64) }
    }
    #[inline]
    pub fn set_mbz(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 49u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_vtl_protection: __u64,
        default_vtl_protection_mask: __u64,
        zero_memory_on_reset: __u64,
        deny_lower_vtl_startup: __u64,
        intercept_acceptance: __u64,
        intercept_enable_vtl_protection: __u64,
        intercept_vp_startup: __u64,
        intercept_cpuid_unimplemented: __u64,
        intercept_unrecoverable_exception: __u64,
        intercept_page: __u64,
        intercept_restore_partition_time: __u64,
        intercept_not_present: __u64,
        mbz: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_vtl_protection: u64 =
                unsafe { ::std::mem::transmute(enable_vtl_protection) };
            enable_vtl_protection as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let default_vtl_protection_mask: u64 =
                unsafe { ::std::mem::transmute(default_vtl_protection_mask) };
            default_vtl_protection_mask as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let zero_memory_on_reset: u64 = unsafe { ::std::mem::transmute(zero_memory_on_reset) };
            zero_memory_on_reset as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let deny_lower_vtl_startup: u64 =
                unsafe { ::std::mem::transmute(deny_lower_vtl_startup) };
            deny_lower_vtl_startup as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let intercept_acceptance: u64 = unsafe { ::std::mem::transmute(intercept_acceptance) };
            intercept_acceptance as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let intercept_enable_vtl_protection: u64 =
                unsafe { ::std::mem::transmute(intercept_enable_vtl_protection) };
            intercept_enable_vtl_protection as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let intercept_vp_startup: u64 = unsafe { ::std::mem::transmute(intercept_vp_startup) };
            intercept_vp_startup as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let intercept_cpuid_unimplemented: u64 =
                unsafe { ::std::mem::transmute(intercept_cpuid_unimplemented) };
            intercept_cpuid_unimplemented as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let intercept_unrecoverable_exception: u64 =
                unsafe { ::std::mem::transmute(intercept_unrecoverable_exception) };
            intercept_unrecoverable_exception as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let intercept_page: u64 = unsafe { ::std::mem::transmute(intercept_page) };
            intercept_page as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let intercept_restore_partition_time: u64 =
                unsafe { ::std::mem::transmute(intercept_restore_partition_time) };
            intercept_restore_partition_time as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let intercept_not_present: u64 =
                unsafe { ::std::mem::transmute(intercept_not_present) };
            intercept_not_present as u64
        });
        __bindgen_bitfield_unit.set(15usize, 49u8, {
            let mbz: u64 = unsafe { ::std::mem::transmute(mbz) };
            mbz as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_register_vsm_partition_config() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_vsm_partition_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_vsm_partition_config>(),
        8usize,
        concat!("Size of: ", stringify!(hv_register_vsm_partition_config))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_vsm_partition_config>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_vsm_partition_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_u64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_vsm_partition_config),
            "::",
            stringify!(as_u64)
        )
    );
}
impl Default for hv_register_vsm_partition_config {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_nested_enlightenments_control {
    pub features: hv_nested_enlightenments_control__bindgen_ty_1,
    pub hypercall_controls: hv_nested_enlightenments_control__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_nested_enlightenments_control__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_nested_enlightenments_control__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_nested_enlightenments_control__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_nested_enlightenments_control__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_nested_enlightenments_control__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_nested_enlightenments_control__bindgen_ty_1)
        )
    );
}
impl hv_nested_enlightenments_control__bindgen_ty_1 {
    #[inline]
    pub fn directhypercall(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directhypercall(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        directhypercall: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let directhypercall: u32 = unsafe { ::std::mem::transmute(directhypercall) };
            directhypercall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_nested_enlightenments_control__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_nested_enlightenments_control__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hv_nested_enlightenments_control__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_nested_enlightenments_control__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_nested_enlightenments_control__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_nested_enlightenments_control__bindgen_ty_2)
        )
    );
}
impl hv_nested_enlightenments_control__bindgen_ty_2 {
    #[inline]
    pub fn inter_partition_comm(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_partition_comm(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inter_partition_comm: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inter_partition_comm: u32 = unsafe { ::std::mem::transmute(inter_partition_comm) };
            inter_partition_comm as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_nested_enlightenments_control() {
    const UNINIT: ::std::mem::MaybeUninit<hv_nested_enlightenments_control> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_nested_enlightenments_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_nested_enlightenments_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_nested_enlightenments_control>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_nested_enlightenments_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_nested_enlightenments_control),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hypercall_controls) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_nested_enlightenments_control),
            "::",
            stringify!(hypercall_controls)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_assist_page {
    pub apic_assist: __u32,
    pub reserved1: __u32,
    pub vtl_entry_reason: __u32,
    pub vtl_reserved: __u32,
    pub vtl_ret_x64rax: __u64,
    pub vtl_ret_x64rcx: __u64,
    pub nested_control: hv_nested_enlightenments_control,
    pub enlighten_vmentry: __u8,
    pub reserved2: [__u8; 7usize],
    pub current_nested_vmcs: __u64,
    pub synthetic_time_unhalted_timer_expired: __u8,
    pub reserved3: [__u8; 7usize],
    pub virtualization_fault_information: [__u8; 40usize],
    pub reserved4: [__u8; 8usize],
    pub intercept_message: [__u8; 256usize],
    pub vtl_ret_actions: [__u8; 256usize],
}
#[test]
fn bindgen_test_layout_hv_vp_assist_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_assist_page> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_assist_page>(),
        624usize,
        concat!("Size of: ", stringify!(hv_vp_assist_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_assist_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vp_assist_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_assist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(apic_assist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl_entry_reason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(vtl_entry_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl_reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(vtl_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl_ret_x64rax) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(vtl_ret_x64rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl_ret_x64rcx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(vtl_ret_x64rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nested_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(nested_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enlighten_vmentry) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(enlighten_vmentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_nested_vmcs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(current_nested_vmcs)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).synthetic_time_unhalted_timer_expired) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(synthetic_time_unhalted_timer_expired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).virtualization_fault_information) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(virtualization_fault_information)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_message) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl_ret_actions) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_assist_page),
            "::",
            stringify!(vtl_ret_actions)
        )
    );
}
impl Default for hv_vp_assist_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_register_name_HV_REGISTER_EXPLICIT_SUSPEND: hv_register_name = 0;
pub const hv_register_name_HV_REGISTER_INTERCEPT_SUSPEND: hv_register_name = 1;
pub const hv_register_name_HV_REGISTER_INSTRUCTION_EMULATION_HINTS: hv_register_name = 2;
pub const hv_register_name_HV_REGISTER_DISPATCH_SUSPEND: hv_register_name = 3;
pub const hv_register_name_HV_REGISTER_INTERNAL_ACTIVITY_STATE: hv_register_name = 4;
pub const hv_register_name_HV_REGISTER_HYPERVISOR_VERSION: hv_register_name = 256;
pub const hv_register_name_HV_REGISTER_PRIVILEGES_AND_FEATURES_INFO: hv_register_name = 512;
pub const hv_register_name_HV_REGISTER_FEATURES_INFO: hv_register_name = 513;
pub const hv_register_name_HV_REGISTER_IMPLEMENTATION_LIMITS_INFO: hv_register_name = 514;
pub const hv_register_name_HV_REGISTER_HARDWARE_FEATURES_INFO: hv_register_name = 515;
pub const hv_register_name_HV_REGISTER_CPU_MANAGEMENT_FEATURES_INFO: hv_register_name = 516;
pub const hv_register_name_HV_REGISTER_SVM_FEATURES_INFO: hv_register_name = 517;
pub const hv_register_name_HV_REGISTER_SKIP_LEVEL_FEATURES_INFO: hv_register_name = 518;
pub const hv_register_name_HV_REGISTER_NESTED_VIRT_FEATURES_INFO: hv_register_name = 519;
pub const hv_register_name_HV_REGISTER_IPT_FEATURES_INFO: hv_register_name = 520;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P0: hv_register_name = 528;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P1: hv_register_name = 529;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P2: hv_register_name = 530;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P3: hv_register_name = 531;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_P4: hv_register_name = 532;
pub const hv_register_name_HV_REGISTER_GUEST_CRASH_CTL: hv_register_name = 533;
pub const hv_register_name_HV_REGISTER_POWER_STATE_CONFIG_C1: hv_register_name = 544;
pub const hv_register_name_HV_REGISTER_POWER_STATE_TRIGGER_C1: hv_register_name = 545;
pub const hv_register_name_HV_REGISTER_POWER_STATE_CONFIG_C2: hv_register_name = 546;
pub const hv_register_name_HV_REGISTER_POWER_STATE_TRIGGER_C2: hv_register_name = 547;
pub const hv_register_name_HV_REGISTER_POWER_STATE_CONFIG_C3: hv_register_name = 548;
pub const hv_register_name_HV_REGISTER_POWER_STATE_TRIGGER_C3: hv_register_name = 549;
pub const hv_register_name_HV_REGISTER_PROCESSOR_CLOCK_FREQUENCY: hv_register_name = 576;
pub const hv_register_name_HV_REGISTER_INTERRUPT_CLOCK_FREQUENCY: hv_register_name = 577;
pub const hv_register_name_HV_REGISTER_GUEST_IDLE: hv_register_name = 592;
pub const hv_register_name_HV_REGISTER_DEBUG_DEVICE_OPTIONS: hv_register_name = 608;
pub const hv_register_name_HV_REGISTER_MEMORY_ZEROING_CONTROL: hv_register_name = 624;
pub const hv_register_name_HV_REGISTER_PENDING_EVENT0: hv_register_name = 65540;
pub const hv_register_name_HV_REGISTER_PENDING_EVENT1: hv_register_name = 65541;
pub const hv_register_name_HV_REGISTER_DELIVERABILITY_NOTIFICATIONS: hv_register_name = 65542;
pub const hv_register_name_HV_REGISTER_VP_RUNTIME: hv_register_name = 589824;
pub const hv_register_name_HV_REGISTER_GUEST_OS_ID: hv_register_name = 589826;
pub const hv_register_name_HV_REGISTER_VP_INDEX: hv_register_name = 589827;
pub const hv_register_name_HV_REGISTER_TIME_REF_COUNT: hv_register_name = 589828;
pub const hv_register_name_HV_REGISTER_CPU_MANAGEMENT_VERSION: hv_register_name = 589831;
pub const hv_register_name_HV_REGISTER_VP_ASSIST_PAGE: hv_register_name = 589843;
pub const hv_register_name_HV_REGISTER_VP_ROOT_SIGNAL_COUNT: hv_register_name = 589844;
pub const hv_register_name_HV_REGISTER_REFERENCE_TSC: hv_register_name = 589847;
pub const hv_register_name_HV_REGISTER_STATS_PARTITION_RETAIL: hv_register_name = 589856;
pub const hv_register_name_HV_REGISTER_STATS_PARTITION_INTERNAL: hv_register_name = 589857;
pub const hv_register_name_HV_REGISTER_STATS_VP_RETAIL: hv_register_name = 589858;
pub const hv_register_name_HV_REGISTER_STATS_VP_INTERNAL: hv_register_name = 589859;
pub const hv_register_name_HV_REGISTER_NESTED_VP_INDEX: hv_register_name = 593923;
pub const hv_register_name_HV_REGISTER_SINT0: hv_register_name = 655360;
pub const hv_register_name_HV_REGISTER_SINT1: hv_register_name = 655361;
pub const hv_register_name_HV_REGISTER_SINT2: hv_register_name = 655362;
pub const hv_register_name_HV_REGISTER_SINT3: hv_register_name = 655363;
pub const hv_register_name_HV_REGISTER_SINT4: hv_register_name = 655364;
pub const hv_register_name_HV_REGISTER_SINT5: hv_register_name = 655365;
pub const hv_register_name_HV_REGISTER_SINT6: hv_register_name = 655366;
pub const hv_register_name_HV_REGISTER_SINT7: hv_register_name = 655367;
pub const hv_register_name_HV_REGISTER_SINT8: hv_register_name = 655368;
pub const hv_register_name_HV_REGISTER_SINT9: hv_register_name = 655369;
pub const hv_register_name_HV_REGISTER_SINT10: hv_register_name = 655370;
pub const hv_register_name_HV_REGISTER_SINT11: hv_register_name = 655371;
pub const hv_register_name_HV_REGISTER_SINT12: hv_register_name = 655372;
pub const hv_register_name_HV_REGISTER_SINT13: hv_register_name = 655373;
pub const hv_register_name_HV_REGISTER_SINT14: hv_register_name = 655374;
pub const hv_register_name_HV_REGISTER_SINT15: hv_register_name = 655375;
pub const hv_register_name_HV_REGISTER_SCONTROL: hv_register_name = 655376;
pub const hv_register_name_HV_REGISTER_SVERSION: hv_register_name = 655377;
pub const hv_register_name_HV_REGISTER_SIEFP: hv_register_name = 655378;
pub const hv_register_name_HV_REGISTER_SIMP: hv_register_name = 655379;
pub const hv_register_name_HV_REGISTER_EOM: hv_register_name = 655380;
pub const hv_register_name_HV_REGISTER_SIRBP: hv_register_name = 655381;
pub const hv_register_name_HV_REGISTER_NESTED_SINT0: hv_register_name = 659456;
pub const hv_register_name_HV_REGISTER_NESTED_SINT1: hv_register_name = 659457;
pub const hv_register_name_HV_REGISTER_NESTED_SINT2: hv_register_name = 659458;
pub const hv_register_name_HV_REGISTER_NESTED_SINT3: hv_register_name = 659459;
pub const hv_register_name_HV_REGISTER_NESTED_SINT4: hv_register_name = 659460;
pub const hv_register_name_HV_REGISTER_NESTED_SINT5: hv_register_name = 659461;
pub const hv_register_name_HV_REGISTER_NESTED_SINT6: hv_register_name = 659462;
pub const hv_register_name_HV_REGISTER_NESTED_SINT7: hv_register_name = 659463;
pub const hv_register_name_HV_REGISTER_NESTED_SINT8: hv_register_name = 659464;
pub const hv_register_name_HV_REGISTER_NESTED_SINT9: hv_register_name = 659465;
pub const hv_register_name_HV_REGISTER_NESTED_SINT10: hv_register_name = 659466;
pub const hv_register_name_HV_REGISTER_NESTED_SINT11: hv_register_name = 659467;
pub const hv_register_name_HV_REGISTER_NESTED_SINT12: hv_register_name = 659468;
pub const hv_register_name_HV_REGISTER_NESTED_SINT13: hv_register_name = 659469;
pub const hv_register_name_HV_REGISTER_NESTED_SINT14: hv_register_name = 659470;
pub const hv_register_name_HV_REGISTER_NESTED_SINT15: hv_register_name = 659471;
pub const hv_register_name_HV_REGISTER_NESTED_SCONTROL: hv_register_name = 659472;
pub const hv_register_name_HV_REGISTER_NESTED_SVERSION: hv_register_name = 659473;
pub const hv_register_name_HV_REGISTER_NESTED_SIFP: hv_register_name = 659474;
pub const hv_register_name_HV_REGISTER_NESTED_SIPP: hv_register_name = 659475;
pub const hv_register_name_HV_REGISTER_NESTED_EOM: hv_register_name = 659476;
pub const hv_register_name_HV_REGISTER_NESTED_SIRBP: hv_register_name = 659477;
pub const hv_register_name_HV_REGISTER_STIMER0_CONFIG: hv_register_name = 720896;
pub const hv_register_name_HV_REGISTER_STIMER0_COUNT: hv_register_name = 720897;
pub const hv_register_name_HV_REGISTER_STIMER1_CONFIG: hv_register_name = 720898;
pub const hv_register_name_HV_REGISTER_STIMER1_COUNT: hv_register_name = 720899;
pub const hv_register_name_HV_REGISTER_STIMER2_CONFIG: hv_register_name = 720900;
pub const hv_register_name_HV_REGISTER_STIMER2_COUNT: hv_register_name = 720901;
pub const hv_register_name_HV_REGISTER_STIMER3_CONFIG: hv_register_name = 720902;
pub const hv_register_name_HV_REGISTER_STIMER3_COUNT: hv_register_name = 720903;
pub const hv_register_name_HV_REGISTER_STIME_UNHALTED_TIMER_CONFIG: hv_register_name = 721152;
pub const hv_register_name_HV_REGISTER_STIME_UNHALTED_TIMER_COUNT: hv_register_name = 721153;
pub const hv_register_name_HV_REGISTER_VSM_CODE_PAGE_OFFSETS: hv_register_name = 851970;
pub const hv_register_name_HV_REGISTER_VSM_VP_STATUS: hv_register_name = 851971;
pub const hv_register_name_HV_REGISTER_VSM_PARTITION_STATUS: hv_register_name = 851972;
pub const hv_register_name_HV_REGISTER_VSM_VINA: hv_register_name = 851973;
pub const hv_register_name_HV_REGISTER_VSM_CAPABILITIES: hv_register_name = 851974;
pub const hv_register_name_HV_REGISTER_VSM_PARTITION_CONFIG: hv_register_name = 851975;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL0: hv_register_name = 851984;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL1: hv_register_name = 851985;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL2: hv_register_name = 851986;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL3: hv_register_name = 851987;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL4: hv_register_name = 851988;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL5: hv_register_name = 851989;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL6: hv_register_name = 851990;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL7: hv_register_name = 851991;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL8: hv_register_name = 851992;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL9: hv_register_name = 851993;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL10: hv_register_name = 851994;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL11: hv_register_name = 851995;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL12: hv_register_name = 851996;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL13: hv_register_name = 851997;
pub const hv_register_name_HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL14: hv_register_name = 851998;
pub const hv_register_name_HV_REGISTER_VSM_VP_WAIT_FOR_TLB_LOCK: hv_register_name = 852000;
pub const hv_register_name_HV_REGISTER_ISOLATION_CAPABILITIES: hv_register_name = 852224;
pub const hv_register_name_HV_REGISTER_PENDING_INTERRUPTION: hv_register_name = 65538;
pub const hv_register_name_HV_REGISTER_INTERRUPT_STATE: hv_register_name = 65539;
pub const hv_register_name_HV_X64_REGISTER_DELIVERABILITY_NOTIFICATIONS: hv_register_name = 65542;
pub const hv_register_name_HV_X64_REGISTER_PENDING_DEBUG_EXCEPTION: hv_register_name = 65543;
pub const hv_register_name_HV_X64_REGISTER_RAX: hv_register_name = 131072;
pub const hv_register_name_HV_X64_REGISTER_RCX: hv_register_name = 131073;
pub const hv_register_name_HV_X64_REGISTER_RDX: hv_register_name = 131074;
pub const hv_register_name_HV_X64_REGISTER_RBX: hv_register_name = 131075;
pub const hv_register_name_HV_X64_REGISTER_RSP: hv_register_name = 131076;
pub const hv_register_name_HV_X64_REGISTER_RBP: hv_register_name = 131077;
pub const hv_register_name_HV_X64_REGISTER_RSI: hv_register_name = 131078;
pub const hv_register_name_HV_X64_REGISTER_RDI: hv_register_name = 131079;
pub const hv_register_name_HV_X64_REGISTER_R8: hv_register_name = 131080;
pub const hv_register_name_HV_X64_REGISTER_R9: hv_register_name = 131081;
pub const hv_register_name_HV_X64_REGISTER_R10: hv_register_name = 131082;
pub const hv_register_name_HV_X64_REGISTER_R11: hv_register_name = 131083;
pub const hv_register_name_HV_X64_REGISTER_R12: hv_register_name = 131084;
pub const hv_register_name_HV_X64_REGISTER_R13: hv_register_name = 131085;
pub const hv_register_name_HV_X64_REGISTER_R14: hv_register_name = 131086;
pub const hv_register_name_HV_X64_REGISTER_R15: hv_register_name = 131087;
pub const hv_register_name_HV_X64_REGISTER_RIP: hv_register_name = 131088;
pub const hv_register_name_HV_X64_REGISTER_RFLAGS: hv_register_name = 131089;
pub const hv_register_name_HV_X64_REGISTER_XMM0: hv_register_name = 196608;
pub const hv_register_name_HV_X64_REGISTER_XMM1: hv_register_name = 196609;
pub const hv_register_name_HV_X64_REGISTER_XMM2: hv_register_name = 196610;
pub const hv_register_name_HV_X64_REGISTER_XMM3: hv_register_name = 196611;
pub const hv_register_name_HV_X64_REGISTER_XMM4: hv_register_name = 196612;
pub const hv_register_name_HV_X64_REGISTER_XMM5: hv_register_name = 196613;
pub const hv_register_name_HV_X64_REGISTER_XMM6: hv_register_name = 196614;
pub const hv_register_name_HV_X64_REGISTER_XMM7: hv_register_name = 196615;
pub const hv_register_name_HV_X64_REGISTER_XMM8: hv_register_name = 196616;
pub const hv_register_name_HV_X64_REGISTER_XMM9: hv_register_name = 196617;
pub const hv_register_name_HV_X64_REGISTER_XMM10: hv_register_name = 196618;
pub const hv_register_name_HV_X64_REGISTER_XMM11: hv_register_name = 196619;
pub const hv_register_name_HV_X64_REGISTER_XMM12: hv_register_name = 196620;
pub const hv_register_name_HV_X64_REGISTER_XMM13: hv_register_name = 196621;
pub const hv_register_name_HV_X64_REGISTER_XMM14: hv_register_name = 196622;
pub const hv_register_name_HV_X64_REGISTER_XMM15: hv_register_name = 196623;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX0: hv_register_name = 196624;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX1: hv_register_name = 196625;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX2: hv_register_name = 196626;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX3: hv_register_name = 196627;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX4: hv_register_name = 196628;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX5: hv_register_name = 196629;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX6: hv_register_name = 196630;
pub const hv_register_name_HV_X64_REGISTER_FP_MMX7: hv_register_name = 196631;
pub const hv_register_name_HV_X64_REGISTER_FP_CONTROL_STATUS: hv_register_name = 196632;
pub const hv_register_name_HV_X64_REGISTER_XMM_CONTROL_STATUS: hv_register_name = 196633;
pub const hv_register_name_HV_X64_REGISTER_CR0: hv_register_name = 262144;
pub const hv_register_name_HV_X64_REGISTER_CR2: hv_register_name = 262145;
pub const hv_register_name_HV_X64_REGISTER_CR3: hv_register_name = 262146;
pub const hv_register_name_HV_X64_REGISTER_CR4: hv_register_name = 262147;
pub const hv_register_name_HV_X64_REGISTER_CR8: hv_register_name = 262148;
pub const hv_register_name_HV_X64_REGISTER_XFEM: hv_register_name = 262149;
pub const hv_register_name_HV_X64_REGISTER_INTERMEDIATE_CR0: hv_register_name = 266240;
pub const hv_register_name_HV_X64_REGISTER_INTERMEDIATE_CR4: hv_register_name = 266243;
pub const hv_register_name_HV_X64_REGISTER_INTERMEDIATE_CR8: hv_register_name = 266244;
pub const hv_register_name_HV_X64_REGISTER_DR0: hv_register_name = 327680;
pub const hv_register_name_HV_X64_REGISTER_DR1: hv_register_name = 327681;
pub const hv_register_name_HV_X64_REGISTER_DR2: hv_register_name = 327682;
pub const hv_register_name_HV_X64_REGISTER_DR3: hv_register_name = 327683;
pub const hv_register_name_HV_X64_REGISTER_DR6: hv_register_name = 327684;
pub const hv_register_name_HV_X64_REGISTER_DR7: hv_register_name = 327685;
pub const hv_register_name_HV_X64_REGISTER_ES: hv_register_name = 393216;
pub const hv_register_name_HV_X64_REGISTER_CS: hv_register_name = 393217;
pub const hv_register_name_HV_X64_REGISTER_SS: hv_register_name = 393218;
pub const hv_register_name_HV_X64_REGISTER_DS: hv_register_name = 393219;
pub const hv_register_name_HV_X64_REGISTER_FS: hv_register_name = 393220;
pub const hv_register_name_HV_X64_REGISTER_GS: hv_register_name = 393221;
pub const hv_register_name_HV_X64_REGISTER_LDTR: hv_register_name = 393222;
pub const hv_register_name_HV_X64_REGISTER_TR: hv_register_name = 393223;
pub const hv_register_name_HV_X64_REGISTER_IDTR: hv_register_name = 458752;
pub const hv_register_name_HV_X64_REGISTER_GDTR: hv_register_name = 458753;
pub const hv_register_name_HV_X64_REGISTER_TSC: hv_register_name = 524288;
pub const hv_register_name_HV_X64_REGISTER_EFER: hv_register_name = 524289;
pub const hv_register_name_HV_X64_REGISTER_KERNEL_GS_BASE: hv_register_name = 524290;
pub const hv_register_name_HV_X64_REGISTER_APIC_BASE: hv_register_name = 524291;
pub const hv_register_name_HV_X64_REGISTER_PAT: hv_register_name = 524292;
pub const hv_register_name_HV_X64_REGISTER_SYSENTER_CS: hv_register_name = 524293;
pub const hv_register_name_HV_X64_REGISTER_SYSENTER_EIP: hv_register_name = 524294;
pub const hv_register_name_HV_X64_REGISTER_SYSENTER_ESP: hv_register_name = 524295;
pub const hv_register_name_HV_X64_REGISTER_STAR: hv_register_name = 524296;
pub const hv_register_name_HV_X64_REGISTER_LSTAR: hv_register_name = 524297;
pub const hv_register_name_HV_X64_REGISTER_CSTAR: hv_register_name = 524298;
pub const hv_register_name_HV_X64_REGISTER_SFMASK: hv_register_name = 524299;
pub const hv_register_name_HV_X64_REGISTER_INITIAL_APIC_ID: hv_register_name = 524300;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_CAP: hv_register_name = 524301;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_DEF_TYPE: hv_register_name = 524302;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE0: hv_register_name = 524304;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE1: hv_register_name = 524305;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE2: hv_register_name = 524306;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE3: hv_register_name = 524307;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE4: hv_register_name = 524308;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE5: hv_register_name = 524309;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE6: hv_register_name = 524310;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE7: hv_register_name = 524311;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE8: hv_register_name = 524312;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASE9: hv_register_name = 524313;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASEA: hv_register_name = 524314;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASEB: hv_register_name = 524315;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASEC: hv_register_name = 524316;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASED: hv_register_name = 524317;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASEE: hv_register_name = 524318;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_BASEF: hv_register_name = 524319;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK0: hv_register_name = 524352;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK1: hv_register_name = 524353;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK2: hv_register_name = 524354;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK3: hv_register_name = 524355;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK4: hv_register_name = 524356;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK5: hv_register_name = 524357;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK6: hv_register_name = 524358;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK7: hv_register_name = 524359;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK8: hv_register_name = 524360;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASK9: hv_register_name = 524361;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASKA: hv_register_name = 524362;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASKB: hv_register_name = 524363;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASKC: hv_register_name = 524364;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASKD: hv_register_name = 524365;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASKE: hv_register_name = 524366;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_PHYS_MASKF: hv_register_name = 524367;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX64K00000: hv_register_name = 524400;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX16K80000: hv_register_name = 524401;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX16KA0000: hv_register_name = 524402;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KC0000: hv_register_name = 524403;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KC8000: hv_register_name = 524404;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KD0000: hv_register_name = 524405;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KD8000: hv_register_name = 524406;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KE0000: hv_register_name = 524407;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KE8000: hv_register_name = 524408;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KF0000: hv_register_name = 524409;
pub const hv_register_name_HV_X64_REGISTER_MSR_MTRR_FIX4KF8000: hv_register_name = 524410;
pub const hv_register_name_HV_X64_REGISTER_TSC_AUX: hv_register_name = 524411;
pub const hv_register_name_HV_X64_REGISTER_BNDCFGS: hv_register_name = 524412;
pub const hv_register_name_HV_X64_REGISTER_DEBUG_CTL: hv_register_name = 524413;
pub const hv_register_name_HV_X64_REGISTER_AVAILABLE0008007E: hv_register_name = 524414;
pub const hv_register_name_HV_X64_REGISTER_AVAILABLE0008007F: hv_register_name = 524415;
pub const hv_register_name_HV_X64_REGISTER_SGX_LAUNCH_CONTROL0: hv_register_name = 524416;
pub const hv_register_name_HV_X64_REGISTER_SGX_LAUNCH_CONTROL1: hv_register_name = 524417;
pub const hv_register_name_HV_X64_REGISTER_SGX_LAUNCH_CONTROL2: hv_register_name = 524418;
pub const hv_register_name_HV_X64_REGISTER_SGX_LAUNCH_CONTROL3: hv_register_name = 524419;
pub const hv_register_name_HV_X64_REGISTER_SPEC_CTRL: hv_register_name = 524420;
pub const hv_register_name_HV_X64_REGISTER_PRED_CMD: hv_register_name = 524421;
pub const hv_register_name_HV_X64_REGISTER_VIRT_SPEC_CTRL: hv_register_name = 524422;
pub const hv_register_name_HV_X64_REGISTER_TSC_ADJUST: hv_register_name = 524438;
pub const hv_register_name_HV_X64_REGISTER_MSR_IA32_MISC_ENABLE: hv_register_name = 524448;
pub const hv_register_name_HV_X64_REGISTER_IA32_FEATURE_CONTROL: hv_register_name = 524449;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_BASIC: hv_register_name = 524450;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_PINBASED_CTLS: hv_register_name = 524451;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_PROCBASED_CTLS: hv_register_name = 524452;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_EXIT_CTLS: hv_register_name = 524453;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_ENTRY_CTLS: hv_register_name = 524454;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_MISC: hv_register_name = 524455;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_CR0_FIXED0: hv_register_name = 524456;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_CR0_FIXED1: hv_register_name = 524457;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_CR4_FIXED0: hv_register_name = 524458;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_CR4_FIXED1: hv_register_name = 524459;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_VMCS_ENUM: hv_register_name = 524460;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_PROCBASED_CTLS2: hv_register_name = 524461;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_EPT_VPID_CAP: hv_register_name = 524462;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_TRUE_PINBASED_CTLS: hv_register_name = 524463;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_TRUE_PROCBASED_CTLS: hv_register_name = 524464;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_TRUE_EXIT_CTLS: hv_register_name = 524465;
pub const hv_register_name_HV_X64_REGISTER_IA32_VMX_TRUE_ENTRY_CTLS: hv_register_name = 524466;
pub const hv_register_name_HV_X64_REGISTER_PERF_GLOBAL_CTRL: hv_register_name = 528384;
pub const hv_register_name_HV_X64_REGISTER_PERF_GLOBAL_STATUS: hv_register_name = 528385;
pub const hv_register_name_HV_X64_REGISTER_PERF_GLOBAL_IN_USE: hv_register_name = 528386;
pub const hv_register_name_HV_X64_REGISTER_FIXED_CTR_CTRL: hv_register_name = 528387;
pub const hv_register_name_HV_X64_REGISTER_DS_AREA: hv_register_name = 528388;
pub const hv_register_name_HV_X64_REGISTER_PEBS_ENABLE: hv_register_name = 528389;
pub const hv_register_name_HV_X64_REGISTER_PEBS_LD_LAT: hv_register_name = 528390;
pub const hv_register_name_HV_X64_REGISTER_PEBS_FRONTEND: hv_register_name = 528391;
pub const hv_register_name_HV_X64_REGISTER_PERF_EVT_SEL0: hv_register_name = 528640;
pub const hv_register_name_HV_X64_REGISTER_PMC0: hv_register_name = 528896;
pub const hv_register_name_HV_X64_REGISTER_FIXED_CTR0: hv_register_name = 529152;
pub const hv_register_name_HV_X64_REGISTER_LBR_TOS: hv_register_name = 532480;
pub const hv_register_name_HV_X64_REGISTER_LBR_SELECT: hv_register_name = 532481;
pub const hv_register_name_HV_X64_REGISTER_LER_FROM_LIP: hv_register_name = 532482;
pub const hv_register_name_HV_X64_REGISTER_LER_TO_LIP: hv_register_name = 532483;
pub const hv_register_name_HV_X64_REGISTER_LBR_FROM0: hv_register_name = 532736;
pub const hv_register_name_HV_X64_REGISTER_LBR_TO0: hv_register_name = 532992;
pub const hv_register_name_HV_X64_REGISTER_LBR_INFO0: hv_register_name = 537344;
pub const hv_register_name_HV_X64_REGISTER_RTIT_CTL: hv_register_name = 528392;
pub const hv_register_name_HV_X64_REGISTER_RTIT_STATUS: hv_register_name = 528393;
pub const hv_register_name_HV_X64_REGISTER_RTIT_OUTPUT_BASE: hv_register_name = 528394;
pub const hv_register_name_HV_X64_REGISTER_RTIT_OUTPUT_MASK_PTRS: hv_register_name = 528395;
pub const hv_register_name_HV_X64_REGISTER_RTIT_CR3_MATCH: hv_register_name = 528396;
pub const hv_register_name_HV_X64_REGISTER_RTIT_ADDR0A: hv_register_name = 529408;
pub const hv_register_name_HV_X64_REGISTER_APIC_ID: hv_register_name = 542722;
pub const hv_register_name_HV_X64_REGISTER_APIC_VERSION: hv_register_name = 542723;
pub const hv_register_name_HV_X64_REGISTER_HYPERCALL: hv_register_name = 589825;
pub const hv_register_name_HV_X64_REGISTER_SYNTHETIC_EOI: hv_register_name = 589840;
pub const hv_register_name_HV_X64_REGISTER_SYNTHETIC_ICR: hv_register_name = 589841;
pub const hv_register_name_HV_X64_REGISTER_SYNTHETIC_TPR: hv_register_name = 589842;
pub const hv_register_name_HV_X64_REGISTER_REG_PAGE: hv_register_name = 589852;
pub const hv_register_name_HV_X64_REGISTER_GHCB: hv_register_name = 589849;
pub const hv_register_name_HV_X64_REGISTER_EMULATED_TIMER_PERIOD: hv_register_name = 589872;
pub const hv_register_name_HV_X64_REGISTER_EMULATED_TIMER_CONTROL: hv_register_name = 589873;
pub const hv_register_name_HV_X64_REGISTER_PM_TIMER_ASSIST: hv_register_name = 589874;
pub const hv_register_name_HV_X64_REGISTER_SEV_CONTROL: hv_register_name = 589888;
pub const hv_register_name_HV_X64_REGISTER_SEV_GHCB_GPA: hv_register_name = 589889;
pub const hv_register_name_HV_X64_REGISTER_SEV_DOORBELL_GPA: hv_register_name = 589890;
pub const hv_register_name_HV_X64_REGISTER_CR_INTERCEPT_CONTROL: hv_register_name = 917504;
pub const hv_register_name_HV_X64_REGISTER_CR_INTERCEPT_CR0_MASK: hv_register_name = 917505;
pub const hv_register_name_HV_X64_REGISTER_CR_INTERCEPT_CR4_MASK: hv_register_name = 917506;
pub const hv_register_name_HV_X64_REGISTER_CR_INTERCEPT_IA32_MISC_ENABLE_MASK: hv_register_name =
    917507;
pub type hv_register_name = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_explicit_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_explicit_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_explicit_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_explicit_suspend_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_explicit_suspend_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_explicit_suspend_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_explicit_suspend_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_explicit_suspend_register__bindgen_ty_1)
        )
    );
}
impl hv_explicit_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_explicit_suspend_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_explicit_suspend_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_explicit_suspend_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_explicit_suspend_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_explicit_suspend_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_explicit_suspend_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_explicit_suspend_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_explicit_suspend_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_intercept_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_intercept_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_intercept_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_intercept_suspend_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_intercept_suspend_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_intercept_suspend_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_intercept_suspend_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_intercept_suspend_register__bindgen_ty_1)
        )
    );
}
impl hv_intercept_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_intercept_suspend_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_intercept_suspend_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_intercept_suspend_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_intercept_suspend_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_intercept_suspend_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_intercept_suspend_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_suspend_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_intercept_suspend_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_dispatch_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_dispatch_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_dispatch_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_dispatch_suspend_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_dispatch_suspend_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_dispatch_suspend_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_dispatch_suspend_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_dispatch_suspend_register__bindgen_ty_1)
        )
    );
}
impl hv_dispatch_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_dispatch_suspend_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_dispatch_suspend_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_dispatch_suspend_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_dispatch_suspend_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_dispatch_suspend_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_dispatch_suspend_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_dispatch_suspend_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_dispatch_suspend_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_internal_activity_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_internal_activity_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_internal_activity_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_internal_activity_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_internal_activity_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_internal_activity_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_internal_activity_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_internal_activity_register__bindgen_ty_1)
        )
    );
}
impl hv_internal_activity_register__bindgen_ty_1 {
    #[inline]
    pub fn startup_suspend(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_startup_suspend(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn halt_suspend(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_halt_suspend(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_suspend(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_idle_suspend(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd_z(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd_z(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        startup_suspend: __u64,
        halt_suspend: __u64,
        idle_suspend: __u64,
        rsvd_z: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let startup_suspend: u64 = unsafe { ::std::mem::transmute(startup_suspend) };
            startup_suspend as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let halt_suspend: u64 = unsafe { ::std::mem::transmute(halt_suspend) };
            halt_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let idle_suspend: u64 = unsafe { ::std::mem::transmute(idle_suspend) };
            idle_suspend as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let rsvd_z: u64 = unsafe { ::std::mem::transmute(rsvd_z) };
            rsvd_z as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_internal_activity_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_internal_activity_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_internal_activity_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_internal_activity_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_internal_activity_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_internal_activity_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_internal_activity_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_internal_activity_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_interrupt_state_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_interrupt_state_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_interrupt_state_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_interrupt_state_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_interrupt_state_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_interrupt_state_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_interrupt_state_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_interrupt_state_register__bindgen_ty_1)
        )
    );
}
impl hv_x64_interrupt_state_register__bindgen_ty_1 {
    #[inline]
    pub fn interrupt_shadow(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_interrupt_shadow(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nmi_masked(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nmi_masked(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt_shadow: __u64,
        nmi_masked: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt_shadow: u64 = unsafe { ::std::mem::transmute(interrupt_shadow) };
            interrupt_shadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nmi_masked: u64 = unsafe { ::std::mem::transmute(nmi_masked) };
            nmi_masked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_interrupt_state_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_interrupt_state_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_interrupt_state_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_interrupt_state_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_interrupt_state_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_interrupt_state_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interrupt_state_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_interrupt_state_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_pending_exception_event {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_x64_pending_exception_event__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_pending_exception_event__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub error_code: __u32,
    pub exception_parameter: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_pending_exception_event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_pending_exception_event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_exception_event__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_exception_event__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1),
            "::",
            stringify!(exception_parameter)
        )
    );
}
impl hv_x64_pending_exception_event__bindgen_ty_1 {
    #[inline]
    pub fn event_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_event_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn event_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn deliver_error_code(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deliver_error_code(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn vector(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        event_pending: __u32,
        event_type: __u32,
        reserved0: __u32,
        deliver_error_code: __u32,
        reserved1: __u32,
        vector: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let event_pending: u32 = unsafe { ::std::mem::transmute(event_pending) };
            event_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let event_type: u32 = unsafe { ::std::mem::transmute(event_type) };
            event_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let deliver_error_code: u32 = unsafe { ::std::mem::transmute(deliver_error_code) };
            deliver_error_code as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_pending_exception_event() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_pending_exception_event> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_exception_event>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_pending_exception_event))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_exception_event>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_pending_exception_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_exception_event),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_pending_exception_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_pending_virtualization_fault_event {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_x64_pending_virtualization_fault_event__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_pending_virtualization_fault_event__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub code: __u32,
    pub parameter1: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_pending_virtualization_fault_event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_pending_virtualization_fault_event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_virtualization_fault_event__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_virtualization_fault_event__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1),
            "::",
            stringify!(parameter1)
        )
    );
}
impl hv_x64_pending_virtualization_fault_event__bindgen_ty_1 {
    #[inline]
    pub fn event_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_event_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn event_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn parameter0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_parameter0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        event_pending: __u32,
        event_type: __u32,
        reserved0: __u32,
        reserved1: __u32,
        parameter0: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let event_pending: u32 = unsafe { ::std::mem::transmute(event_pending) };
            event_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let event_type: u32 = unsafe { ::std::mem::transmute(event_type) };
            event_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let parameter0: u32 = unsafe { ::std::mem::transmute(parameter0) };
            parameter0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_pending_virtualization_fault_event() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_pending_virtualization_fault_event> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_virtualization_fault_event>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_virtualization_fault_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_virtualization_fault_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_virtualization_fault_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_virtualization_fault_event),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_pending_virtualization_fault_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_pending_interruption_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_pending_interruption_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_pending_interruption_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub error_code: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_pending_interruption_register__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_pending_interruption_register__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_interruption_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_interruption_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_interruption_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_interruption_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_interruption_register__bindgen_ty_1),
            "::",
            stringify!(error_code)
        )
    );
}
impl hv_x64_pending_interruption_register__bindgen_ty_1 {
    #[inline]
    pub fn interruption_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interruption_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interruption_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_interruption_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn deliver_error_code(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deliver_error_code(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instruction_length(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_instruction_length(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nested_event(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nested_event(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn interruption_vector(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_interruption_vector(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interruption_pending: __u32,
        interruption_type: __u32,
        deliver_error_code: __u32,
        instruction_length: __u32,
        nested_event: __u32,
        reserved: __u32,
        interruption_vector: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interruption_pending: u32 = unsafe { ::std::mem::transmute(interruption_pending) };
            interruption_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let interruption_type: u32 = unsafe { ::std::mem::transmute(interruption_type) };
            interruption_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let deliver_error_code: u32 = unsafe { ::std::mem::transmute(deliver_error_code) };
            deliver_error_code as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let instruction_length: u32 = unsafe { ::std::mem::transmute(instruction_length) };
            instruction_length as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let nested_event: u32 = unsafe { ::std::mem::transmute(nested_event) };
            nested_event as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let interruption_vector: u32 = unsafe { ::std::mem::transmute(interruption_vector) };
            interruption_vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_pending_interruption_register() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_pending_interruption_register> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_interruption_register>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_interruption_register)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_interruption_register>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_interruption_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_interruption_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_pending_interruption_register {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_sev_control {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_register_sev_control__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_register_sev_control__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_register_sev_control__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_sev_control__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_register_sev_control__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_sev_control__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_sev_control__bindgen_ty_1)
        )
    );
}
impl hv_x64_register_sev_control__bindgen_ty_1 {
    #[inline]
    pub fn enable_encrypted_state(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_encrypted_state(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn vmsa_gpa_page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_vmsa_gpa_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_encrypted_state: __u64,
        reserved_z: __u64,
        vmsa_gpa_page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_encrypted_state: u64 =
                unsafe { ::std::mem::transmute(enable_encrypted_state) };
            enable_encrypted_state as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reserved_z: u64 = unsafe { ::std::mem::transmute(reserved_z) };
            reserved_z as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let vmsa_gpa_page_number: u64 = unsafe { ::std::mem::transmute(vmsa_gpa_page_number) };
            vmsa_gpa_page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_register_sev_control() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_register_sev_control> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_sev_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_register_sev_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_sev_control>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_register_sev_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_sev_control),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_register_sev_control {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_register_value {
    pub reg128: hv_u128,
    pub reg64: __u64,
    pub reg32: __u32,
    pub reg16: __u16,
    pub reg8: __u8,
    pub fp: hv_x64_fp_register,
    pub fp_control_status: hv_x64_fp_control_status_register,
    pub xmm_control_status: hv_x64_xmm_control_status_register,
    pub segment: hv_x64_segment_register,
    pub table: hv_x64_table_register,
    pub explicit_suspend: hv_explicit_suspend_register,
    pub intercept_suspend: hv_intercept_suspend_register,
    pub dispatch_suspend: hv_dispatch_suspend_register,
    pub internal_activity: hv_internal_activity_register,
    pub interrupt_state: hv_x64_interrupt_state_register,
    pub pending_interruption: hv_x64_pending_interruption_register,
    pub npiep_config: hv_x64_msr_npiep_config_contents,
    pub pending_exception_event: hv_x64_pending_exception_event,
    pub pending_virtualization_fault_event: hv_x64_pending_virtualization_fault_event,
    pub sev_control: hv_x64_register_sev_control,
}
#[test]
fn bindgen_test_layout_hv_register_value() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_value>(),
        16usize,
        concat!("Size of: ", stringify!(hv_register_value))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_value>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_register_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_control_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(fp_control_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm_control_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(xmm_control_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).explicit_suspend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(explicit_suspend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_suspend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(intercept_suspend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch_suspend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(dispatch_suspend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_activity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(internal_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(interrupt_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_interruption) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(pending_interruption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npiep_config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(npiep_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_exception_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(pending_exception_event)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pending_virtualization_fault_event) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(pending_virtualization_fault_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sev_control) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(sev_control)
        )
    );
}
impl Default for hv_register_value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_register_assoc {
    pub name: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
    pub value: hv_register_value,
}
#[test]
fn bindgen_test_layout_hv_register_assoc() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_assoc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_assoc>(),
        32usize,
        concat!("Size of: ", stringify!(hv_register_assoc))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_assoc>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_register_assoc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(value)
        )
    );
}
impl Default for hv_register_assoc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_get_vp_registers {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub input_vtl: hv_input_vtl,
    pub rsvd_z8: __u8,
    pub rsvd_z16: __u16,
    pub names: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_hv_input_get_vp_registers() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_vp_registers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_vp_registers>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_get_vp_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_vp_registers>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_get_vp_registers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_registers),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_registers),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_registers),
            "::",
            stringify!(input_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_z8) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_registers),
            "::",
            stringify!(rsvd_z8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_z16) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_registers),
            "::",
            stringify!(rsvd_z16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_registers),
            "::",
            stringify!(names)
        )
    );
}
impl Default for hv_input_get_vp_registers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_set_vp_registers {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub input_vtl: hv_input_vtl,
    pub rsvd_z8: __u8,
    pub rsvd_z16: __u16,
    pub elements: __IncompleteArrayField<hv_register_assoc>,
}
#[test]
fn bindgen_test_layout_hv_input_set_vp_registers() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_set_vp_registers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_set_vp_registers>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_set_vp_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_set_vp_registers>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_set_vp_registers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_registers),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_registers),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_registers),
            "::",
            stringify!(input_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_z8) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_registers),
            "::",
            stringify!(rsvd_z8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_z16) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_registers),
            "::",
            stringify!(rsvd_z16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_registers),
            "::",
            stringify!(elements)
        )
    );
}
impl Default for hv_input_set_vp_registers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_send_ipi {
    pub vector: __u32,
    pub reserved: __u32,
    pub cpu_mask: __u64,
}
#[test]
fn bindgen_test_layout_hv_send_ipi() {
    const UNINIT: ::std::mem::MaybeUninit<hv_send_ipi> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_send_ipi>(),
        16usize,
        concat!("Size of: ", stringify!(hv_send_ipi))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_send_ipi>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_send_ipi))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_send_ipi),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_send_ipi),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_send_ipi),
            "::",
            stringify!(cpu_mask)
        )
    );
}
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_IO_PORT: hv_intercept_type = 0;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_MSR: hv_intercept_type = 1;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_CPUID: hv_intercept_type = 2;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_EXCEPTION: hv_intercept_type = 3;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_RESERVED0: hv_intercept_type = 4;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_MMIO: hv_intercept_type = 5;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_GLOBAL_CPUID: hv_intercept_type = 6;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_APIC_SMI: hv_intercept_type = 7;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_HYPERCALL: hv_intercept_type = 8;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_APIC_INIT_SIPI: hv_intercept_type = 9;
pub const hv_intercept_type_HV_INTERCEPT_MC_UPDATE_PATCH_LEVEL_MSR_READ: hv_intercept_type = 10;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_APIC_WRITE: hv_intercept_type = 11;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_MSR_INDEX: hv_intercept_type = 12;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_MAX: hv_intercept_type = 13;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_INVALID: hv_intercept_type = 4294967295;
pub type hv_intercept_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_intercept_parameters {
    pub as_uint64: __u64,
    pub io_port: __u16,
    pub cpuid_index: __u32,
    pub apic_write_mask: __u32,
    pub exception_vector: __u16,
    pub msr_index: __u32,
}
#[test]
fn bindgen_test_layout_hv_intercept_parameters() {
    const UNINIT: ::std::mem::MaybeUninit<hv_intercept_parameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_intercept_parameters>(),
        8usize,
        concat!("Size of: ", stringify!(hv_intercept_parameters))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_intercept_parameters>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_intercept_parameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(as_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(io_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuid_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(cpuid_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_write_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(apic_write_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_vector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(exception_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msr_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(msr_index)
        )
    );
}
impl Default for hv_intercept_parameters {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_install_intercept {
    pub partition_id: __u64,
    pub access_type: __u32,
    pub intercept_type: __u32,
    pub intercept_parameter: hv_intercept_parameters,
}
#[test]
fn bindgen_test_layout_hv_input_install_intercept() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_install_intercept> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_install_intercept>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_install_intercept))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_install_intercept>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_install_intercept))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_install_intercept),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_install_intercept),
            "::",
            stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_install_intercept),
            "::",
            stringify!(intercept_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_parameter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_install_intercept),
            "::",
            stringify!(intercept_parameter)
        )
    );
}
impl Default for hv_input_install_intercept {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_eventlog_type_HV_EVENT_LOG_TYPE_GLOBAL_SYSTEM_EVENTS: hv_eventlog_type = 0;
pub const hv_eventlog_type_HV_EVENT_LOG_TYPE_LOCAL_DIAGNOSTICS: hv_eventlog_type = 1;
pub const hv_eventlog_type_HV_EVENT_LOG_TYPE_SYSTEM_DIAGNOSTICS: hv_eventlog_type = 2;
pub type hv_eventlog_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_sev_ghcb {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_register_sev_ghcb__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_register_sev_ghcb__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_register_sev_ghcb__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_sev_ghcb__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_register_sev_ghcb__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_sev_ghcb__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_sev_ghcb__bindgen_ty_1)
        )
    );
}
impl hv_x64_register_sev_ghcb__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedz(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reservedz(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: __u64,
        reservedz: __u64,
        page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reservedz: u64 = unsafe { ::std::mem::transmute(reservedz) };
            reservedz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let page_number: u64 = unsafe { ::std::mem::transmute(page_number) };
            page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_register_sev_ghcb() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_register_sev_ghcb> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_sev_ghcb>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_register_sev_ghcb))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_sev_ghcb>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_register_sev_ghcb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_sev_ghcb),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_register_sev_ghcb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_sev_hv_doorbell {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_register_sev_hv_doorbell__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_register_sev_hv_doorbell__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_register_sev_hv_doorbell__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_sev_hv_doorbell__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_register_sev_hv_doorbell__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_sev_hv_doorbell__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_sev_hv_doorbell__bindgen_ty_1)
        )
    );
}
impl hv_x64_register_sev_hv_doorbell__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedz(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_reservedz(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: __u64,
        reservedz: __u64,
        page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let reservedz: u64 = unsafe { ::std::mem::transmute(reservedz) };
            reservedz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let page_number: u64 = unsafe { ::std::mem::transmute(page_number) };
            page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_register_sev_hv_doorbell() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_register_sev_hv_doorbell> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_sev_hv_doorbell>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_register_sev_hv_doorbell))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_sev_hv_doorbell>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_register_sev_hv_doorbell))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_sev_hv_doorbell),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_register_sev_hv_doorbell {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_FAULT:
    hv_unimplemented_msr_action = 0;
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_IGNORE_WRITE_READ_ZERO:
    hv_unimplemented_msr_action = 1;
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_COUNT:
    hv_unimplemented_msr_action = 2;
pub type hv_unimplemented_msr_action = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_connection_id {
    pub asu32: __u32,
    pub u: hv_connection_id__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_connection_id__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_connection_id__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_connection_id__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_connection_id__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_id__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_connection_id__bindgen_ty_1))
    );
}
impl hv_connection_id__bindgen_ty_1 {
    #[inline]
    pub fn id(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(id: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_connection_id() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_id>(),
        4usize,
        concat!("Size of: ", stringify!(hv_connection_id))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_id>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_connection_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asu32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_id),
            "::",
            stringify!(asu32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_id),
            "::",
            stringify!(u)
        )
    );
}
impl Default for hv_connection_id {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_unmap_gpa_pages {
    pub target_partition_id: __u64,
    pub target_gpa_base: __u64,
    pub unmap_flags: __u32,
    pub padding: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_unmap_gpa_pages() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_unmap_gpa_pages> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_unmap_gpa_pages>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_unmap_gpa_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_unmap_gpa_pages>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_unmap_gpa_pages))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_gpa_pages),
            "::",
            stringify!(target_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_gpa_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_gpa_pages),
            "::",
            stringify!(target_gpa_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmap_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_gpa_pages),
            "::",
            stringify!(unmap_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_gpa_pages),
            "::",
            stringify!(padding)
        )
    );
}
pub const hv_generic_set_format_HV_GENERIC_SET_SPARSE_4K: hv_generic_set_format = 0;
pub const hv_generic_set_format_HV_GENERIC_SET_ALL: hv_generic_set_format = 1;
pub type hv_generic_set_format = ::std::os::raw::c_uint;
pub const hv_scheduler_type_HV_SCHEDULER_TYPE_LP: hv_scheduler_type = 1;
pub const hv_scheduler_type_HV_SCHEDULER_TYPE_LP_SMT: hv_scheduler_type = 2;
pub const hv_scheduler_type_HV_SCHEDULER_TYPE_CORE_SMT: hv_scheduler_type = 3;
pub const hv_scheduler_type_HV_SCHEDULER_TYPE_ROOT: hv_scheduler_type = 4;
pub const hv_scheduler_type_HV_SCHEDULER_TYPE_MAX: hv_scheduler_type = 5;
pub type hv_scheduler_type = ::std::os::raw::c_uint;
pub const hv_stats_object_type_HV_STATS_OBJECT_HYPERVISOR: hv_stats_object_type = 1;
pub const hv_stats_object_type_HV_STATS_OBJECT_LOGICAL_PROCESSOR: hv_stats_object_type = 2;
pub const hv_stats_object_type_HV_STATS_OBJECT_PARTITION: hv_stats_object_type = 65537;
pub const hv_stats_object_type_HV_STATS_OBJECT_VP: hv_stats_object_type = 65538;
pub type hv_stats_object_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_stats_object_identity {
    pub hv: hv_stats_object_identity__bindgen_ty_1,
    pub lp: hv_stats_object_identity__bindgen_ty_2,
    pub partition: hv_stats_object_identity__bindgen_ty_3,
    pub vp: hv_stats_object_identity__bindgen_ty_4,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stats_object_identity__bindgen_ty_1 {
    pub reserved: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_hv_stats_object_identity__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stats_object_identity__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stats_object_identity__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_stats_object_identity__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_object_identity__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_stats_object_identity__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stats_object_identity__bindgen_ty_2 {
    pub lp_index: __u32,
    pub reserved: [__u8; 12usize],
}
#[test]
fn bindgen_test_layout_hv_stats_object_identity__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stats_object_identity__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stats_object_identity__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_stats_object_identity__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_object_identity__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_stats_object_identity__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_2),
            "::",
            stringify!(lp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stats_object_identity__bindgen_ty_3 {
    pub partition_id: __u64,
    pub reserved: [__u8; 4usize],
    pub flags: __u16,
    pub reserved1: [__u8; 2usize],
}
#[test]
fn bindgen_test_layout_hv_stats_object_identity__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stats_object_identity__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stats_object_identity__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_stats_object_identity__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_object_identity__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_stats_object_identity__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_3),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_3),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_3),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_3),
            "::",
            stringify!(reserved1)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stats_object_identity__bindgen_ty_4 {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub flags: __u16,
    pub reserved: [__u8; 2usize],
}
#[test]
fn bindgen_test_layout_hv_stats_object_identity__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stats_object_identity__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stats_object_identity__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_stats_object_identity__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_object_identity__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_stats_object_identity__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_4),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_4),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_4),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_stats_object_identity() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stats_object_identity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stats_object_identity>(),
        16usize,
        concat!("Size of: ", stringify!(hv_stats_object_identity))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_object_identity>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_stats_object_identity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity),
            "::",
            stringify!(hv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity),
            "::",
            stringify!(lp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity),
            "::",
            stringify!(partition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_object_identity),
            "::",
            stringify!(vp)
        )
    );
}
impl Default for hv_stats_object_identity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PRIVILEGE_FLAGS:
    hv_partition_property_code = 65536;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SYNTHETIC_PROC_FEATURES:
    hv_partition_property_code = 65537;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SUSPEND: hv_partition_property_code =
    131072;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_RESERVE: hv_partition_property_code =
    131073;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_CAP: hv_partition_property_code =
    131074;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_WEIGHT: hv_partition_property_code =
    131075;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_GROUP_ID:
    hv_partition_property_code = 131076;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_TIME_FREEZE: hv_partition_property_code =
    196611;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_REFERENCE_TIME:
    hv_partition_property_code = 196613;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEBUG_CHANNEL_ID:
    hv_partition_property_code = 262144;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VIRTUAL_TLB_PAGE_COUNT:
    hv_partition_property_code = 327680;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VSM_CONFIG: hv_partition_property_code =
    327681;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ZERO_MEMORY_ON_RESET:
    hv_partition_property_code = 327682;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSORS_PER_SOCKET:
    hv_partition_property_code = 327683;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_NESTED_TLB_SIZE:
    hv_partition_property_code = 327684;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GPA_PAGE_ACCESS_TRACKING:
    hv_partition_property_code = 327685;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VSM_PERMISSIONS_DIRTY_SINCE_LAST_QUERY : hv_partition_property_code = 327686 ;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SGX_LAUNCH_CONTROL_CONFIG:
    hv_partition_property_code = 327687;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL0:
    hv_partition_property_code = 327688;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL1:
    hv_partition_property_code = 327689;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL2:
    hv_partition_property_code = 327690;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL3:
    hv_partition_property_code = 327691;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_STATE:
    hv_partition_property_code = 327692;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_CONTROL:
    hv_partition_property_code = 327693;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ALLOCATION_ID:
    hv_partition_property_code = 327694;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_MONITORING_ID:
    hv_partition_property_code = 327695;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_IMPLEMENTED_PHYSICAL_ADDRESS_BITS:
    hv_partition_property_code = 327696;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_NON_ARCHITECTURAL_CORE_SHARING:
    hv_partition_property_code = 327697;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_HYPERCALL_DOORBELL_PAGE:
    hv_partition_property_code = 327698;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_POLICY:
    hv_partition_property_code = 327700;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_UNIMPLEMENTED_MSR_ACTION:
    hv_partition_property_code = 327703;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SEV_VMGEXIT_OFFLOADS:
    hv_partition_property_code = 327714;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_VENDOR:
    hv_partition_property_code = 393216;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES_DEPRECATED:
    hv_partition_property_code = 393217;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_XSAVE_FEATURES:
    hv_partition_property_code = 393218;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_CL_FLUSH_SIZE:
    hv_partition_property_code = 393219;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ENLIGHTENMENT_MODIFICATIONS:
    hv_partition_property_code = 393220;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_COMPATIBILITY_VERSION:
    hv_partition_property_code = 393221;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PHYSICAL_ADDRESS_WIDTH:
    hv_partition_property_code = 393222;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_XSAVE_STATES:
    hv_partition_property_code = 393223;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_MAX_XSAVE_DATA_SIZE:
    hv_partition_property_code = 393224;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_CLOCK_FREQUENCY:
    hv_partition_property_code = 393225;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES0:
    hv_partition_property_code = 393226;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES1:
    hv_partition_property_code = 393227;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GUEST_OS_ID: hv_partition_property_code =
    458752;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_VIRTUALIZATION_FEATURES:
    hv_partition_property_code = 524288;
pub type hv_partition_property_code = ::std::os::raw::c_uint;
pub const hv_sleep_state_HV_SLEEP_STATE_S1: hv_sleep_state = 1;
pub const hv_sleep_state_HV_SLEEP_STATE_S2: hv_sleep_state = 2;
pub const hv_sleep_state_HV_SLEEP_STATE_S3: hv_sleep_state = 3;
pub const hv_sleep_state_HV_SLEEP_STATE_S4: hv_sleep_state = 4;
pub const hv_sleep_state_HV_SLEEP_STATE_S5: hv_sleep_state = 5;
pub const hv_sleep_state_HV_SLEEP_STATE_LOCK: hv_sleep_state = 6;
pub type hv_sleep_state = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_enter_sleep_state {
    pub sleep_state: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_enter_sleep_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_enter_sleep_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_enter_sleep_state>(),
        4usize,
        concat!("Size of: ", stringify!(hv_input_enter_sleep_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_enter_sleep_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_enter_sleep_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sleep_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_enter_sleep_state),
            "::",
            stringify!(sleep_state)
        )
    );
}
pub const hv_system_property_HV_SYSTEM_PROPERTY_SLEEP_STATE: hv_system_property = 3;
pub const hv_system_property_HV_SYSTEM_PROPERTY_SCHEDULER_TYPE: hv_system_property = 15;
pub const hv_system_property_HV_DYNAMIC_PROCESSOR_FEATURE_PROPERTY: hv_system_property = 21;
pub const hv_system_property_HV_SYSTEM_PROPERTY_DIAGOSTICS_LOG_BUFFERS: hv_system_property = 28;
pub const hv_system_property_HV_SYSTEM_PROPERTY_CRASHDUMPAREA: hv_system_property = 47;
pub const hv_system_property_HV_SYSTEM_PROPERTY_DEVIRT_TRAMP_PA: hv_system_property = 52;
pub type hv_system_property = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_pfn_range {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_pfn_range__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_pfn_range__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_pfn_range__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_pfn_range__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_pfn_range__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_pfn_range__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_pfn_range__bindgen_ty_1))
    );
}
impl hv_pfn_range__bindgen_ty_1 {
    #[inline]
    pub fn base_pfn(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_base_pfn(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub fn add_pfns(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_add_pfns(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(base_pfn: __u64, add_pfns: __u64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 40u8, {
            let base_pfn: u64 = unsafe { ::std::mem::transmute(base_pfn) };
            base_pfn as u64
        });
        __bindgen_bitfield_unit.set(40usize, 24u8, {
            let add_pfns: u64 = unsafe { ::std::mem::transmute(add_pfns) };
            add_pfns as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_pfn_range() {
    const UNINIT: ::std::mem::MaybeUninit<hv_pfn_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_pfn_range>(),
        8usize,
        concat!("Size of: ", stringify!(hv_pfn_range))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_pfn_range>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_pfn_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_pfn_range),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_pfn_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_sleep_state_info {
    pub sleep_state: __u32,
    pub pm1a_slp_typ: __u8,
    pub pm1b_slp_typ: __u8,
}
#[test]
fn bindgen_test_layout_hv_sleep_state_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_sleep_state_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_sleep_state_info>(),
        6usize,
        concat!("Size of: ", stringify!(hv_sleep_state_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_sleep_state_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_sleep_state_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sleep_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_sleep_state_info),
            "::",
            stringify!(sleep_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pm1a_slp_typ) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_sleep_state_info),
            "::",
            stringify!(pm1a_slp_typ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pm1b_slp_typ) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_sleep_state_info),
            "::",
            stringify!(pm1b_slp_typ)
        )
    );
}
pub const hv_snp_status_HV_SNP_STATUS_NONE: hv_snp_status = 0;
pub const hv_snp_status_HV_SNP_STATUS_AVAILABLE: hv_snp_status = 1;
pub const hv_snp_status_HV_SNP_STATUS_INCOMPATIBLE: hv_snp_status = 2;
pub const hv_snp_status_HV_SNP_STATUS_PSP_UNAVAILABLE: hv_snp_status = 3;
pub const hv_snp_status_HV_SNP_STATUS_PSP_INIT_FAILED: hv_snp_status = 4;
pub const hv_snp_status_HV_SNP_STATUS_PSP_BAD_FW_VERSION: hv_snp_status = 5;
pub const hv_snp_status_HV_SNP_STATUS_BAD_CONFIGURATION: hv_snp_status = 6;
pub const hv_snp_status_HV_SNP_STATUS_PSP_FW_UPDATE_IN_PROGRESS: hv_snp_status = 7;
pub const hv_snp_status_HV_SNP_STATUS_PSP_RB_INIT_FAILED: hv_snp_status = 8;
pub const hv_snp_status_HV_SNP_STATUS_PSP_PLATFORM_STATUS_FAILED: hv_snp_status = 9;
pub const hv_snp_status_HV_SNP_STATUS_PSP_INIT_LATE_FAILED: hv_snp_status = 10;
pub type hv_snp_status = ::std::os::raw::c_uint;
pub const hv_dynamic_processor_feature_property_HV_X64_DYNAMIC_PROCESSOR_FEATURE_MAX_ENCRYPTED_PARTITIONS : hv_dynamic_processor_feature_property = 13 ;
pub const hv_dynamic_processor_feature_property_HV_X64_DYNAMIC_PROCESSOR_FEATURE_SNP_STATUS:
    hv_dynamic_processor_feature_property = 16;
pub type hv_dynamic_processor_feature_property = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_get_system_property {
    pub property_id: __u32,
    pub reserved: __u32,
    pub __bindgen_anon_1: hv_input_get_system_property__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_input_get_system_property__bindgen_ty_1 {
    pub as_uint64: __u64,
    pub hv_processor_feature: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_get_system_property__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_system_property__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_system_property__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_input_get_system_property__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_system_property__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_get_system_property__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_system_property__bindgen_ty_1),
            "::",
            stringify!(as_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_processor_feature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_system_property__bindgen_ty_1),
            "::",
            stringify!(hv_processor_feature)
        )
    );
}
impl Default for hv_input_get_system_property__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_input_get_system_property() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_system_property> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_system_property>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_get_system_property))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_system_property>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_get_system_property))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_system_property),
            "::",
            stringify!(property_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_system_property),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hv_input_get_system_property {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_system_diag_log_buffer_config {
    pub buffer_count: __u32,
    pub buffer_size_in_pages: __u32,
}
#[test]
fn bindgen_test_layout_hv_system_diag_log_buffer_config() {
    const UNINIT: ::std::mem::MaybeUninit<hv_system_diag_log_buffer_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_system_diag_log_buffer_config>(),
        8usize,
        concat!("Size of: ", stringify!(hv_system_diag_log_buffer_config))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_system_diag_log_buffer_config>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_system_diag_log_buffer_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_system_diag_log_buffer_config),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_in_pages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_system_diag_log_buffer_config),
            "::",
            stringify!(buffer_size_in_pages)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_get_system_property {
    pub __bindgen_anon_1: hv_output_get_system_property__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_output_get_system_property__bindgen_ty_1 {
    pub scheduler_type: __u32,
    pub hv_diagbuf_info: hv_system_diag_log_buffer_config,
    pub hv_processor_feature_value: __u64,
    pub hv_cda_info: hv_pfn_range,
    pub hv_tramp_pa: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_get_system_property__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_get_system_property__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_system_property__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_output_get_system_property__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_system_property__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_output_get_system_property__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheduler_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_system_property__bindgen_ty_1),
            "::",
            stringify!(scheduler_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_diagbuf_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_system_property__bindgen_ty_1),
            "::",
            stringify!(hv_diagbuf_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_processor_feature_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_system_property__bindgen_ty_1),
            "::",
            stringify!(hv_processor_feature_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_cda_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_system_property__bindgen_ty_1),
            "::",
            stringify!(hv_cda_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_tramp_pa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_system_property__bindgen_ty_1),
            "::",
            stringify!(hv_tramp_pa)
        )
    );
}
impl Default for hv_output_get_system_property__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_output_get_system_property() {
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_system_property>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_get_system_property))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_system_property>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_get_system_property))
    );
}
impl Default for hv_output_get_system_property {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_set_system_property {
    pub property_id: __u32,
    pub reserved: __u32,
    pub __bindgen_anon_1: hv_input_set_system_property__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_input_set_system_property__bindgen_ty_1 {
    pub set_sleep_state_info: hv_sleep_state_info,
}
#[test]
fn bindgen_test_layout_hv_input_set_system_property__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_set_system_property__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_set_system_property__bindgen_ty_1>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(hv_input_set_system_property__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_set_system_property__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_set_system_property__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_sleep_state_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_system_property__bindgen_ty_1),
            "::",
            stringify!(set_sleep_state_info)
        )
    );
}
impl Default for hv_input_set_system_property__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_input_set_system_property() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_set_system_property> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_set_system_property>(),
        14usize,
        concat!("Size of: ", stringify!(hv_input_set_system_property))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_set_system_property>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_set_system_property))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_system_property),
            "::",
            stringify!(property_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_system_property),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hv_input_set_system_property {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_map_stats_page {
    pub type_: __u32,
    pub padding: __u32,
    pub identity: hv_stats_object_identity,
}
#[test]
fn bindgen_test_layout_hv_input_map_stats_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_map_stats_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_map_stats_page>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_map_stats_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_map_stats_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_map_stats_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_stats_page),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_stats_page),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_stats_page),
            "::",
            stringify!(identity)
        )
    );
}
impl Default for hv_input_map_stats_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_map_stats_page {
    pub map_location: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_map_stats_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_map_stats_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_map_stats_page>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_map_stats_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_map_stats_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_map_stats_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_map_stats_page),
            "::",
            stringify!(map_location)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_unmap_stats_page {
    pub type_: __u32,
    pub padding: __u32,
    pub identity: hv_stats_object_identity,
}
#[test]
fn bindgen_test_layout_hv_input_unmap_stats_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_unmap_stats_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_unmap_stats_page>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_unmap_stats_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_unmap_stats_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_unmap_stats_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_stats_page),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_stats_page),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_stats_page),
            "::",
            stringify!(identity)
        )
    );
}
impl Default for hv_input_unmap_stats_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_proximity_domain_flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_proximity_domain_flags() {
    assert_eq!(
        ::std::mem::size_of::<hv_proximity_domain_flags>(),
        4usize,
        concat!("Size of: ", stringify!(hv_proximity_domain_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_proximity_domain_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_proximity_domain_flags))
    );
}
impl hv_proximity_domain_flags {
    #[inline]
    pub fn proximity_preferred(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proximity_preferred(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn proximity_info_valid(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proximity_info_valid(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        proximity_preferred: __u32,
        reserved: __u32,
        proximity_info_valid: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let proximity_preferred: u32 = unsafe { ::std::mem::transmute(proximity_preferred) };
            proximity_preferred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let proximity_info_valid: u32 = unsafe { ::std::mem::transmute(proximity_info_valid) };
            proximity_info_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_proximity_domain_info {
    pub __bindgen_anon_1: hv_proximity_domain_info__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_proximity_domain_info__bindgen_ty_1 {
    pub domain_id: __u32,
    pub flags: hv_proximity_domain_flags,
}
#[test]
fn bindgen_test_layout_hv_proximity_domain_info__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_proximity_domain_info__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_proximity_domain_info__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_proximity_domain_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_proximity_domain_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hv_proximity_domain_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_proximity_domain_info__bindgen_ty_1),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_proximity_domain_info__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_proximity_domain_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_proximity_domain_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_proximity_domain_info>(),
        8usize,
        concat!("Size of: ", stringify!(hv_proximity_domain_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_proximity_domain_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_proximity_domain_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_proximity_domain_info),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_proximity_domain_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_deposit_memory {
    pub partition_id: __u64,
    pub gpa_page_list: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_deposit_memory() {
    const UNINIT: ::std::mem::MaybeUninit<hv_deposit_memory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_deposit_memory>(),
        8usize,
        concat!("Size of: ", stringify!(hv_deposit_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_deposit_memory>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_deposit_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_deposit_memory),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa_page_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_deposit_memory),
            "::",
            stringify!(gpa_page_list)
        )
    );
}
impl Default for hv_deposit_memory {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_withdraw_memory {
    pub partition_id: __u64,
    pub proximity_domain_info: hv_proximity_domain_info,
}
#[test]
fn bindgen_test_layout_hv_input_withdraw_memory() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_withdraw_memory> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_withdraw_memory>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_withdraw_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_withdraw_memory>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_withdraw_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_withdraw_memory),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proximity_domain_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_withdraw_memory),
            "::",
            stringify!(proximity_domain_info)
        )
    );
}
impl Default for hv_input_withdraw_memory {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_output_withdraw_memory {
    pub gpa_page_list: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_output_withdraw_memory() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_withdraw_memory> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_withdraw_memory>(),
        0usize,
        concat!("Size of: ", stringify!(hv_output_withdraw_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_withdraw_memory>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_withdraw_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa_page_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_withdraw_memory),
            "::",
            stringify!(gpa_page_list)
        )
    );
}
impl Default for hv_output_withdraw_memory {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_map_gpa_pages {
    pub target_partition_id: __u64,
    pub target_gpa_base: __u64,
    pub map_flags: __u32,
    pub padding: __u32,
    pub source_gpa_page_list: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_input_map_gpa_pages() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_map_gpa_pages> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_map_gpa_pages>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_map_gpa_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_map_gpa_pages>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_map_gpa_pages))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_gpa_pages),
            "::",
            stringify!(target_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_gpa_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_gpa_pages),
            "::",
            stringify!(target_gpa_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_gpa_pages),
            "::",
            stringify!(map_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_gpa_pages),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_gpa_page_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_gpa_pages),
            "::",
            stringify!(source_gpa_page_list)
        )
    );
}
impl Default for hv_input_map_gpa_pages {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_gpa_page_access_state_flags {
    pub __bindgen_anon_1: hv_gpa_page_access_state_flags__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_gpa_page_access_state_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state_flags__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_gpa_page_access_state_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state_flags__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_gpa_page_access_state_flags__bindgen_ty_1)
        )
    );
}
impl hv_gpa_page_access_state_flags__bindgen_ty_1 {
    #[inline]
    pub fn clear_accessed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clear_accessed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_access(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_set_access(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clear_dirty(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clear_dirty(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_dirty(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_set_dirty(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clear_accessed: __u64,
        set_access: __u64,
        clear_dirty: __u64,
        set_dirty: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clear_accessed: u64 = unsafe { ::std::mem::transmute(clear_accessed) };
            clear_accessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let set_access: u64 = unsafe { ::std::mem::transmute(set_access) };
            set_access as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clear_dirty: u64 = unsafe { ::std::mem::transmute(clear_dirty) };
            clear_dirty as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let set_dirty: u64 = unsafe { ::std::mem::transmute(set_dirty) };
            set_dirty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state_flags() {
    const UNINIT: ::std::mem::MaybeUninit<hv_gpa_page_access_state_flags> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state_flags>(),
        8usize,
        concat!("Size of: ", stringify!(hv_gpa_page_access_state_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state_flags>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_access_state_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_gpa_page_access_state_flags),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_gpa_page_access_state_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_get_gpa_pages_access_state {
    pub partition_id: __u64,
    pub flags: hv_gpa_page_access_state_flags,
    pub hv_gpa_page_number: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_get_gpa_pages_access_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_gpa_pages_access_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_gpa_pages_access_state>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_get_gpa_pages_access_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_gpa_pages_access_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_get_gpa_pages_access_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_gpa_pages_access_state),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_gpa_pages_access_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_gpa_page_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_gpa_pages_access_state),
            "::",
            stringify!(hv_gpa_page_number)
        )
    );
}
impl Default for hv_input_get_gpa_pages_access_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_gpa_page_access_state {
    pub __bindgen_anon_1: hv_gpa_page_access_state__bindgen_ty_1,
    pub as_uint8: __u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_gpa_page_access_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_gpa_page_access_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_gpa_page_access_state__bindgen_ty_1)
        )
    );
}
impl hv_gpa_page_access_state__bindgen_ty_1 {
    #[inline]
    pub fn accessed(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_accessed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dirty(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dirty(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        accessed: __u8,
        dirty: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let accessed: u8 = unsafe { ::std::mem::transmute(accessed) };
            accessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dirty: u8 = unsafe { ::std::mem::transmute(dirty) };
            dirty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_gpa_page_access_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state>(),
        1usize,
        concat!("Size of: ", stringify!(hv_gpa_page_access_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_access_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_gpa_page_access_state),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_gpa_page_access_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_snp_guest_policy {
    pub __bindgen_anon_1: hv_snp_guest_policy__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_snp_guest_policy__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_snp_guest_policy__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_snp_guest_policy__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_snp_guest_policy__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_snp_guest_policy__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_snp_guest_policy__bindgen_ty_1)
        )
    );
}
impl hv_snp_guest_policy__bindgen_ty_1 {
    #[inline]
    pub fn minor_version(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_minor_version(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn major_version(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_major_version(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn smt_allowed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smt_allowed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vmpls_required(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vmpls_required(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn migration_agent_allowed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_migration_agent_allowed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_allowed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_debug_allowed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 44u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 44u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minor_version: __u64,
        major_version: __u64,
        smt_allowed: __u64,
        vmpls_required: __u64,
        migration_agent_allowed: __u64,
        debug_allowed: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let minor_version: u64 = unsafe { ::std::mem::transmute(minor_version) };
            minor_version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let major_version: u64 = unsafe { ::std::mem::transmute(major_version) };
            major_version as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let smt_allowed: u64 = unsafe { ::std::mem::transmute(smt_allowed) };
            smt_allowed as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let vmpls_required: u64 = unsafe { ::std::mem::transmute(vmpls_required) };
            vmpls_required as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let migration_agent_allowed: u64 =
                unsafe { ::std::mem::transmute(migration_agent_allowed) };
            migration_agent_allowed as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let debug_allowed: u64 = unsafe { ::std::mem::transmute(debug_allowed) };
            debug_allowed as u64
        });
        __bindgen_bitfield_unit.set(20usize, 44u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_snp_guest_policy() {
    const UNINIT: ::std::mem::MaybeUninit<hv_snp_guest_policy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_snp_guest_policy>(),
        8usize,
        concat!("Size of: ", stringify!(hv_snp_guest_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_snp_guest_policy>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_snp_guest_policy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_guest_policy),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_snp_guest_policy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_snp_id_block {
    pub launch_digest: [__u8; 48usize],
    pub family_id: [__u8; 16usize],
    pub image_id: [__u8; 16usize],
    pub version: __u32,
    pub guest_svn: __u32,
    pub policy: hv_snp_guest_policy,
}
#[test]
fn bindgen_test_layout_hv_snp_id_block() {
    const UNINIT: ::std::mem::MaybeUninit<hv_snp_id_block> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_snp_id_block>(),
        96usize,
        concat!("Size of: ", stringify!(hv_snp_id_block))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_snp_id_block>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_snp_id_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_block),
            "::",
            stringify!(launch_digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_block),
            "::",
            stringify!(family_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_block),
            "::",
            stringify!(image_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_block),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guest_svn) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_block),
            "::",
            stringify!(guest_svn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).policy) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_block),
            "::",
            stringify!(policy)
        )
    );
}
impl Default for hv_snp_id_block {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_snp_id_auth_info {
    pub id_key_algorithm: __u32,
    pub auth_key_algorithm: __u32,
    pub reserved0: [__u8; 56usize],
    pub id_block_signature: [__u8; 512usize],
    pub id_key: [__u8; 1028usize],
    pub reserved1: [__u8; 60usize],
    pub id_key_signature: [__u8; 512usize],
    pub author_key: [__u8; 1028usize],
}
#[test]
fn bindgen_test_layout_hv_snp_id_auth_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_snp_id_auth_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_snp_id_auth_info>(),
        3204usize,
        concat!("Size of: ", stringify!(hv_snp_id_auth_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_snp_id_auth_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_snp_id_auth_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_key_algorithm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(id_key_algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_key_algorithm) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(auth_key_algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_block_signature) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(id_block_signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_key) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(id_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        1604usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_key_signature) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(id_key_signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).author_key) as usize - ptr as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_snp_id_auth_info),
            "::",
            stringify!(author_key)
        )
    );
}
impl Default for hv_snp_id_auth_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_psp_launch_finish_data {
    pub id_block: hv_snp_id_block,
    pub id_auth_info: hv_snp_id_auth_info,
    pub host_data: [__u8; 32usize],
    pub id_block_enabled: __u8,
    pub author_key_enabled: __u8,
}
#[test]
fn bindgen_test_layout_hv_psp_launch_finish_data() {
    const UNINIT: ::std::mem::MaybeUninit<hv_psp_launch_finish_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_psp_launch_finish_data>(),
        3334usize,
        concat!("Size of: ", stringify!(hv_psp_launch_finish_data))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_psp_launch_finish_data>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_psp_launch_finish_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_launch_finish_data),
            "::",
            stringify!(id_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_auth_info) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_launch_finish_data),
            "::",
            stringify!(id_auth_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_data) as usize - ptr as usize },
        3300usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_launch_finish_data),
            "::",
            stringify!(host_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_block_enabled) as usize - ptr as usize },
        3332usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_launch_finish_data),
            "::",
            stringify!(id_block_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).author_key_enabled) as usize - ptr as usize },
        3333usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_launch_finish_data),
            "::",
            stringify!(author_key_enabled)
        )
    );
}
impl Default for hv_psp_launch_finish_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_partition_complete_isolated_import_data {
    pub reserved: __u64,
    pub psp_parameters: hv_psp_launch_finish_data,
}
#[test]
fn bindgen_test_layout_hv_partition_complete_isolated_import_data() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_complete_isolated_import_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_complete_isolated_import_data>(),
        3334usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_complete_isolated_import_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_complete_isolated_import_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_complete_isolated_import_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_complete_isolated_import_data),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psp_parameters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_complete_isolated_import_data),
            "::",
            stringify!(psp_parameters)
        )
    );
}
impl Default for hv_partition_complete_isolated_import_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_complete_isolated_import {
    pub partition_id: __u64,
    pub import_data: hv_partition_complete_isolated_import_data,
}
#[test]
fn bindgen_test_layout_hv_input_complete_isolated_import() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_complete_isolated_import> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_complete_isolated_import>(),
        3342usize,
        concat!("Size of: ", stringify!(hv_input_complete_isolated_import))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_complete_isolated_import>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_complete_isolated_import)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_complete_isolated_import),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).import_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_complete_isolated_import),
            "::",
            stringify!(import_data)
        )
    );
}
impl Default for hv_input_complete_isolated_import {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_crashdump_action_HV_CRASHDUMP_NONE: hv_crashdump_action = 0;
pub const hv_crashdump_action_HV_CRASHDUMP_SUSPEND_ALL_VPS: hv_crashdump_action = 1;
pub const hv_crashdump_action_HV_CRASHDUMP_PREPARE_FOR_STATE_SAVE: hv_crashdump_action = 2;
pub const hv_crashdump_action_HV_CRASHDUMP_STATE_SAVED: hv_crashdump_action = 3;
pub const hv_crashdump_action_HV_CRASHDUMP_ENTRY: hv_crashdump_action = 4;
pub type hv_crashdump_action = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_event_root_crashdump_input {
    pub crashdump_action: __u32,
}
#[test]
fn bindgen_test_layout_hv_partition_event_root_crashdump_input() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_event_root_crashdump_input> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_event_root_crashdump_input>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_event_root_crashdump_input)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_event_root_crashdump_input>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_event_root_crashdump_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crashdump_action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_event_root_crashdump_input),
            "::",
            stringify!(crashdump_action)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_disable_hyp_ex {
    pub rip: __u64,
    pub arg: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_disable_hyp_ex() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_disable_hyp_ex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_disable_hyp_ex>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_disable_hyp_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_disable_hyp_ex>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_disable_hyp_ex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_disable_hyp_ex),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_disable_hyp_ex),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_crashdump_area {
    pub version: __u32,
    pub __bindgen_anon_1: hv_crashdump_area__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_crashdump_area__bindgen_ty_1 {
    pub flags_as_uint32: __u32,
    pub __bindgen_anon_1: hv_crashdump_area__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_crashdump_area__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_crashdump_area__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_crashdump_area__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_crashdump_area__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_crashdump_area__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_crashdump_area__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl hv_crashdump_area__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cda_valid(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cda_valid(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cda_unused(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_cda_unused(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cda_valid: __u32,
        cda_unused: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cda_valid: u32 = unsafe { ::std::mem::transmute(cda_valid) };
            cda_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let cda_unused: u32 = unsafe { ::std::mem::transmute(cda_unused) };
            cda_unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_crashdump_area__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_crashdump_area__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_crashdump_area__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_crashdump_area__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_crashdump_area__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_crashdump_area__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_as_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_crashdump_area__bindgen_ty_1),
            "::",
            stringify!(flags_as_uint32)
        )
    );
}
impl Default for hv_crashdump_area__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_crashdump_area() {
    const UNINIT: ::std::mem::MaybeUninit<hv_crashdump_area> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_crashdump_area>(),
        8usize,
        concat!("Size of: ", stringify!(hv_crashdump_area))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_crashdump_area>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_crashdump_area))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_crashdump_area),
            "::",
            stringify!(version)
        )
    );
}
impl Default for hv_crashdump_area {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_event_commit_processor_indices_input {
    pub schedulable_processor_count: __u32,
}
#[test]
fn bindgen_test_layout_hv_partition_event_commit_processor_indices_input() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_event_commit_processor_indices_input> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_event_commit_processor_indices_input>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_event_commit_processor_indices_input)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_event_commit_processor_indices_input>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_event_commit_processor_indices_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schedulable_processor_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_event_commit_processor_indices_input),
            "::",
            stringify!(schedulable_processor_count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_event_input {
    pub crashdump_input: hv_partition_event_root_crashdump_input,
    pub commit_lp_indices_input: hv_partition_event_commit_processor_indices_input,
}
#[test]
fn bindgen_test_layout_hv_partition_event_input() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_event_input> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_event_input>(),
        4usize,
        concat!("Size of: ", stringify!(hv_partition_event_input))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_event_input>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_partition_event_input))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crashdump_input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_event_input),
            "::",
            stringify!(crashdump_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commit_lp_indices_input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_event_input),
            "::",
            stringify!(commit_lp_indices_input)
        )
    );
}
impl Default for hv_partition_event_input {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_partition_event_HV_PARTITION_EVENT_DEBUG_DEVICE_AVAILABLE: hv_partition_event = 1;
pub const hv_partition_event_HV_PARTITION_EVENT_ROOT_CRASHDUMP: hv_partition_event = 2;
pub const hv_partition_event_HV_PARTITION_EVENT_ACPI_REENABLED: hv_partition_event = 3;
pub const hv_partition_event_HV_PARTITION_ALL_LOGICAL_PROCESSORS_STARTED: hv_partition_event = 4;
pub const hv_partition_event_HV_PARTITION_COMMIT_LP_INDICES: hv_partition_event = 5;
pub type hv_partition_event = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_notify_partition_event {
    pub event: __u32,
    pub input: hv_partition_event_input,
}
#[test]
fn bindgen_test_layout_hv_input_notify_partition_event() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_notify_partition_event> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_notify_partition_event>(),
        8usize,
        concat!("Size of: ", stringify!(hv_input_notify_partition_event))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_notify_partition_event>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_notify_partition_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_notify_partition_event),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_notify_partition_event),
            "::",
            stringify!(input)
        )
    );
}
impl Default for hv_input_notify_partition_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_lp_startup_status {
    pub hv_status: __u64,
    pub substatus1: __u64,
    pub substatus2: __u64,
    pub substatus3: __u64,
    pub substatus4: __u64,
    pub substatus5: __u64,
    pub substatus6: __u64,
}
#[test]
fn bindgen_test_layout_hv_lp_startup_status() {
    const UNINIT: ::std::mem::MaybeUninit<hv_lp_startup_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_lp_startup_status>(),
        56usize,
        concat!("Size of: ", stringify!(hv_lp_startup_status))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_lp_startup_status>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_lp_startup_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(hv_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substatus1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(substatus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substatus2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(substatus2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substatus3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(substatus3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substatus4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(substatus4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substatus5) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(substatus5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substatus6) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_lp_startup_status),
            "::",
            stringify!(substatus6)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_add_logical_processor {
    pub lp_index: __u32,
    pub apic_id: __u32,
    pub proximity_domain_info: hv_proximity_domain_info,
}
#[test]
fn bindgen_test_layout_hv_input_add_logical_processor() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_add_logical_processor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_add_logical_processor>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_add_logical_processor))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_add_logical_processor>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_add_logical_processor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_add_logical_processor),
            "::",
            stringify!(lp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_add_logical_processor),
            "::",
            stringify!(apic_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proximity_domain_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_add_logical_processor),
            "::",
            stringify!(proximity_domain_info)
        )
    );
}
impl Default for hv_input_add_logical_processor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_add_logical_processor {
    pub startup_status: hv_lp_startup_status,
}
#[test]
fn bindgen_test_layout_hv_output_add_logical_processor() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_add_logical_processor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_add_logical_processor>(),
        56usize,
        concat!("Size of: ", stringify!(hv_output_add_logical_processor))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_add_logical_processor>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_add_logical_processor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startup_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_add_logical_processor),
            "::",
            stringify!(startup_status)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_get_logical_processor_run_time {
    pub lp_index: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_get_logical_processor_run_time() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_logical_processor_run_time> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_logical_processor_run_time>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_input_get_logical_processor_run_time)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_logical_processor_run_time>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_get_logical_processor_run_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_logical_processor_run_time),
            "::",
            stringify!(lp_index)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_get_logical_processor_run_time {
    pub global_time: __u64,
    pub local_run_time: __u64,
    pub rsvdz0: __u64,
    pub hypervisor_time: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_get_logical_processor_run_time() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_get_logical_processor_run_time> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_logical_processor_run_time>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hv_output_get_logical_processor_run_time)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_logical_processor_run_time>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_output_get_logical_processor_run_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_logical_processor_run_time),
            "::",
            stringify!(global_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_run_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_logical_processor_run_time),
            "::",
            stringify!(local_run_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz0) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_logical_processor_run_time),
            "::",
            stringify!(rsvdz0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hypervisor_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_logical_processor_run_time),
            "::",
            stringify!(hypervisor_time)
        )
    );
}
pub const HvSubnodeAny: _bindgen_ty_1 = 0;
pub const HvSubnodeSocket: _bindgen_ty_1 = 1;
pub const HvSubnodeCluster: _bindgen_ty_1 = 2;
pub const HvSubnodeL3: _bindgen_ty_1 = 3;
pub const HvSubnodeCount: _bindgen_ty_1 = 4;
pub const HvSubnodeInvalid: _bindgen_ty_1 = -1;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_create_vp {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub padding: [__u8; 3usize],
    pub subnode_type: __u8,
    pub subnode_id: __u64,
    pub proximity_domain_info: hv_proximity_domain_info,
    pub flags: __u64,
}
#[test]
fn bindgen_test_layout_hv_create_vp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_create_vp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_create_vp>(),
        40usize,
        concat!("Size of: ", stringify!(hv_create_vp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_create_vp>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_create_vp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subnode_type) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(subnode_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subnode_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(subnode_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proximity_domain_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(proximity_domain_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_vp),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for hv_create_vp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_send_ipi_ex {
    pub vector: __u32,
    pub reserved: __u32,
    pub vp_set: hv_vpset,
}
#[test]
fn bindgen_test_layout_hv_send_ipi_ex() {
    const UNINIT: ::std::mem::MaybeUninit<hv_send_ipi_ex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_send_ipi_ex>(),
        24usize,
        concat!("Size of: ", stringify!(hv_send_ipi_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_send_ipi_ex>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_send_ipi_ex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_send_ipi_ex),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_send_ipi_ex),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_send_ipi_ex),
            "::",
            stringify!(vp_set)
        )
    );
}
impl Default for hv_send_ipi_ex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_attdev_flags {
    pub __bindgen_anon_1: hv_attdev_flags__bindgen_ty_1,
    pub as_uint32: __u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_attdev_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_attdev_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_attdev_flags__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_attdev_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_attdev_flags__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_attdev_flags__bindgen_ty_1))
    );
}
impl hv_attdev_flags__bindgen_ty_1 {
    #[inline]
    pub fn logical_id(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logical_id(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resvd0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resvd0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ats_enabled(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ats_enabled(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virt_func(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virt_func(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared_irq_child(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared_irq_child(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virt_dev(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_virt_dev(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ats_supported(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ats_supported(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn small_irt(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_small_irt(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resvd(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_resvd(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        logical_id: __u32,
        resvd0: __u32,
        ats_enabled: __u32,
        virt_func: __u32,
        shared_irq_child: __u32,
        virt_dev: __u32,
        ats_supported: __u32,
        small_irt: __u32,
        resvd: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let logical_id: u32 = unsafe { ::std::mem::transmute(logical_id) };
            logical_id as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let resvd0: u32 = unsafe { ::std::mem::transmute(resvd0) };
            resvd0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ats_enabled: u32 = unsafe { ::std::mem::transmute(ats_enabled) };
            ats_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let virt_func: u32 = unsafe { ::std::mem::transmute(virt_func) };
            virt_func as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shared_irq_child: u32 = unsafe { ::std::mem::transmute(shared_irq_child) };
            shared_irq_child as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let virt_dev: u32 = unsafe { ::std::mem::transmute(virt_dev) };
            virt_dev as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ats_supported: u32 = unsafe { ::std::mem::transmute(ats_supported) };
            ats_supported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let small_irt: u32 = unsafe { ::std::mem::transmute(small_irt) };
            small_irt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let resvd: u32 = unsafe { ::std::mem::transmute(resvd) };
            resvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_attdev_flags() {
    const UNINIT: ::std::mem::MaybeUninit<hv_attdev_flags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_attdev_flags>(),
        4usize,
        concat!("Size of: ", stringify!(hv_attdev_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_attdev_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_attdev_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_attdev_flags),
            "::",
            stringify!(as_uint32)
        )
    );
}
impl Default for hv_attdev_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_dev_pci_caps {
    pub __bindgen_anon_1: hv_dev_pci_caps__bindgen_ty_1,
    pub as_uint32: __u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_dev_pci_caps__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_dev_pci_caps__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_dev_pci_caps__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_dev_pci_caps__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_dev_pci_caps__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_dev_pci_caps__bindgen_ty_1))
    );
}
impl hv_dev_pci_caps__bindgen_ty_1 {
    #[inline]
    pub fn max_pasid_width(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_max_pasid_width(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalidate_qdepth(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalidate_qdepth(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn global_inval(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_global_inval(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prg_response_req(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prg_response_req(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resvd(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_resvd(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        max_pasid_width: __u32,
        invalidate_qdepth: __u32,
        global_inval: __u32,
        prg_response_req: __u32,
        resvd: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let max_pasid_width: u32 = unsafe { ::std::mem::transmute(max_pasid_width) };
            max_pasid_width as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let invalidate_qdepth: u32 = unsafe { ::std::mem::transmute(invalidate_qdepth) };
            invalidate_qdepth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let global_inval: u32 = unsafe { ::std::mem::transmute(global_inval) };
            global_inval as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let prg_response_req: u32 = unsafe { ::std::mem::transmute(prg_response_req) };
            prg_response_req as u64
        });
        __bindgen_bitfield_unit.set(4usize, 24u8, {
            let resvd: u32 = unsafe { ::std::mem::transmute(resvd) };
            resvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_dev_pci_caps() {
    const UNINIT: ::std::mem::MaybeUninit<hv_dev_pci_caps> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_dev_pci_caps>(),
        4usize,
        concat!("Size of: ", stringify!(hv_dev_pci_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_dev_pci_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_dev_pci_caps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_dev_pci_caps),
            "::",
            stringify!(as_uint32)
        )
    );
}
impl Default for hv_dev_pci_caps {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hv_pci_rid = __u16;
pub type hv_pci_segment = __u16;
pub type hv_logical_device_id = __u64;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_pci_bdf {
    pub as_uint16: __u16,
    pub __bindgen_anon_1: hv_pci_bdf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_pci_bdf__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bus: __u8,
}
#[test]
fn bindgen_test_layout_hv_pci_bdf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_pci_bdf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_pci_bdf__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(hv_pci_bdf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_pci_bdf__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_pci_bdf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_pci_bdf__bindgen_ty_1),
            "::",
            stringify!(bus)
        )
    );
}
impl hv_pci_bdf__bindgen_ty_1 {
    #[inline]
    pub fn function(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_function(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn device(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_device(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(function: __u8, device: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let function: u8 = unsafe { ::std::mem::transmute(function) };
            function as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let device: u8 = unsafe { ::std::mem::transmute(device) };
            device as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_pci_bdf() {
    const UNINIT: ::std::mem::MaybeUninit<hv_pci_bdf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_pci_bdf>(),
        2usize,
        concat!("Size of: ", stringify!(hv_pci_bdf))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_pci_bdf>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_pci_bdf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_pci_bdf),
            "::",
            stringify!(as_uint16)
        )
    );
}
impl Default for hv_pci_bdf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_pci_bus_range {
    pub as_uint16: __u16,
    pub __bindgen_anon_1: hv_pci_bus_range__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_pci_bus_range__bindgen_ty_1 {
    pub subordinate_bus: __u8,
    pub secondary_bus: __u8,
}
#[test]
fn bindgen_test_layout_hv_pci_bus_range__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_pci_bus_range__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_pci_bus_range__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(hv_pci_bus_range__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_pci_bus_range__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_pci_bus_range__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subordinate_bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_pci_bus_range__bindgen_ty_1),
            "::",
            stringify!(subordinate_bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secondary_bus) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_pci_bus_range__bindgen_ty_1),
            "::",
            stringify!(secondary_bus)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_pci_bus_range() {
    const UNINIT: ::std::mem::MaybeUninit<hv_pci_bus_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_pci_bus_range>(),
        2usize,
        concat!("Size of: ", stringify!(hv_pci_bus_range))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_pci_bus_range>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_pci_bus_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_pci_bus_range),
            "::",
            stringify!(as_uint16)
        )
    );
}
impl Default for hv_pci_bus_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_device_type_HV_DEVICE_TYPE_LOGICAL: hv_device_type = 0;
pub const hv_device_type_HV_DEVICE_TYPE_PCI: hv_device_type = 1;
pub const hv_device_type_HV_DEVICE_TYPE_IOAPIC: hv_device_type = 2;
pub const hv_device_type_HV_DEVICE_TYPE_ACPI: hv_device_type = 3;
pub type hv_device_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_detach_device {
    pub partition_id: __u64,
    pub logical_devid: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_detach_device() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_detach_device> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_detach_device>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_detach_device))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_detach_device>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_detach_device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_detach_device),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_devid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_detach_device),
            "::",
            stringify!(logical_devid)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_device_domain_id {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_device_domain_id__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_device_domain_id__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub id: __u32,
}
#[test]
fn bindgen_test_layout_hv_device_domain_id__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_device_domain_id__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_device_domain_id__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_device_domain_id__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_device_domain_id__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hv_device_domain_id__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_device_domain_id__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
}
impl hv_device_domain_id__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_device_domain_id() {
    const UNINIT: ::std::mem::MaybeUninit<hv_device_domain_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_device_domain_id>(),
        8usize,
        concat!("Size of: ", stringify!(hv_device_domain_id))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_device_domain_id>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_device_domain_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_device_domain_id),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_device_domain_id {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_device_domain {
    pub partition_id: __u64,
    pub owner_vtl: hv_input_vtl,
    pub padding: [__u8; 7usize],
    pub domain_id: hv_device_domain_id,
}
#[test]
fn bindgen_test_layout_hv_input_device_domain() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_device_domain> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_device_domain>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_device_domain))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_device_domain>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_device_domain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_device_domain),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_vtl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_device_domain),
            "::",
            stringify!(owner_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_device_domain),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_device_domain),
            "::",
            stringify!(domain_id)
        )
    );
}
impl Default for hv_input_device_domain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_create_device_domain_flags {
    pub as_uint32: __u32,
    pub __bindgen_anon_1: hv_create_device_domain_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_create_device_domain_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_create_device_domain_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_create_device_domain_flags__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_create_device_domain_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_create_device_domain_flags__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_create_device_domain_flags__bindgen_ty_1)
        )
    );
}
impl hv_create_device_domain_flags__bindgen_ty_1 {
    #[inline]
    pub fn forward_progress_required(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forward_progress_required(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit_owning_vtl(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inherit_owning_vtl(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        forward_progress_required: __u32,
        inherit_owning_vtl: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let forward_progress_required: u32 =
                unsafe { ::std::mem::transmute(forward_progress_required) };
            forward_progress_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inherit_owning_vtl: u32 = unsafe { ::std::mem::transmute(inherit_owning_vtl) };
            inherit_owning_vtl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_create_device_domain_flags() {
    const UNINIT: ::std::mem::MaybeUninit<hv_create_device_domain_flags> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_create_device_domain_flags>(),
        4usize,
        concat!("Size of: ", stringify!(hv_create_device_domain_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_create_device_domain_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_create_device_domain_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_create_device_domain_flags),
            "::",
            stringify!(as_uint32)
        )
    );
}
impl Default for hv_create_device_domain_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_create_device_domain {
    pub device_domain: hv_input_device_domain,
    pub create_device_domain_flags: hv_create_device_domain_flags,
}
#[test]
fn bindgen_test_layout_hv_input_create_device_domain() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_create_device_domain> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_create_device_domain>(),
        28usize,
        concat!("Size of: ", stringify!(hv_input_create_device_domain))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_create_device_domain>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_create_device_domain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_device_domain),
            "::",
            stringify!(device_domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_device_domain_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_device_domain),
            "::",
            stringify!(create_device_domain_flags)
        )
    );
}
impl Default for hv_input_create_device_domain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_delete_device_domain {
    pub device_domain: hv_input_device_domain,
}
#[test]
fn bindgen_test_layout_hv_input_delete_device_domain() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_delete_device_domain> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_delete_device_domain>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_delete_device_domain))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_delete_device_domain>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_delete_device_domain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_delete_device_domain),
            "::",
            stringify!(device_domain)
        )
    );
}
impl Default for hv_input_delete_device_domain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_map_device_gpa_pages {
    pub device_domain: hv_input_device_domain,
    pub target_vtl: hv_input_vtl,
    pub padding: [__u8; 3usize],
    pub map_flags: __u32,
    pub target_device_va_base: __u64,
    pub gpa_page_list: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_input_map_device_gpa_pages() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_map_device_gpa_pages> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_map_device_gpa_pages>(),
        40usize,
        concat!("Size of: ", stringify!(hv_input_map_device_gpa_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_map_device_gpa_pages>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_map_device_gpa_pages))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_device_gpa_pages),
            "::",
            stringify!(device_domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vtl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_device_gpa_pages),
            "::",
            stringify!(target_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_device_gpa_pages),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_device_gpa_pages),
            "::",
            stringify!(map_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_device_va_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_device_gpa_pages),
            "::",
            stringify!(target_device_va_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa_page_list) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_device_gpa_pages),
            "::",
            stringify!(gpa_page_list)
        )
    );
}
impl Default for hv_input_map_device_gpa_pages {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_unmap_device_gpa_pages {
    pub device_domain: hv_input_device_domain,
    pub target_device_va_base: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_unmap_device_gpa_pages() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_unmap_device_gpa_pages> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_unmap_device_gpa_pages>(),
        32usize,
        concat!("Size of: ", stringify!(hv_input_unmap_device_gpa_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_unmap_device_gpa_pages>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_unmap_device_gpa_pages))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_device_gpa_pages),
            "::",
            stringify!(device_domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_device_va_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_device_gpa_pages),
            "::",
            stringify!(target_device_va_base)
        )
    );
}
impl Default for hv_input_unmap_device_gpa_pages {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_stats_hypervisor_counters_HvLogicalProcessors: hv_stats_hypervisor_counters = 1;
pub const hv_stats_hypervisor_counters_HvPartitions: hv_stats_hypervisor_counters = 2;
pub const hv_stats_hypervisor_counters_HvTotalPages: hv_stats_hypervisor_counters = 3;
pub const hv_stats_hypervisor_counters_HvVirtualProcessors: hv_stats_hypervisor_counters = 4;
pub const hv_stats_hypervisor_counters_HvMonitoredNotifications: hv_stats_hypervisor_counters = 5;
pub const hv_stats_hypervisor_counters_HvModernStandbyEntries: hv_stats_hypervisor_counters = 6;
pub const hv_stats_hypervisor_counters_HvPlatformIdleTransitions: hv_stats_hypervisor_counters = 7;
pub const hv_stats_hypervisor_counters_HvHypervisorStartupCost: hv_stats_hypervisor_counters = 8;
pub const hv_stats_hypervisor_counters_HvIOSpacePages: hv_stats_hypervisor_counters = 10;
pub const hv_stats_hypervisor_counters_HvNonEssentialPagesForDump: hv_stats_hypervisor_counters =
    11;
pub const hv_stats_hypervisor_counters_HvSubsumedPages: hv_stats_hypervisor_counters = 12;
pub const hv_stats_hypervisor_counters_HvStatsMaxCounter: hv_stats_hypervisor_counters = 13;
pub type hv_stats_hypervisor_counters = ::std::os::raw::c_uint;
pub const hv_stats_partition_counters_PartitionVirtualProcessors: hv_stats_partition_counters = 1;
pub const hv_stats_partition_counters_PartitionTlbSize: hv_stats_partition_counters = 3;
pub const hv_stats_partition_counters_PartitionAddressSpaces: hv_stats_partition_counters = 4;
pub const hv_stats_partition_counters_PartitionDepositedPages: hv_stats_partition_counters = 5;
pub const hv_stats_partition_counters_PartitionGpaPages: hv_stats_partition_counters = 6;
pub const hv_stats_partition_counters_PartitionGpaSpaceModifications: hv_stats_partition_counters =
    7;
pub const hv_stats_partition_counters_PartitionVirtualTlbFlushEntires: hv_stats_partition_counters =
    8;
pub const hv_stats_partition_counters_PartitionRecommendedTlbSize: hv_stats_partition_counters = 9;
pub const hv_stats_partition_counters_PartitionGpaPages4K: hv_stats_partition_counters = 10;
pub const hv_stats_partition_counters_PartitionGpaPages2M: hv_stats_partition_counters = 11;
pub const hv_stats_partition_counters_PartitionGpaPages1G: hv_stats_partition_counters = 12;
pub const hv_stats_partition_counters_PartitionGpaPages512G: hv_stats_partition_counters = 13;
pub const hv_stats_partition_counters_PartitionDevicePages4K: hv_stats_partition_counters = 14;
pub const hv_stats_partition_counters_PartitionDevicePages2M: hv_stats_partition_counters = 15;
pub const hv_stats_partition_counters_PartitionDevicePages1G: hv_stats_partition_counters = 16;
pub const hv_stats_partition_counters_PartitionDevicePages512G: hv_stats_partition_counters = 17;
pub const hv_stats_partition_counters_PartitionAttachedDevices: hv_stats_partition_counters = 18;
pub const hv_stats_partition_counters_PartitionDeviceInterruptMappings:
    hv_stats_partition_counters = 19;
pub const hv_stats_partition_counters_PartitionIoTlbFlushes: hv_stats_partition_counters = 20;
pub const hv_stats_partition_counters_PartitionIoTlbFlushCost: hv_stats_partition_counters = 21;
pub const hv_stats_partition_counters_PartitionDeviceInterruptErrors: hv_stats_partition_counters =
    22;
pub const hv_stats_partition_counters_PartitionDeviceDmaErrors: hv_stats_partition_counters = 23;
pub const hv_stats_partition_counters_PartitionDeviceInterruptThrottleEvents:
    hv_stats_partition_counters = 24;
pub const hv_stats_partition_counters_PartitionSkippedTimerTicks: hv_stats_partition_counters = 25;
pub const hv_stats_partition_counters_PartitionPartitionId: hv_stats_partition_counters = 26;
pub const hv_stats_partition_counters_PartitionNestedTlbSize: hv_stats_partition_counters = 27;
pub const hv_stats_partition_counters_PartitionRecommendedNestedTlbSize:
    hv_stats_partition_counters = 28;
pub const hv_stats_partition_counters_PartitionNestedTlbFreeListSize: hv_stats_partition_counters =
    29;
pub const hv_stats_partition_counters_PartitionNestedTlbTrimmedPages: hv_stats_partition_counters =
    30;
pub const hv_stats_partition_counters_PartitionPagesShattered: hv_stats_partition_counters = 31;
pub const hv_stats_partition_counters_PartitionPagesRecombined: hv_stats_partition_counters = 32;
pub const hv_stats_partition_counters_PartitionHwpRequestValue: hv_stats_partition_counters = 33;
pub const hv_stats_partition_counters_PartitionStatsMaxCounter: hv_stats_partition_counters = 34;
pub type hv_stats_partition_counters = ::std::os::raw::c_uint;
pub const hv_stats_vp_counters_VpTotalRunTime: hv_stats_vp_counters = 1;
pub const hv_stats_vp_counters_VpHypervisorRunTime: hv_stats_vp_counters = 2;
pub const hv_stats_vp_counters_VpRemoteNodeRunTime: hv_stats_vp_counters = 3;
pub const hv_stats_vp_counters_VpNormalizedRunTime: hv_stats_vp_counters = 4;
pub const hv_stats_vp_counters_VpIdealCpu: hv_stats_vp_counters = 5;
pub const hv_stats_vp_counters_VpHypercallsCount: hv_stats_vp_counters = 7;
pub const hv_stats_vp_counters_VpHypercallsTime: hv_stats_vp_counters = 8;
pub const hv_stats_vp_counters_VpPageInvalidationsCount: hv_stats_vp_counters = 9;
pub const hv_stats_vp_counters_VpPageInvalidationsTime: hv_stats_vp_counters = 10;
pub const hv_stats_vp_counters_VpControlRegisterAccessesCount: hv_stats_vp_counters = 11;
pub const hv_stats_vp_counters_VpControlRegisterAccessesTime: hv_stats_vp_counters = 12;
pub const hv_stats_vp_counters_VpIoInstructionsCount: hv_stats_vp_counters = 13;
pub const hv_stats_vp_counters_VpIoInstructionsTime: hv_stats_vp_counters = 14;
pub const hv_stats_vp_counters_VpHltInstructionsCount: hv_stats_vp_counters = 15;
pub const hv_stats_vp_counters_VpHltInstructionsTime: hv_stats_vp_counters = 16;
pub const hv_stats_vp_counters_VpMwaitInstructionsCount: hv_stats_vp_counters = 17;
pub const hv_stats_vp_counters_VpMwaitInstructionsTime: hv_stats_vp_counters = 18;
pub const hv_stats_vp_counters_VpCpuidInstructionsCount: hv_stats_vp_counters = 19;
pub const hv_stats_vp_counters_VpCpuidInstructionsTime: hv_stats_vp_counters = 20;
pub const hv_stats_vp_counters_VpMsrAccessesCount: hv_stats_vp_counters = 21;
pub const hv_stats_vp_counters_VpMsrAccessesTime: hv_stats_vp_counters = 22;
pub const hv_stats_vp_counters_VpOtherInterceptsCount: hv_stats_vp_counters = 23;
pub const hv_stats_vp_counters_VpOtherInterceptsTime: hv_stats_vp_counters = 24;
pub const hv_stats_vp_counters_VpExternalInterruptsCount: hv_stats_vp_counters = 25;
pub const hv_stats_vp_counters_VpExternalInterruptsTime: hv_stats_vp_counters = 26;
pub const hv_stats_vp_counters_VpPendingInterruptsCount: hv_stats_vp_counters = 27;
pub const hv_stats_vp_counters_VpPendingInterruptsTime: hv_stats_vp_counters = 28;
pub const hv_stats_vp_counters_VpEmulatedInstructionsCount: hv_stats_vp_counters = 29;
pub const hv_stats_vp_counters_VpEmulatedInstructionsTime: hv_stats_vp_counters = 30;
pub const hv_stats_vp_counters_VpDebugRegisterAccessesCount: hv_stats_vp_counters = 31;
pub const hv_stats_vp_counters_VpDebugRegisterAccessesTime: hv_stats_vp_counters = 32;
pub const hv_stats_vp_counters_VpPageFaultInterceptsCount: hv_stats_vp_counters = 33;
pub const hv_stats_vp_counters_VpPageFaultInterceptsTime: hv_stats_vp_counters = 34;
pub const hv_stats_vp_counters_VpGuestPageTableMaps: hv_stats_vp_counters = 35;
pub const hv_stats_vp_counters_VpLargePageTlbFills: hv_stats_vp_counters = 36;
pub const hv_stats_vp_counters_VpSmallPageTlbFills: hv_stats_vp_counters = 37;
pub const hv_stats_vp_counters_VpReflectedGuestPageFaults: hv_stats_vp_counters = 38;
pub const hv_stats_vp_counters_VpApicMmioAccesses: hv_stats_vp_counters = 39;
pub const hv_stats_vp_counters_VpIoInterceptMessages: hv_stats_vp_counters = 40;
pub const hv_stats_vp_counters_VpMemoryInterceptMessages: hv_stats_vp_counters = 41;
pub const hv_stats_vp_counters_VpApicEoiAccesses: hv_stats_vp_counters = 42;
pub const hv_stats_vp_counters_VpOtherMessages: hv_stats_vp_counters = 43;
pub const hv_stats_vp_counters_VpPageTableAllocations: hv_stats_vp_counters = 44;
pub const hv_stats_vp_counters_VpLogicalProcessorMigrations: hv_stats_vp_counters = 45;
pub const hv_stats_vp_counters_VpAddressSpaceEvictions: hv_stats_vp_counters = 46;
pub const hv_stats_vp_counters_VpAddressSpaceSwitches: hv_stats_vp_counters = 47;
pub const hv_stats_vp_counters_VpAddressDomainFlushes: hv_stats_vp_counters = 48;
pub const hv_stats_vp_counters_VpAddressSpaceFlushes: hv_stats_vp_counters = 49;
pub const hv_stats_vp_counters_VpGlobalGvaRangeFlushes: hv_stats_vp_counters = 50;
pub const hv_stats_vp_counters_VpLocalGvaRangeFlushes: hv_stats_vp_counters = 51;
pub const hv_stats_vp_counters_VpPageTableEvictions: hv_stats_vp_counters = 52;
pub const hv_stats_vp_counters_VpPageTableReclamations: hv_stats_vp_counters = 53;
pub const hv_stats_vp_counters_VpPageTableResets: hv_stats_vp_counters = 54;
pub const hv_stats_vp_counters_VpPageTableValidations: hv_stats_vp_counters = 55;
pub const hv_stats_vp_counters_VpApicTprAccesses: hv_stats_vp_counters = 56;
pub const hv_stats_vp_counters_VpPageTableWriteIntercepts: hv_stats_vp_counters = 57;
pub const hv_stats_vp_counters_VpSyntheticInterrupts: hv_stats_vp_counters = 58;
pub const hv_stats_vp_counters_VpVirtualInterrupts: hv_stats_vp_counters = 59;
pub const hv_stats_vp_counters_VpApicIpisSent: hv_stats_vp_counters = 60;
pub const hv_stats_vp_counters_VpApicSelfIpisSent: hv_stats_vp_counters = 61;
pub const hv_stats_vp_counters_VpGpaSpaceHypercalls: hv_stats_vp_counters = 62;
pub const hv_stats_vp_counters_VpLogicalProcessorHypercalls: hv_stats_vp_counters = 63;
pub const hv_stats_vp_counters_VpLongSpinWaitHypercalls: hv_stats_vp_counters = 64;
pub const hv_stats_vp_counters_VpOtherHypercalls: hv_stats_vp_counters = 65;
pub const hv_stats_vp_counters_VpSyntheticInterruptHypercalls: hv_stats_vp_counters = 66;
pub const hv_stats_vp_counters_VpVirtualInterruptHypercalls: hv_stats_vp_counters = 67;
pub const hv_stats_vp_counters_VpVirtualMmuHypercalls: hv_stats_vp_counters = 68;
pub const hv_stats_vp_counters_VpVirtualProcessorHypercalls: hv_stats_vp_counters = 69;
pub const hv_stats_vp_counters_VpHardwareInterrupts: hv_stats_vp_counters = 70;
pub const hv_stats_vp_counters_VpNestedPageFaultInterceptsCount: hv_stats_vp_counters = 71;
pub const hv_stats_vp_counters_VpNestedPageFaultInterceptsTime: hv_stats_vp_counters = 72;
pub const hv_stats_vp_counters_VpPageScans: hv_stats_vp_counters = 73;
pub const hv_stats_vp_counters_VpLogicalProcessorDispatches: hv_stats_vp_counters = 74;
pub const hv_stats_vp_counters_VpWaitingForCpuTime: hv_stats_vp_counters = 75;
pub const hv_stats_vp_counters_VpExtendedHypercalls: hv_stats_vp_counters = 76;
pub const hv_stats_vp_counters_VpExtendedHypercallInterceptMessages: hv_stats_vp_counters = 77;
pub const hv_stats_vp_counters_VpMbecNestedPageTableSwitches: hv_stats_vp_counters = 78;
pub const hv_stats_vp_counters_VpOtherReflectedGuestExceptions: hv_stats_vp_counters = 79;
pub const hv_stats_vp_counters_VpGlobalIoTlbFlushes: hv_stats_vp_counters = 80;
pub const hv_stats_vp_counters_VpGlobalIoTlbFlushCost: hv_stats_vp_counters = 81;
pub const hv_stats_vp_counters_VpLocalIoTlbFlushes: hv_stats_vp_counters = 82;
pub const hv_stats_vp_counters_VpLocalIoTlbFlushCost: hv_stats_vp_counters = 83;
pub const hv_stats_vp_counters_VpHypercallsForwardedCount: hv_stats_vp_counters = 84;
pub const hv_stats_vp_counters_VpHypercallsForwardingTime: hv_stats_vp_counters = 85;
pub const hv_stats_vp_counters_VpPageInvalidationsForwardedCount: hv_stats_vp_counters = 86;
pub const hv_stats_vp_counters_VpPageInvalidationsForwardingTime: hv_stats_vp_counters = 87;
pub const hv_stats_vp_counters_VpControlRegisterAccessesForwardedCount: hv_stats_vp_counters = 88;
pub const hv_stats_vp_counters_VpControlRegisterAccessesForwardingTime: hv_stats_vp_counters = 89;
pub const hv_stats_vp_counters_VpIoInstructionsForwardedCount: hv_stats_vp_counters = 90;
pub const hv_stats_vp_counters_VpIoInstructionsForwardingTime: hv_stats_vp_counters = 91;
pub const hv_stats_vp_counters_VpHltInstructionsForwardedCount: hv_stats_vp_counters = 92;
pub const hv_stats_vp_counters_VpHltInstructionsForwardingTime: hv_stats_vp_counters = 93;
pub const hv_stats_vp_counters_VpMwaitInstructionsForwardedCount: hv_stats_vp_counters = 94;
pub const hv_stats_vp_counters_VpMwaitInstructionsForwardingTime: hv_stats_vp_counters = 95;
pub const hv_stats_vp_counters_VpCpuidInstructionsForwardedCount: hv_stats_vp_counters = 96;
pub const hv_stats_vp_counters_VpCpuidInstructionsForwardingTime: hv_stats_vp_counters = 97;
pub const hv_stats_vp_counters_VpMsrAccessesForwardedCount: hv_stats_vp_counters = 98;
pub const hv_stats_vp_counters_VpMsrAccessesForwardingTime: hv_stats_vp_counters = 99;
pub const hv_stats_vp_counters_VpOtherInterceptsForwardedCount: hv_stats_vp_counters = 100;
pub const hv_stats_vp_counters_VpOtherInterceptsForwardingTime: hv_stats_vp_counters = 101;
pub const hv_stats_vp_counters_VpExternalInterruptsForwardedCount: hv_stats_vp_counters = 102;
pub const hv_stats_vp_counters_VpExternalInterruptsForwardingTime: hv_stats_vp_counters = 103;
pub const hv_stats_vp_counters_VpPendingInterruptsForwardedCount: hv_stats_vp_counters = 104;
pub const hv_stats_vp_counters_VpPendingInterruptsForwardingTime: hv_stats_vp_counters = 105;
pub const hv_stats_vp_counters_VpEmulatedInstructionsForwardedCount: hv_stats_vp_counters = 106;
pub const hv_stats_vp_counters_VpEmulatedInstructionsForwardingTime: hv_stats_vp_counters = 107;
pub const hv_stats_vp_counters_VpDebugRegisterAccessesForwardedCount: hv_stats_vp_counters = 108;
pub const hv_stats_vp_counters_VpDebugRegisterAccessesForwardingTime: hv_stats_vp_counters = 109;
pub const hv_stats_vp_counters_VpPageFaultInterceptsForwardedCount: hv_stats_vp_counters = 110;
pub const hv_stats_vp_counters_VpPageFaultInterceptsForwardingTime: hv_stats_vp_counters = 111;
pub const hv_stats_vp_counters_VpVmclearEmulationCount: hv_stats_vp_counters = 112;
pub const hv_stats_vp_counters_VpVmclearEmulationTime: hv_stats_vp_counters = 113;
pub const hv_stats_vp_counters_VpVmptrldEmulationCount: hv_stats_vp_counters = 114;
pub const hv_stats_vp_counters_VpVmptrldEmulationTime: hv_stats_vp_counters = 115;
pub const hv_stats_vp_counters_VpVmptrstEmulationCount: hv_stats_vp_counters = 116;
pub const hv_stats_vp_counters_VpVmptrstEmulationTime: hv_stats_vp_counters = 117;
pub const hv_stats_vp_counters_VpVmreadEmulationCount: hv_stats_vp_counters = 118;
pub const hv_stats_vp_counters_VpVmreadEmulationTime: hv_stats_vp_counters = 119;
pub const hv_stats_vp_counters_VpVmwriteEmulationCount: hv_stats_vp_counters = 120;
pub const hv_stats_vp_counters_VpVmwriteEmulationTime: hv_stats_vp_counters = 121;
pub const hv_stats_vp_counters_VpVmxoffEmulationCount: hv_stats_vp_counters = 122;
pub const hv_stats_vp_counters_VpVmxoffEmulationTime: hv_stats_vp_counters = 123;
pub const hv_stats_vp_counters_VpVmxonEmulationCount: hv_stats_vp_counters = 124;
pub const hv_stats_vp_counters_VpVmxonEmulationTime: hv_stats_vp_counters = 125;
pub const hv_stats_vp_counters_VpNestedVMEntriesCount: hv_stats_vp_counters = 126;
pub const hv_stats_vp_counters_VpNestedVMEntriesTime: hv_stats_vp_counters = 127;
pub const hv_stats_vp_counters_VpNestedSLATSoftPageFaultsCount: hv_stats_vp_counters = 128;
pub const hv_stats_vp_counters_VpNestedSLATSoftPageFaultsTime: hv_stats_vp_counters = 129;
pub const hv_stats_vp_counters_VpNestedSLATHardPageFaultsCount: hv_stats_vp_counters = 130;
pub const hv_stats_vp_counters_VpNestedSLATHardPageFaultsTime: hv_stats_vp_counters = 131;
pub const hv_stats_vp_counters_VpInvEptAllContextEmulationCount: hv_stats_vp_counters = 132;
pub const hv_stats_vp_counters_VpInvEptAllContextEmulationTime: hv_stats_vp_counters = 133;
pub const hv_stats_vp_counters_VpInvEptSingleContextEmulationCount: hv_stats_vp_counters = 134;
pub const hv_stats_vp_counters_VpInvEptSingleContextEmulationTime: hv_stats_vp_counters = 135;
pub const hv_stats_vp_counters_VpInvVpidAllContextEmulationCount: hv_stats_vp_counters = 136;
pub const hv_stats_vp_counters_VpInvVpidAllContextEmulationTime: hv_stats_vp_counters = 137;
pub const hv_stats_vp_counters_VpInvVpidSingleContextEmulationCount: hv_stats_vp_counters = 138;
pub const hv_stats_vp_counters_VpInvVpidSingleContextEmulationTime: hv_stats_vp_counters = 139;
pub const hv_stats_vp_counters_VpInvVpidSingleAddressEmulationCount: hv_stats_vp_counters = 140;
pub const hv_stats_vp_counters_VpInvVpidSingleAddressEmulationTime: hv_stats_vp_counters = 141;
pub const hv_stats_vp_counters_VpNestedTlbPageTableReclamations: hv_stats_vp_counters = 142;
pub const hv_stats_vp_counters_VpNestedTlbPageTableEvictions: hv_stats_vp_counters = 143;
pub const hv_stats_vp_counters_VpFlushGuestPhysicalAddressSpaceHypercalls: hv_stats_vp_counters =
    144;
pub const hv_stats_vp_counters_VpFlushGuestPhysicalAddressListHypercalls: hv_stats_vp_counters =
    145;
pub const hv_stats_vp_counters_VpPostedInterruptNotifications: hv_stats_vp_counters = 146;
pub const hv_stats_vp_counters_VpPostedInterruptScans: hv_stats_vp_counters = 147;
pub const hv_stats_vp_counters_VpTotalCoreRunTime: hv_stats_vp_counters = 148;
pub const hv_stats_vp_counters_VpMaximumRunTime: hv_stats_vp_counters = 149;
pub const hv_stats_vp_counters_VpHwpRequestContextSwitches: hv_stats_vp_counters = 150;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket0: hv_stats_vp_counters = 151;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket1: hv_stats_vp_counters = 152;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket2: hv_stats_vp_counters = 153;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket3: hv_stats_vp_counters = 154;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket4: hv_stats_vp_counters = 155;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket5: hv_stats_vp_counters = 156;
pub const hv_stats_vp_counters_VpWaitingForCpuTimeBucket6: hv_stats_vp_counters = 157;
pub const hv_stats_vp_counters_VpVmloadEmulationCount: hv_stats_vp_counters = 158;
pub const hv_stats_vp_counters_VpVmloadEmulationTime: hv_stats_vp_counters = 159;
pub const hv_stats_vp_counters_VpVmsaveEmulationCount: hv_stats_vp_counters = 160;
pub const hv_stats_vp_counters_VpVmsaveEmulationTime: hv_stats_vp_counters = 161;
pub const hv_stats_vp_counters_VpGifInstructionEmulationCount: hv_stats_vp_counters = 162;
pub const hv_stats_vp_counters_VpGifInstructionEmulationTime: hv_stats_vp_counters = 163;
pub const hv_stats_vp_counters_VpEmulatedErrataSvmInstructions: hv_stats_vp_counters = 164;
pub const hv_stats_vp_counters_VpPlaceholder1: hv_stats_vp_counters = 165;
pub const hv_stats_vp_counters_VpPlaceholder2: hv_stats_vp_counters = 166;
pub const hv_stats_vp_counters_VpPlaceholder3: hv_stats_vp_counters = 167;
pub const hv_stats_vp_counters_VpPlaceholder4: hv_stats_vp_counters = 168;
pub const hv_stats_vp_counters_VpPlaceholder5: hv_stats_vp_counters = 169;
pub const hv_stats_vp_counters_VpPlaceholder6: hv_stats_vp_counters = 170;
pub const hv_stats_vp_counters_VpPlaceholder7: hv_stats_vp_counters = 171;
pub const hv_stats_vp_counters_VpPlaceholder8: hv_stats_vp_counters = 172;
pub const hv_stats_vp_counters_VpPlaceholder9: hv_stats_vp_counters = 173;
pub const hv_stats_vp_counters_VpPlaceholder10: hv_stats_vp_counters = 174;
pub const hv_stats_vp_counters_VpSchedulingPriority: hv_stats_vp_counters = 175;
pub const hv_stats_vp_counters_VpRdpmcInstructionsCount: hv_stats_vp_counters = 176;
pub const hv_stats_vp_counters_VpRdpmcInstructionsTime: hv_stats_vp_counters = 177;
pub const hv_stats_vp_counters_VpPerfmonPmuMsrAccessesCount: hv_stats_vp_counters = 178;
pub const hv_stats_vp_counters_VpPerfmonLbrMsrAccessesCount: hv_stats_vp_counters = 179;
pub const hv_stats_vp_counters_VpPerfmonIptMsrAccessesCount: hv_stats_vp_counters = 180;
pub const hv_stats_vp_counters_VpPerfmonInterruptCount: hv_stats_vp_counters = 181;
pub const hv_stats_vp_counters_VpVtl1DispatchCount: hv_stats_vp_counters = 182;
pub const hv_stats_vp_counters_VpVtl2DispatchCount: hv_stats_vp_counters = 183;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket0: hv_stats_vp_counters = 184;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket1: hv_stats_vp_counters = 185;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket2: hv_stats_vp_counters = 186;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket3: hv_stats_vp_counters = 187;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket4: hv_stats_vp_counters = 188;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket5: hv_stats_vp_counters = 189;
pub const hv_stats_vp_counters_VpVtl2DispatchBucket6: hv_stats_vp_counters = 190;
pub const hv_stats_vp_counters_VpVtl1RunTime: hv_stats_vp_counters = 191;
pub const hv_stats_vp_counters_VpVtl2RunTime: hv_stats_vp_counters = 192;
pub const hv_stats_vp_counters_VpIommuHypercalls: hv_stats_vp_counters = 193;
pub const hv_stats_vp_counters_VpCpuGroupHypercalls: hv_stats_vp_counters = 194;
pub const hv_stats_vp_counters_VpVsmHypercalls: hv_stats_vp_counters = 195;
pub const hv_stats_vp_counters_VpEventLogHypercalls: hv_stats_vp_counters = 196;
pub const hv_stats_vp_counters_VpDeviceDomainHypercalls: hv_stats_vp_counters = 197;
pub const hv_stats_vp_counters_VpDepositHypercalls: hv_stats_vp_counters = 198;
pub const hv_stats_vp_counters_VpSvmHypercalls: hv_stats_vp_counters = 199;
pub const hv_stats_vp_counters_VpBusLockAcquisitionCount: hv_stats_vp_counters = 200;
pub const hv_stats_vp_counters_VpRootDispatchThreadBlocked: hv_stats_vp_counters = 201;
pub const hv_stats_vp_counters_VpStatsMaxCounter: hv_stats_vp_counters = 202;
pub type hv_stats_vp_counters = ::std::os::raw::c_uint;
pub const hv_stats_lp_counters_LpGlobalTime: hv_stats_lp_counters = 1;
pub const hv_stats_lp_counters_LpTotalRunTime: hv_stats_lp_counters = 2;
pub const hv_stats_lp_counters_LpHypervisorRunTime: hv_stats_lp_counters = 3;
pub const hv_stats_lp_counters_LpHardwareInterrupts: hv_stats_lp_counters = 4;
pub const hv_stats_lp_counters_LpContextSwitches: hv_stats_lp_counters = 5;
pub const hv_stats_lp_counters_LpInterProcessorInterrupts: hv_stats_lp_counters = 6;
pub const hv_stats_lp_counters_LpSchedulerInterrupts: hv_stats_lp_counters = 7;
pub const hv_stats_lp_counters_LpTimerInterrupts: hv_stats_lp_counters = 8;
pub const hv_stats_lp_counters_LpInterProcessorInterruptsSent: hv_stats_lp_counters = 9;
pub const hv_stats_lp_counters_LpProcessorHalts: hv_stats_lp_counters = 10;
pub const hv_stats_lp_counters_LpMonitorTransitionCost: hv_stats_lp_counters = 11;
pub const hv_stats_lp_counters_LpContextSwitchTime: hv_stats_lp_counters = 12;
pub const hv_stats_lp_counters_LpC1TransitionsCount: hv_stats_lp_counters = 13;
pub const hv_stats_lp_counters_LpC1RunTime: hv_stats_lp_counters = 14;
pub const hv_stats_lp_counters_LpC2TransitionsCount: hv_stats_lp_counters = 15;
pub const hv_stats_lp_counters_LpC2RunTime: hv_stats_lp_counters = 16;
pub const hv_stats_lp_counters_LpC3TransitionsCount: hv_stats_lp_counters = 17;
pub const hv_stats_lp_counters_LpC3RunTime: hv_stats_lp_counters = 18;
pub const hv_stats_lp_counters_LpRootVpIndex: hv_stats_lp_counters = 19;
pub const hv_stats_lp_counters_LpIdleSequenceNumber: hv_stats_lp_counters = 20;
pub const hv_stats_lp_counters_LpGlobalTscCount: hv_stats_lp_counters = 21;
pub const hv_stats_lp_counters_LpActiveTscCount: hv_stats_lp_counters = 22;
pub const hv_stats_lp_counters_LpIdleAccumulation: hv_stats_lp_counters = 23;
pub const hv_stats_lp_counters_LpReferenceCycleCount0: hv_stats_lp_counters = 24;
pub const hv_stats_lp_counters_LpActualCycleCount0: hv_stats_lp_counters = 25;
pub const hv_stats_lp_counters_LpReferenceCycleCount1: hv_stats_lp_counters = 26;
pub const hv_stats_lp_counters_LpActualCycleCount1: hv_stats_lp_counters = 27;
pub const hv_stats_lp_counters_LpProximityDomainId: hv_stats_lp_counters = 28;
pub const hv_stats_lp_counters_LpPostedInterruptNotifications: hv_stats_lp_counters = 29;
pub const hv_stats_lp_counters_LpBranchPredictorFlushes: hv_stats_lp_counters = 30;
pub const hv_stats_lp_counters_LpL1DataCacheFlushes: hv_stats_lp_counters = 31;
pub const hv_stats_lp_counters_LpImmediateL1DataCacheFlushes: hv_stats_lp_counters = 32;
pub const hv_stats_lp_counters_LpMbFlushes: hv_stats_lp_counters = 33;
pub const hv_stats_lp_counters_LpCounterRefreshSequenceNumber: hv_stats_lp_counters = 34;
pub const hv_stats_lp_counters_LpCounterRefreshReferenceTime: hv_stats_lp_counters = 35;
pub const hv_stats_lp_counters_LpIdleAccumulationSnapshot: hv_stats_lp_counters = 36;
pub const hv_stats_lp_counters_LpActiveTscCountSnapshot: hv_stats_lp_counters = 37;
pub const hv_stats_lp_counters_LpHwpRequestContextSwitches: hv_stats_lp_counters = 38;
pub const hv_stats_lp_counters_LpPlaceholder1: hv_stats_lp_counters = 39;
pub const hv_stats_lp_counters_LpPlaceholder2: hv_stats_lp_counters = 40;
pub const hv_stats_lp_counters_LpPlaceholder3: hv_stats_lp_counters = 41;
pub const hv_stats_lp_counters_LpPlaceholder4: hv_stats_lp_counters = 42;
pub const hv_stats_lp_counters_LpPlaceholder5: hv_stats_lp_counters = 43;
pub const hv_stats_lp_counters_LpPlaceholder6: hv_stats_lp_counters = 44;
pub const hv_stats_lp_counters_LpPlaceholder7: hv_stats_lp_counters = 45;
pub const hv_stats_lp_counters_LpPlaceholder8: hv_stats_lp_counters = 46;
pub const hv_stats_lp_counters_LpPlaceholder9: hv_stats_lp_counters = 47;
pub const hv_stats_lp_counters_LpPlaceholder10: hv_stats_lp_counters = 48;
pub const hv_stats_lp_counters_LpReserveGroupId: hv_stats_lp_counters = 49;
pub const hv_stats_lp_counters_LpRunningPriority: hv_stats_lp_counters = 50;
pub const hv_stats_lp_counters_LpPerfmonInterruptCount: hv_stats_lp_counters = 51;
pub const hv_stats_lp_counters_LpStatsMaxCounter: hv_stats_lp_counters = 52;
pub type hv_stats_lp_counters = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_stats_page {
    pub __bindgen_anon_1: hv_stats_page__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_stats_page__bindgen_ty_1 {
    pub hv_cntrs: [__u64; 13usize],
    pub pt_cntrs: [__u64; 34usize],
    pub vp_cntrs: [__u64; 202usize],
    pub lp_cntrs: [__u64; 52usize],
    pub data: [__u8; 4096usize],
}
#[test]
fn bindgen_test_layout_hv_stats_page__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stats_page__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stats_page__bindgen_ty_1>(),
        4096usize,
        concat!("Size of: ", stringify!(hv_stats_page__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_page__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_stats_page__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_cntrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_page__bindgen_ty_1),
            "::",
            stringify!(hv_cntrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pt_cntrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_page__bindgen_ty_1),
            "::",
            stringify!(pt_cntrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_cntrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_page__bindgen_ty_1),
            "::",
            stringify!(vp_cntrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp_cntrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_page__bindgen_ty_1),
            "::",
            stringify!(lp_cntrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stats_page__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
impl Default for hv_stats_page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_stats_page() {
    assert_eq!(
        ::std::mem::size_of::<hv_stats_page>(),
        4096usize,
        concat!("Size of: ", stringify!(hv_stats_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stats_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_stats_page))
    );
}
impl Default for hv_stats_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_register_page {
    pub version: __u16,
    pub isvalid: __u8,
    pub rsvdz: __u8,
    pub dirty: __u32,
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_1,
    pub reserved: [__u8; 8usize],
    pub __bindgen_anon_2: hv_vp_register_page__bindgen_ty_2,
    pub __bindgen_anon_3: hv_vp_register_page__bindgen_ty_3,
    pub cr0: __u64,
    pub cr3: __u64,
    pub cr4: __u64,
    pub cr8: __u64,
    pub efer: __u64,
    pub dr7: __u64,
    pub pending_interruption: hv_x64_pending_interruption_register,
    pub interrupt_state: hv_x64_interrupt_state_register,
    pub instruction_emulation_hints: __u64,
    pub xfem: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_1__bindgen_ty_1,
    pub registers: [__u64; 18usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_register_page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub rip: __u64,
    pub rflags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub gp_registers: [__u64; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub rax: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rbx: __u64,
    pub rsp: __u64,
    pub rbp: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1()
{
    const UNINIT: ::std::mem::MaybeUninit<
        hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r11) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r12) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r13) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r14) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r15) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r15)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_registers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(gp_registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rflags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rflags)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_1>(),
        144usize,
        concat!("Size of: ", stringify!(hv_vp_register_page__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1),
            "::",
            stringify!(registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_2 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_2__bindgen_ty_1,
    pub xmm_registers: [hv_u128; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_register_page__bindgen_ty_2__bindgen_ty_1 {
    pub xmm0: hv_u128,
    pub xmm1: hv_u128,
    pub xmm2: hv_u128,
    pub xmm3: hv_u128,
    pub xmm4: hv_u128,
    pub xmm5: hv_u128,
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm3) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm5) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm5)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_2>(),
        96usize,
        concat!("Size of: ", stringify!(hv_vp_register_page__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmm_registers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2),
            "::",
            stringify!(xmm_registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_3 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_3__bindgen_ty_1,
    pub segment_registers: [hv_x64_segment_register; 6usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_register_page__bindgen_ty_3__bindgen_ty_1 {
    pub es: hv_x64_segment_register,
    pub cs: hv_x64_segment_register,
    pub ss: hv_x64_segment_register,
    pub ds: hv_x64_segment_register,
    pub fs: hv_x64_segment_register,
    pub gs: hv_x64_segment_register,
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(gs)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_3>(),
        96usize,
        concat!("Size of: ", stringify!(hv_vp_register_page__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment_registers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3),
            "::",
            stringify!(segment_registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_register_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_register_page> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page>(),
        432usize,
        concat!("Size of: ", stringify!(hv_vp_register_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vp_register_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isvalid) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(isvalid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(rsvdz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirty) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(dirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr0) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr3) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr4) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr8) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).efer) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(efer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dr7) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(dr7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_interruption) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(pending_interruption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_state) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(interrupt_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_emulation_hints) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(instruction_emulation_hints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfem) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(xfem)
        )
    );
}
impl Default for hv_vp_register_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_processor_features {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_partition_processor_features__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_processor_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_processor_features__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_features__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_processor_features__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_features__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_processor_features__bindgen_ty_1)
        )
    );
}
impl hv_partition_processor_features__bindgen_ty_1 {
    #[inline]
    pub fn sse3_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse3_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lahf_sahf_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lahf_sahf_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssse3_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssse3_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4_1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse4_1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4_2_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse4_2_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4a_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse4a_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xop_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xop_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pop_cnt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pop_cnt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmpxchg16b_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cmpxchg16b_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn altmovcr8_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_altmovcr8_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lzcnt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lzcnt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mis_align_sse_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mis_align_sse_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmx_ext_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmx_ext_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amd3dnow_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amd3dnow_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_amd3dnow_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_extended_amd3dnow_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn page_1gb_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_page_1gb_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aes_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_aes_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pclmulqdq_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pclmulqdq_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcid_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pcid_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fma4_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fma4_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn f16c_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_f16c_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_rand_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_rand_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_wr_fs_gs_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_wr_fs_gs_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smep_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smep_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_fast_string_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enhanced_fast_string_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bmi1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bmi1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bmi2_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bmi2_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hle_support_deprecated(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hle_support_deprecated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtm_support_deprecated(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rtm_support_deprecated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movbe_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_movbe_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn npiep1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_npiep1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dep_x87_fpu_save_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dep_x87_fpu_save_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_seed_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_seed_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adx_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_adx_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intel_prefetch_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intel_prefetch_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smap_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smap_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hle_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hle_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtm_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rtm_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdtscp_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdtscp_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clflushopt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clflushopt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clwb_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clwb_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sha_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x87_pointers_saved_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_x87_pointers_saved_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invpcid_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_invpcid_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibrs_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ibrs_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stibp_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_stibp_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibpb_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ibpb_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unrestricted_guest_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_unrestricted_guest_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mdd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mdd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_short_rep_mov_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fast_short_rep_mov_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l1dcache_flush_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l1dcache_flush_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdcl_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdcl_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibrs_all_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ibrs_all_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_l1df_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_skip_l1df_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssb_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssb_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsb_a_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rsb_a_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virt_spec_ctrl_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_virt_spec_ctrl_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_pid_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_pid_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn umip_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_umip_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbs_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mbs_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_clear_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mb_clear_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn taa_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_taa_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsx_ctrl_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsx_ctrl_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_bank0(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_bank0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acount_mcount_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_acount_mcount_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_invariant_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsc_invariant_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_zero_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cl_zero_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdpru_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdpru_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn la57_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_la57_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbec_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(69usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mbec_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(69usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nested_virt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(70usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nested_virt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(70usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psfd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_psfd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_ss_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_ss_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_ibt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(73usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_ibt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(73usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vmx_exception_inject_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vmx_exception_inject_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enqcmd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enqcmd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn umwait_tpause_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_umwait_tpause_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movdiri_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_movdiri_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movdir64b_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_movdir64b_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cldemote_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cldemote_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn serialize_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_serialize_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_deadline_tmr_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsc_deadline_tmr_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_adjust_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsc_adjust_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fzlrep_movsb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fzlrep_movsb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsrep_stosb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fsrep_stosb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsrep_cmpsb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fsrep_cmpsb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_bank1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(86usize, 42u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_bank1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(86usize, 42u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sse3_support: __u64,
        lahf_sahf_support: __u64,
        ssse3_support: __u64,
        sse4_1_support: __u64,
        sse4_2_support: __u64,
        sse4a_support: __u64,
        xop_support: __u64,
        pop_cnt_support: __u64,
        cmpxchg16b_support: __u64,
        altmovcr8_support: __u64,
        lzcnt_support: __u64,
        mis_align_sse_support: __u64,
        mmx_ext_support: __u64,
        amd3dnow_support: __u64,
        extended_amd3dnow_support: __u64,
        page_1gb_support: __u64,
        aes_support: __u64,
        pclmulqdq_support: __u64,
        pcid_support: __u64,
        fma4_support: __u64,
        f16c_support: __u64,
        rd_rand_support: __u64,
        rd_wr_fs_gs_support: __u64,
        smep_support: __u64,
        enhanced_fast_string_support: __u64,
        bmi1_support: __u64,
        bmi2_support: __u64,
        hle_support_deprecated: __u64,
        rtm_support_deprecated: __u64,
        movbe_support: __u64,
        npiep1_support: __u64,
        dep_x87_fpu_save_support: __u64,
        rd_seed_support: __u64,
        adx_support: __u64,
        intel_prefetch_support: __u64,
        smap_support: __u64,
        hle_support: __u64,
        rtm_support: __u64,
        rdtscp_support: __u64,
        clflushopt_support: __u64,
        clwb_support: __u64,
        sha_support: __u64,
        x87_pointers_saved_support: __u64,
        invpcid_support: __u64,
        ibrs_support: __u64,
        stibp_support: __u64,
        ibpb_support: __u64,
        unrestricted_guest_support: __u64,
        mdd_support: __u64,
        fast_short_rep_mov_support: __u64,
        l1dcache_flush_support: __u64,
        rdcl_no_support: __u64,
        ibrs_all_support: __u64,
        skip_l1df_support: __u64,
        ssb_no_support: __u64,
        rsb_a_no_support: __u64,
        virt_spec_ctrl_support: __u64,
        rd_pid_support: __u64,
        umip_support: __u64,
        mbs_no_support: __u64,
        mb_clear_support: __u64,
        taa_no_support: __u64,
        tsx_ctrl_support: __u64,
        reserved_bank0: __u64,
        acount_mcount_support: __u64,
        tsc_invariant_support: __u64,
        cl_zero_support: __u64,
        rdpru_support: __u64,
        la57_support: __u64,
        mbec_support: __u64,
        nested_virt_support: __u64,
        psfd_support: __u64,
        cet_ss_support: __u64,
        cet_ibt_support: __u64,
        vmx_exception_inject_support: __u64,
        enqcmd_support: __u64,
        umwait_tpause_support: __u64,
        movdiri_support: __u64,
        movdir64b_support: __u64,
        cldemote_support: __u64,
        serialize_support: __u64,
        tsc_deadline_tmr_support: __u64,
        tsc_adjust_support: __u64,
        fzlrep_movsb: __u64,
        fsrep_stosb: __u64,
        fsrep_cmpsb: __u64,
        reserved_bank1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sse3_support: u64 = unsafe { ::std::mem::transmute(sse3_support) };
            sse3_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lahf_sahf_support: u64 = unsafe { ::std::mem::transmute(lahf_sahf_support) };
            lahf_sahf_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ssse3_support: u64 = unsafe { ::std::mem::transmute(ssse3_support) };
            ssse3_support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sse4_1_support: u64 = unsafe { ::std::mem::transmute(sse4_1_support) };
            sse4_1_support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sse4_2_support: u64 = unsafe { ::std::mem::transmute(sse4_2_support) };
            sse4_2_support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sse4a_support: u64 = unsafe { ::std::mem::transmute(sse4a_support) };
            sse4a_support as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let xop_support: u64 = unsafe { ::std::mem::transmute(xop_support) };
            xop_support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pop_cnt_support: u64 = unsafe { ::std::mem::transmute(pop_cnt_support) };
            pop_cnt_support as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cmpxchg16b_support: u64 = unsafe { ::std::mem::transmute(cmpxchg16b_support) };
            cmpxchg16b_support as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let altmovcr8_support: u64 = unsafe { ::std::mem::transmute(altmovcr8_support) };
            altmovcr8_support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let lzcnt_support: u64 = unsafe { ::std::mem::transmute(lzcnt_support) };
            lzcnt_support as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mis_align_sse_support: u64 =
                unsafe { ::std::mem::transmute(mis_align_sse_support) };
            mis_align_sse_support as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mmx_ext_support: u64 = unsafe { ::std::mem::transmute(mmx_ext_support) };
            mmx_ext_support as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let amd3dnow_support: u64 = unsafe { ::std::mem::transmute(amd3dnow_support) };
            amd3dnow_support as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let extended_amd3dnow_support: u64 =
                unsafe { ::std::mem::transmute(extended_amd3dnow_support) };
            extended_amd3dnow_support as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let page_1gb_support: u64 = unsafe { ::std::mem::transmute(page_1gb_support) };
            page_1gb_support as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let aes_support: u64 = unsafe { ::std::mem::transmute(aes_support) };
            aes_support as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pclmulqdq_support: u64 = unsafe { ::std::mem::transmute(pclmulqdq_support) };
            pclmulqdq_support as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pcid_support: u64 = unsafe { ::std::mem::transmute(pcid_support) };
            pcid_support as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let fma4_support: u64 = unsafe { ::std::mem::transmute(fma4_support) };
            fma4_support as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let f16c_support: u64 = unsafe { ::std::mem::transmute(f16c_support) };
            f16c_support as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rd_rand_support: u64 = unsafe { ::std::mem::transmute(rd_rand_support) };
            rd_rand_support as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rd_wr_fs_gs_support: u64 = unsafe { ::std::mem::transmute(rd_wr_fs_gs_support) };
            rd_wr_fs_gs_support as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let smep_support: u64 = unsafe { ::std::mem::transmute(smep_support) };
            smep_support as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let enhanced_fast_string_support: u64 =
                unsafe { ::std::mem::transmute(enhanced_fast_string_support) };
            enhanced_fast_string_support as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bmi1_support: u64 = unsafe { ::std::mem::transmute(bmi1_support) };
            bmi1_support as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let bmi2_support: u64 = unsafe { ::std::mem::transmute(bmi2_support) };
            bmi2_support as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let hle_support_deprecated: u64 =
                unsafe { ::std::mem::transmute(hle_support_deprecated) };
            hle_support_deprecated as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rtm_support_deprecated: u64 =
                unsafe { ::std::mem::transmute(rtm_support_deprecated) };
            rtm_support_deprecated as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let movbe_support: u64 = unsafe { ::std::mem::transmute(movbe_support) };
            movbe_support as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let npiep1_support: u64 = unsafe { ::std::mem::transmute(npiep1_support) };
            npiep1_support as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dep_x87_fpu_save_support: u64 =
                unsafe { ::std::mem::transmute(dep_x87_fpu_save_support) };
            dep_x87_fpu_save_support as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let rd_seed_support: u64 = unsafe { ::std::mem::transmute(rd_seed_support) };
            rd_seed_support as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let adx_support: u64 = unsafe { ::std::mem::transmute(adx_support) };
            adx_support as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let intel_prefetch_support: u64 =
                unsafe { ::std::mem::transmute(intel_prefetch_support) };
            intel_prefetch_support as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let smap_support: u64 = unsafe { ::std::mem::transmute(smap_support) };
            smap_support as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let hle_support: u64 = unsafe { ::std::mem::transmute(hle_support) };
            hle_support as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let rtm_support: u64 = unsafe { ::std::mem::transmute(rtm_support) };
            rtm_support as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let rdtscp_support: u64 = unsafe { ::std::mem::transmute(rdtscp_support) };
            rdtscp_support as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let clflushopt_support: u64 = unsafe { ::std::mem::transmute(clflushopt_support) };
            clflushopt_support as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let clwb_support: u64 = unsafe { ::std::mem::transmute(clwb_support) };
            clwb_support as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let sha_support: u64 = unsafe { ::std::mem::transmute(sha_support) };
            sha_support as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let x87_pointers_saved_support: u64 =
                unsafe { ::std::mem::transmute(x87_pointers_saved_support) };
            x87_pointers_saved_support as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let invpcid_support: u64 = unsafe { ::std::mem::transmute(invpcid_support) };
            invpcid_support as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let ibrs_support: u64 = unsafe { ::std::mem::transmute(ibrs_support) };
            ibrs_support as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let stibp_support: u64 = unsafe { ::std::mem::transmute(stibp_support) };
            stibp_support as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let ibpb_support: u64 = unsafe { ::std::mem::transmute(ibpb_support) };
            ibpb_support as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let unrestricted_guest_support: u64 =
                unsafe { ::std::mem::transmute(unrestricted_guest_support) };
            unrestricted_guest_support as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let mdd_support: u64 = unsafe { ::std::mem::transmute(mdd_support) };
            mdd_support as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let fast_short_rep_mov_support: u64 =
                unsafe { ::std::mem::transmute(fast_short_rep_mov_support) };
            fast_short_rep_mov_support as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let l1dcache_flush_support: u64 =
                unsafe { ::std::mem::transmute(l1dcache_flush_support) };
            l1dcache_flush_support as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let rdcl_no_support: u64 = unsafe { ::std::mem::transmute(rdcl_no_support) };
            rdcl_no_support as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let ibrs_all_support: u64 = unsafe { ::std::mem::transmute(ibrs_all_support) };
            ibrs_all_support as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let skip_l1df_support: u64 = unsafe { ::std::mem::transmute(skip_l1df_support) };
            skip_l1df_support as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let ssb_no_support: u64 = unsafe { ::std::mem::transmute(ssb_no_support) };
            ssb_no_support as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let rsb_a_no_support: u64 = unsafe { ::std::mem::transmute(rsb_a_no_support) };
            rsb_a_no_support as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let virt_spec_ctrl_support: u64 =
                unsafe { ::std::mem::transmute(virt_spec_ctrl_support) };
            virt_spec_ctrl_support as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let rd_pid_support: u64 = unsafe { ::std::mem::transmute(rd_pid_support) };
            rd_pid_support as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let umip_support: u64 = unsafe { ::std::mem::transmute(umip_support) };
            umip_support as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let mbs_no_support: u64 = unsafe { ::std::mem::transmute(mbs_no_support) };
            mbs_no_support as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let mb_clear_support: u64 = unsafe { ::std::mem::transmute(mb_clear_support) };
            mb_clear_support as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let taa_no_support: u64 = unsafe { ::std::mem::transmute(taa_no_support) };
            taa_no_support as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let tsx_ctrl_support: u64 = unsafe { ::std::mem::transmute(tsx_ctrl_support) };
            tsx_ctrl_support as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let reserved_bank0: u64 = unsafe { ::std::mem::transmute(reserved_bank0) };
            reserved_bank0 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let acount_mcount_support: u64 =
                unsafe { ::std::mem::transmute(acount_mcount_support) };
            acount_mcount_support as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let tsc_invariant_support: u64 =
                unsafe { ::std::mem::transmute(tsc_invariant_support) };
            tsc_invariant_support as u64
        });
        __bindgen_bitfield_unit.set(66usize, 1u8, {
            let cl_zero_support: u64 = unsafe { ::std::mem::transmute(cl_zero_support) };
            cl_zero_support as u64
        });
        __bindgen_bitfield_unit.set(67usize, 1u8, {
            let rdpru_support: u64 = unsafe { ::std::mem::transmute(rdpru_support) };
            rdpru_support as u64
        });
        __bindgen_bitfield_unit.set(68usize, 1u8, {
            let la57_support: u64 = unsafe { ::std::mem::transmute(la57_support) };
            la57_support as u64
        });
        __bindgen_bitfield_unit.set(69usize, 1u8, {
            let mbec_support: u64 = unsafe { ::std::mem::transmute(mbec_support) };
            mbec_support as u64
        });
        __bindgen_bitfield_unit.set(70usize, 1u8, {
            let nested_virt_support: u64 = unsafe { ::std::mem::transmute(nested_virt_support) };
            nested_virt_support as u64
        });
        __bindgen_bitfield_unit.set(71usize, 1u8, {
            let psfd_support: u64 = unsafe { ::std::mem::transmute(psfd_support) };
            psfd_support as u64
        });
        __bindgen_bitfield_unit.set(72usize, 1u8, {
            let cet_ss_support: u64 = unsafe { ::std::mem::transmute(cet_ss_support) };
            cet_ss_support as u64
        });
        __bindgen_bitfield_unit.set(73usize, 1u8, {
            let cet_ibt_support: u64 = unsafe { ::std::mem::transmute(cet_ibt_support) };
            cet_ibt_support as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let vmx_exception_inject_support: u64 =
                unsafe { ::std::mem::transmute(vmx_exception_inject_support) };
            vmx_exception_inject_support as u64
        });
        __bindgen_bitfield_unit.set(75usize, 1u8, {
            let enqcmd_support: u64 = unsafe { ::std::mem::transmute(enqcmd_support) };
            enqcmd_support as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let umwait_tpause_support: u64 =
                unsafe { ::std::mem::transmute(umwait_tpause_support) };
            umwait_tpause_support as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let movdiri_support: u64 = unsafe { ::std::mem::transmute(movdiri_support) };
            movdiri_support as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let movdir64b_support: u64 = unsafe { ::std::mem::transmute(movdir64b_support) };
            movdir64b_support as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let cldemote_support: u64 = unsafe { ::std::mem::transmute(cldemote_support) };
            cldemote_support as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let serialize_support: u64 = unsafe { ::std::mem::transmute(serialize_support) };
            serialize_support as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let tsc_deadline_tmr_support: u64 =
                unsafe { ::std::mem::transmute(tsc_deadline_tmr_support) };
            tsc_deadline_tmr_support as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let tsc_adjust_support: u64 = unsafe { ::std::mem::transmute(tsc_adjust_support) };
            tsc_adjust_support as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let fzlrep_movsb: u64 = unsafe { ::std::mem::transmute(fzlrep_movsb) };
            fzlrep_movsb as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let fsrep_stosb: u64 = unsafe { ::std::mem::transmute(fsrep_stosb) };
            fsrep_stosb as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let fsrep_cmpsb: u64 = unsafe { ::std::mem::transmute(fsrep_cmpsb) };
            fsrep_cmpsb as u64
        });
        __bindgen_bitfield_unit.set(86usize, 42u8, {
            let reserved_bank1: u64 = unsafe { ::std::mem::transmute(reserved_bank1) };
            reserved_bank1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_processor_features() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_processor_features> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_features>(),
        16usize,
        concat!("Size of: ", stringify!(hv_partition_processor_features))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_features>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_partition_processor_features))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_processor_features),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_processor_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_processor_xsave_features {
    pub __bindgen_anon_1: hv_partition_processor_xsave_features__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_processor_xsave_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_processor_xsave_features__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_xsave_features__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_processor_xsave_features__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_xsave_features__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_processor_xsave_features__bindgen_ty_1)
        )
    );
}
impl hv_partition_processor_xsave_features__bindgen_ty_1 {
    #[inline]
    pub fn xsave_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsave_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xsaveopt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsaveopt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xsave_support: __u64,
        xsaveopt_support: __u64,
        avx_support: __u64,
        reserved1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xsave_support: u64 = unsafe { ::std::mem::transmute(xsave_support) };
            xsave_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xsaveopt_support: u64 = unsafe { ::std::mem::transmute(xsaveopt_support) };
            xsaveopt_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let avx_support: u64 = unsafe { ::std::mem::transmute(avx_support) };
            avx_support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_processor_xsave_features() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_processor_xsave_features> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_xsave_features>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_processor_xsave_features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_xsave_features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_processor_xsave_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_processor_xsave_features),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_processor_xsave_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_partition_creation_properties {
    pub disabled_processor_features: hv_partition_processor_features,
    pub disabled_processor_xsave_features: hv_partition_processor_xsave_features,
}
#[test]
fn bindgen_test_layout_hv_partition_creation_properties() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_creation_properties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_creation_properties>(),
        24usize,
        concat!("Size of: ", stringify!(hv_partition_creation_properties))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_creation_properties>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_creation_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disabled_processor_features) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_creation_properties),
            "::",
            stringify!(disabled_processor_features)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disabled_processor_xsave_features) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_creation_properties),
            "::",
            stringify!(disabled_processor_xsave_features)
        )
    );
}
impl Default for hv_partition_creation_properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_INVALID:
    hv_partition_isolation_state = 0;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_INSECURE_CLEAN:
    hv_partition_isolation_state = 1;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_INSECURE_DIRTY:
    hv_partition_isolation_state = 2;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_SECURE: hv_partition_isolation_state =
    3;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_SECURE_DIRTY:
    hv_partition_isolation_state = 4;
pub const hv_partition_isolation_state_HV_PARTITION_ISOLATION_SECURE_TERMINATING:
    hv_partition_isolation_state = 5;
pub type hv_partition_isolation_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_isolation_control {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_partition_isolation_control__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_isolation_control__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_isolation_control__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_isolation_control__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_isolation_control__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_isolation_control__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_isolation_control__bindgen_ty_1)
        )
    );
}
impl hv_partition_isolation_control__bindgen_ty_1 {
    #[inline]
    pub fn runnable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_runnable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        runnable: __u64,
        reserved_z: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let runnable: u64 = unsafe { ::std::mem::transmute(runnable) };
            runnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved_z: u64 = unsafe { ::std::mem::transmute(reserved_z) };
            reserved_z as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_isolation_control() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_isolation_control> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_isolation_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_partition_isolation_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_isolation_control>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_partition_isolation_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_isolation_control),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_isolation_control {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_synthetic_processor_features {
    pub as_uint64: [__u64; 1usize],
    pub __bindgen_anon_1: hv_partition_synthetic_processor_features__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_synthetic_processor_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_synthetic_processor_features__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_synthetic_processor_features__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_synthetic_processor_features__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_synthetic_processor_features__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_synthetic_processor_features__bindgen_ty_1)
        )
    );
}
impl hv_partition_synthetic_processor_features__bindgen_ty_1 {
    #[inline]
    pub fn hypervisor_present(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hypervisor_present(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hv1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hv1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_vp_run_time_reg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_vp_run_time_reg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_partition_reference_counter(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_partition_reference_counter(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_synic_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_synic_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_synthetic_timer_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_synthetic_timer_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_intr_ctrl_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_intr_ctrl_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_hypercall_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_hypercall_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_vp_index(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_vp_index(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_partition_reference_tsc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_partition_reference_tsc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_guest_idle_reg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_guest_idle_reg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_frequency_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_frequency_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z12(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z12(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z13(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z13(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z14(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z14(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_extended_gva_ranges_for_flush_virtual_address_list(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_extended_gva_ranges_for_flush_virtual_address_list(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z17(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z17(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_hypercall_output(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fast_hypercall_output(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z19(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z19(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start_virtual_processor(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_start_virtual_processor(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z21(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z21(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_synthetic_timers(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_direct_synthetic_timers(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z23(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z23(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_processor_masks(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_extended_processor_masks(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tb_flush_hypercalls(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tb_flush_hypercalls(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synthetic_cluster_ipi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_synthetic_cluster_ipi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn notify_long_spin_wait(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_notify_long_spin_wait(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn query_numa_distance(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_query_numa_distance(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn signal_events(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_signal_events(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn retarget_device_interrupt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_retarget_device_interrupt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_time(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_restore_time(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enlightened_vmcs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enlightened_vmcs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 31u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hypervisor_present: __u64,
        hv1: __u64,
        access_vp_run_time_reg: __u64,
        access_partition_reference_counter: __u64,
        access_synic_regs: __u64,
        access_synthetic_timer_regs: __u64,
        access_intr_ctrl_regs: __u64,
        access_hypercall_regs: __u64,
        access_vp_index: __u64,
        access_partition_reference_tsc: __u64,
        access_guest_idle_reg: __u64,
        access_frequency_regs: __u64,
        reserved_z12: __u64,
        reserved_z13: __u64,
        reserved_z14: __u64,
        enable_extended_gva_ranges_for_flush_virtual_address_list: __u64,
        reserved_z16: __u64,
        reserved_z17: __u64,
        fast_hypercall_output: __u64,
        reserved_z19: __u64,
        start_virtual_processor: __u64,
        reserved_z21: __u64,
        direct_synthetic_timers: __u64,
        reserved_z23: __u64,
        extended_processor_masks: __u64,
        tb_flush_hypercalls: __u64,
        synthetic_cluster_ipi: __u64,
        notify_long_spin_wait: __u64,
        query_numa_distance: __u64,
        signal_events: __u64,
        retarget_device_interrupt: __u64,
        restore_time: __u64,
        enlightened_vmcs: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hypervisor_present: u64 = unsafe { ::std::mem::transmute(hypervisor_present) };
            hypervisor_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hv1: u64 = unsafe { ::std::mem::transmute(hv1) };
            hv1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let access_vp_run_time_reg: u64 =
                unsafe { ::std::mem::transmute(access_vp_run_time_reg) };
            access_vp_run_time_reg as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let access_partition_reference_counter: u64 =
                unsafe { ::std::mem::transmute(access_partition_reference_counter) };
            access_partition_reference_counter as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let access_synic_regs: u64 = unsafe { ::std::mem::transmute(access_synic_regs) };
            access_synic_regs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let access_synthetic_timer_regs: u64 =
                unsafe { ::std::mem::transmute(access_synthetic_timer_regs) };
            access_synthetic_timer_regs as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let access_intr_ctrl_regs: u64 =
                unsafe { ::std::mem::transmute(access_intr_ctrl_regs) };
            access_intr_ctrl_regs as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let access_hypercall_regs: u64 =
                unsafe { ::std::mem::transmute(access_hypercall_regs) };
            access_hypercall_regs as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let access_vp_index: u64 = unsafe { ::std::mem::transmute(access_vp_index) };
            access_vp_index as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let access_partition_reference_tsc: u64 =
                unsafe { ::std::mem::transmute(access_partition_reference_tsc) };
            access_partition_reference_tsc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let access_guest_idle_reg: u64 =
                unsafe { ::std::mem::transmute(access_guest_idle_reg) };
            access_guest_idle_reg as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let access_frequency_regs: u64 =
                unsafe { ::std::mem::transmute(access_frequency_regs) };
            access_frequency_regs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved_z12: u64 = unsafe { ::std::mem::transmute(reserved_z12) };
            reserved_z12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved_z13: u64 = unsafe { ::std::mem::transmute(reserved_z13) };
            reserved_z13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved_z14: u64 = unsafe { ::std::mem::transmute(reserved_z14) };
            reserved_z14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enable_extended_gva_ranges_for_flush_virtual_address_list: u64 = unsafe {
                ::std::mem::transmute(enable_extended_gva_ranges_for_flush_virtual_address_list)
            };
            enable_extended_gva_ranges_for_flush_virtual_address_list as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved_z16: u64 = unsafe { ::std::mem::transmute(reserved_z16) };
            reserved_z16 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let reserved_z17: u64 = unsafe { ::std::mem::transmute(reserved_z17) };
            reserved_z17 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let fast_hypercall_output: u64 =
                unsafe { ::std::mem::transmute(fast_hypercall_output) };
            fast_hypercall_output as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let reserved_z19: u64 = unsafe { ::std::mem::transmute(reserved_z19) };
            reserved_z19 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let start_virtual_processor: u64 =
                unsafe { ::std::mem::transmute(start_virtual_processor) };
            start_virtual_processor as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved_z21: u64 = unsafe { ::std::mem::transmute(reserved_z21) };
            reserved_z21 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let direct_synthetic_timers: u64 =
                unsafe { ::std::mem::transmute(direct_synthetic_timers) };
            direct_synthetic_timers as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved_z23: u64 = unsafe { ::std::mem::transmute(reserved_z23) };
            reserved_z23 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let extended_processor_masks: u64 =
                unsafe { ::std::mem::transmute(extended_processor_masks) };
            extended_processor_masks as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let tb_flush_hypercalls: u64 = unsafe { ::std::mem::transmute(tb_flush_hypercalls) };
            tb_flush_hypercalls as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let synthetic_cluster_ipi: u64 =
                unsafe { ::std::mem::transmute(synthetic_cluster_ipi) };
            synthetic_cluster_ipi as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let notify_long_spin_wait: u64 =
                unsafe { ::std::mem::transmute(notify_long_spin_wait) };
            notify_long_spin_wait as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let query_numa_distance: u64 = unsafe { ::std::mem::transmute(query_numa_distance) };
            query_numa_distance as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let signal_events: u64 = unsafe { ::std::mem::transmute(signal_events) };
            signal_events as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let retarget_device_interrupt: u64 =
                unsafe { ::std::mem::transmute(retarget_device_interrupt) };
            retarget_device_interrupt as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let restore_time: u64 = unsafe { ::std::mem::transmute(restore_time) };
            restore_time as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let enlightened_vmcs: u64 = unsafe { ::std::mem::transmute(enlightened_vmcs) };
            enlightened_vmcs as u64
        });
        __bindgen_bitfield_unit.set(33usize, 31u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_synthetic_processor_features() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_synthetic_processor_features> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_synthetic_processor_features>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_synthetic_processor_features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_synthetic_processor_features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_synthetic_processor_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_synthetic_processor_features),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_synthetic_processor_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_isolation_properties {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_partition_isolation_properties__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_partition_isolation_properties__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_isolation_properties__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_isolation_properties__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_isolation_properties__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_isolation_properties__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_isolation_properties__bindgen_ty_1)
        )
    );
}
impl hv_partition_isolation_properties__bindgen_ty_1 {
    #[inline]
    pub fn isolation_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_isolation_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn isolation_host_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_isolation_host_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd_z(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd_z(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn shared_gpa_boundary_page_number(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_shared_gpa_boundary_page_number(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isolation_type: __u64,
        isolation_host_type: __u64,
        rsvd_z: __u64,
        shared_gpa_boundary_page_number: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let isolation_type: u64 = unsafe { ::std::mem::transmute(isolation_type) };
            isolation_type as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let isolation_host_type: u64 = unsafe { ::std::mem::transmute(isolation_host_type) };
            isolation_host_type as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let rsvd_z: u64 = unsafe { ::std::mem::transmute(rsvd_z) };
            rsvd_z as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let shared_gpa_boundary_page_number: u64 =
                unsafe { ::std::mem::transmute(shared_gpa_boundary_page_number) };
            shared_gpa_boundary_page_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_isolation_properties() {
    const UNINIT: ::std::mem::MaybeUninit<hv_partition_isolation_properties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_partition_isolation_properties>(),
        8usize,
        concat!("Size of: ", stringify!(hv_partition_isolation_properties))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_isolation_properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_isolation_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_isolation_properties),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_isolation_properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_create_partition {
    pub flags: __u64,
    pub proximity_domain_info: hv_proximity_domain_info,
    pub compatibility_version: __u32,
    pub padding: __u32,
    pub partition_creation_properties: hv_partition_creation_properties,
    pub isolation_properties: hv_partition_isolation_properties,
}
#[test]
fn bindgen_test_layout_hv_input_create_partition() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_create_partition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_create_partition>(),
        56usize,
        concat!("Size of: ", stringify!(hv_input_create_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_create_partition>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_create_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_partition),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proximity_domain_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_partition),
            "::",
            stringify!(proximity_domain_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compatibility_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_partition),
            "::",
            stringify!(compatibility_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_partition),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).partition_creation_properties) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_partition),
            "::",
            stringify!(partition_creation_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isolation_properties) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_partition),
            "::",
            stringify!(isolation_properties)
        )
    );
}
impl Default for hv_input_create_partition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_create_partition {
    pub partition_id: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_create_partition() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_create_partition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_create_partition>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_create_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_create_partition>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_create_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_create_partition),
            "::",
            stringify!(partition_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_initialize_partition {
    pub partition_id: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_initialize_partition() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_initialize_partition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_initialize_partition>(),
        8usize,
        concat!("Size of: ", stringify!(hv_input_initialize_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_initialize_partition>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_initialize_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_initialize_partition),
            "::",
            stringify!(partition_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_finalize_partition {
    pub partition_id: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_finalize_partition() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_finalize_partition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_finalize_partition>(),
        8usize,
        concat!("Size of: ", stringify!(hv_input_finalize_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_finalize_partition>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_finalize_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_finalize_partition),
            "::",
            stringify!(partition_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_delete_partition {
    pub partition_id: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_delete_partition() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_delete_partition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_delete_partition>(),
        8usize,
        concat!("Size of: ", stringify!(hv_input_delete_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_delete_partition>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_delete_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_delete_partition),
            "::",
            stringify!(partition_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_get_partition_property {
    pub partition_id: __u64,
    pub property_code: __u32,
    pub padding: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_get_partition_property() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_partition_property> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_partition_property>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_get_partition_property))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_partition_property>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_get_partition_property))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_partition_property),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_partition_property),
            "::",
            stringify!(property_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_partition_property),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_get_partition_property {
    pub property_value: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_get_partition_property() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_get_partition_property> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_partition_property>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_get_partition_property))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_partition_property>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_output_get_partition_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_partition_property),
            "::",
            stringify!(property_value)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_set_partition_property {
    pub partition_id: __u64,
    pub property_code: __u32,
    pub padding: __u32,
    pub property_value: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_set_partition_property() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_set_partition_property> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_set_partition_property>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_set_partition_property))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_set_partition_property>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_set_partition_property))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_partition_property),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_partition_property),
            "::",
            stringify!(property_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_partition_property),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_partition_property),
            "::",
            stringify!(property_value)
        )
    );
}
pub const hv_vp_state_page_type_HV_VP_STATE_PAGE_REGISTERS: hv_vp_state_page_type = 0;
pub const hv_vp_state_page_type_HV_VP_STATE_PAGE_INTERCEPT_MESSAGE: hv_vp_state_page_type = 1;
pub const hv_vp_state_page_type_HV_VP_STATE_PAGE_COUNT: hv_vp_state_page_type = 2;
pub type hv_vp_state_page_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_map_vp_state_page {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub type_: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_map_vp_state_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_map_vp_state_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_map_vp_state_page>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_map_vp_state_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_map_vp_state_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_map_vp_state_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_vp_state_page),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_vp_state_page),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_map_vp_state_page),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_map_vp_state_page {
    pub map_location: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_map_vp_state_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_map_vp_state_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_map_vp_state_page>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_map_vp_state_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_map_vp_state_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_map_vp_state_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_map_vp_state_page),
            "::",
            stringify!(map_location)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_unmap_vp_state_page {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub type_: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_unmap_vp_state_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_unmap_vp_state_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_unmap_vp_state_page>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_unmap_vp_state_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_unmap_vp_state_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_unmap_vp_state_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_vp_state_page),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_vp_state_page),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_unmap_vp_state_page),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_cpuid_leaf_info {
    pub eax: __u32,
    pub ecx: __u32,
    pub xfem: __u64,
    pub xss: __u64,
}
#[test]
fn bindgen_test_layout_hv_cpuid_leaf_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_cpuid_leaf_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_cpuid_leaf_info>(),
        24usize,
        concat!("Size of: ", stringify!(hv_cpuid_leaf_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_cpuid_leaf_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_cpuid_leaf_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_cpuid_leaf_info),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_cpuid_leaf_info),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_cpuid_leaf_info),
            "::",
            stringify!(xfem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_cpuid_leaf_info),
            "::",
            stringify!(xss)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_get_vp_cpuid_values_flags {
    pub as_uint32: __u32,
    pub __bindgen_anon_1: hv_get_vp_cpuid_values_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_get_vp_cpuid_values_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_get_vp_cpuid_values_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_get_vp_cpuid_values_flags__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_get_vp_cpuid_values_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_get_vp_cpuid_values_flags__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_get_vp_cpuid_values_flags__bindgen_ty_1)
        )
    );
}
impl hv_get_vp_cpuid_values_flags__bindgen_ty_1 {
    #[inline]
    pub fn use_vp_xfem_xss(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_vp_xfem_xss(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apply_registered_values(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apply_registered_values(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_vp_xfem_xss: __u32,
        apply_registered_values: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_vp_xfem_xss: u32 = unsafe { ::std::mem::transmute(use_vp_xfem_xss) };
            use_vp_xfem_xss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let apply_registered_values: u32 =
                unsafe { ::std::mem::transmute(apply_registered_values) };
            apply_registered_values as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_get_vp_cpuid_values_flags() {
    const UNINIT: ::std::mem::MaybeUninit<hv_get_vp_cpuid_values_flags> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_get_vp_cpuid_values_flags>(),
        4usize,
        concat!("Size of: ", stringify!(hv_get_vp_cpuid_values_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_get_vp_cpuid_values_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_get_vp_cpuid_values_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_get_vp_cpuid_values_flags),
            "::",
            stringify!(as_uint32)
        )
    );
}
impl Default for hv_get_vp_cpuid_values_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_get_vp_cpuid_values {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub flags: hv_get_vp_cpuid_values_flags,
    pub reserved: __u32,
    pub padding: __u32,
    pub cpuid_leaf_info: __IncompleteArrayField<hv_cpuid_leaf_info>,
}
#[test]
fn bindgen_test_layout_hv_input_get_vp_cpuid_values() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_vp_cpuid_values> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_vp_cpuid_values>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_get_vp_cpuid_values))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_vp_cpuid_values>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_get_vp_cpuid_values))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_cpuid_values),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_cpuid_values),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_cpuid_values),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_cpuid_values),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_cpuid_values),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuid_leaf_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_cpuid_values),
            "::",
            stringify!(cpuid_leaf_info)
        )
    );
}
impl Default for hv_input_get_vp_cpuid_values {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_output_get_vp_cpuid_values {
    pub as_uint32: [__u32; 4usize],
    pub __bindgen_anon_1: hv_output_get_vp_cpuid_values__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_get_vp_cpuid_values__bindgen_ty_1 {
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
}
#[test]
fn bindgen_test_layout_hv_output_get_vp_cpuid_values__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_get_vp_cpuid_values__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_vp_cpuid_values__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_output_get_vp_cpuid_values__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_vp_cpuid_values__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_output_get_vp_cpuid_values__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_vp_cpuid_values__bindgen_ty_1),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_vp_cpuid_values__bindgen_ty_1),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_vp_cpuid_values__bindgen_ty_1),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_vp_cpuid_values__bindgen_ty_1),
            "::",
            stringify!(edx)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_output_get_vp_cpuid_values() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_get_vp_cpuid_values> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_vp_cpuid_values>(),
        16usize,
        concat!("Size of: ", stringify!(hv_output_get_vp_cpuid_values))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_vp_cpuid_values>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_output_get_vp_cpuid_values))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_vp_cpuid_values),
            "::",
            stringify!(as_uint32)
        )
    );
}
impl Default for hv_output_get_vp_cpuid_values {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_SUCCESS: hv_translate_gva_result_code = 0;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_PAGE_NOT_PRESENT:
    hv_translate_gva_result_code = 1;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_PRIVILEGE_VIOLATION:
    hv_translate_gva_result_code = 2;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_INVALIDE_PAGE_TABLE_FLAGS:
    hv_translate_gva_result_code = 3;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_UNMAPPED: hv_translate_gva_result_code =
    4;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_NO_READ_ACCESS:
    hv_translate_gva_result_code = 5;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_NO_WRITE_ACCESS:
    hv_translate_gva_result_code = 6;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_ILLEGAL_OVERLAY_ACCESS:
    hv_translate_gva_result_code = 7;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_INTERCEPT: hv_translate_gva_result_code = 8;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_UNACCEPTED:
    hv_translate_gva_result_code = 9;
pub type hv_translate_gva_result_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_translate_gva_result {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_translate_gva_result__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_translate_gva_result__bindgen_ty_1 {
    pub result_code: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_translate_gva_result__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_translate_gva_result__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_translate_gva_result__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_translate_gva_result__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_translate_gva_result__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_translate_gva_result__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_translate_gva_result__bindgen_ty_1),
            "::",
            stringify!(result_code)
        )
    );
}
impl hv_translate_gva_result__bindgen_ty_1 {
    #[inline]
    pub fn cache_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cache_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn overlay_page(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlay_page(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache_type: __u32,
        overlay_page: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cache_type: u32 = unsafe { ::std::mem::transmute(cache_type) };
            cache_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let overlay_page: u32 = unsafe { ::std::mem::transmute(overlay_page) };
            overlay_page as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_translate_gva_result() {
    const UNINIT: ::std::mem::MaybeUninit<hv_translate_gva_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_translate_gva_result>(),
        8usize,
        concat!("Size of: ", stringify!(hv_translate_gva_result))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_translate_gva_result>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_translate_gva_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_translate_gva_result),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_translate_gva_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_apic_eoi_message {
    pub vp_index: __u32,
    pub interrupt_vector: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_apic_eoi_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_apic_eoi_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_apic_eoi_message>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_apic_eoi_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_apic_eoi_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_apic_eoi_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_apic_eoi_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_vector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_apic_eoi_message),
            "::",
            stringify!(interrupt_vector)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_opaque_intercept_message {
    pub vp_index: __u32,
}
#[test]
fn bindgen_test_layout_hv_opaque_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_opaque_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_opaque_intercept_message>(),
        4usize,
        concat!("Size of: ", stringify!(hv_opaque_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_opaque_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_opaque_intercept_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_opaque_intercept_message),
            "::",
            stringify!(vp_index)
        )
    );
}
pub const hv_port_type_HV_PORT_TYPE_MESSAGE: hv_port_type = 1;
pub const hv_port_type_HV_PORT_TYPE_EVENT: hv_port_type = 2;
pub const hv_port_type_HV_PORT_TYPE_MONITOR: hv_port_type = 3;
pub const hv_port_type_HV_PORT_TYPE_DOORBELL: hv_port_type = 4;
pub type hv_port_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_port_info {
    pub port_type: __u32,
    pub padding: __u32,
    pub __bindgen_anon_1: hv_port_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_port_info__bindgen_ty_1 {
    pub message_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_1,
    pub event_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_2,
    pub monitor_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_3,
    pub doorbell_port_info: hv_port_info__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_1 {
    pub target_sint: __u32,
    pub target_vp: __u32,
    pub rsvdz: __u64,
}
#[test]
fn bindgen_test_layout_hv_port_info__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_info__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_sint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(target_sint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(target_vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsvdz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_2 {
    pub target_sint: __u32,
    pub target_vp: __u32,
    pub base_flag_number: __u16,
    pub flag_count: __u16,
    pub rsvdz: __u32,
}
#[test]
fn bindgen_test_layout_hv_port_info__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_info__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_sint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_sint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(target_vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_flag_number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(base_flag_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag_count) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(flag_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvdz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_3 {
    pub monitor_address: __u64,
    pub rsvdz: __u64,
}
#[test]
fn bindgen_test_layout_hv_port_info__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_info__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(monitor_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(rsvdz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_port_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_sint: __u32,
    pub target_vp: __u32,
    pub rsvdz: __u64,
}
#[test]
fn bindgen_test_layout_hv_port_info__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_info__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_info__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_info__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_sint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(target_sint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(target_vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(rsvdz)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_port_info__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_info__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_info__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(hv_port_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_port_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_port_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1),
            "::",
            stringify!(message_port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_port_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1),
            "::",
            stringify!(event_port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_port_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1),
            "::",
            stringify!(monitor_port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doorbell_port_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info__bindgen_ty_1),
            "::",
            stringify!(doorbell_port_info)
        )
    );
}
impl Default for hv_port_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_port_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_port_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_port_info>(),
        24usize,
        concat!("Size of: ", stringify!(hv_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_port_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info),
            "::",
            stringify!(port_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_info),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for hv_port_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_connection_info {
    pub port_type: __u32,
    pub padding: __u32,
    pub __bindgen_anon_1: hv_connection_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_connection_info__bindgen_ty_1 {
    pub message_connection_info: hv_connection_info__bindgen_ty_1__bindgen_ty_1,
    pub event_connection_info: hv_connection_info__bindgen_ty_1__bindgen_ty_2,
    pub monitor_connection_info: hv_connection_info__bindgen_ty_1__bindgen_ty_3,
    pub doorbell_connection_info: hv_connection_info__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_connection_info__bindgen_ty_1__bindgen_ty_1 {
    pub rsvdz: __u64,
}
#[test]
fn bindgen_test_layout_hv_connection_info__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_info__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsvdz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_connection_info__bindgen_ty_1__bindgen_ty_2 {
    pub rsvdz: __u64,
}
#[test]
fn bindgen_test_layout_hv_connection_info__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_info__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvdz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_connection_info__bindgen_ty_1__bindgen_ty_3 {
    pub monitor_address: __u64,
}
#[test]
fn bindgen_test_layout_hv_connection_info__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_info__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(monitor_address)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_connection_info__bindgen_ty_1__bindgen_ty_4 {
    pub gpa: __u64,
    pub trigger_value: __u64,
    pub flags: __u64,
}
#[test]
fn bindgen_test_layout_hv_connection_info__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_info__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_4>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_info__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(gpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(trigger_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_connection_info__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_info__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_info__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(hv_connection_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_info__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_connection_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_connection_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1),
            "::",
            stringify!(message_connection_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_connection_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1),
            "::",
            stringify!(event_connection_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_connection_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1),
            "::",
            stringify!(monitor_connection_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doorbell_connection_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info__bindgen_ty_1),
            "::",
            stringify!(doorbell_connection_info)
        )
    );
}
impl Default for hv_connection_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_connection_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_connection_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_connection_info>(),
        32usize,
        concat!("Size of: ", stringify!(hv_connection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_connection_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info),
            "::",
            stringify!(port_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_info),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for hv_connection_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_event_ring {
    pub signal_masked: __u8,
    pub ring_full: __u8,
    pub reserved_z: __u16,
    pub data: [__u32; 63usize],
}
#[test]
fn bindgen_test_layout_hv_synic_event_ring() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_event_ring> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_event_ring>(),
        256usize,
        concat!("Size of: ", stringify!(hv_synic_event_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_event_ring>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_event_ring))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_masked) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_event_ring),
            "::",
            stringify!(signal_masked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_full) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_event_ring),
            "::",
            stringify!(ring_full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_z) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_event_ring),
            "::",
            stringify!(reserved_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_event_ring),
            "::",
            stringify!(data)
        )
    );
}
impl Default for hv_synic_event_ring {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_event_ring_page {
    pub sint_event_ring: [hv_synic_event_ring; 16usize],
}
#[test]
fn bindgen_test_layout_hv_synic_event_ring_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_event_ring_page> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_event_ring_page>(),
        4096usize,
        concat!("Size of: ", stringify!(hv_synic_event_ring_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_event_ring_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_event_ring_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint_event_ring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_event_ring_page),
            "::",
            stringify!(sint_event_ring)
        )
    );
}
impl Default for hv_synic_event_ring_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_synic_scontrol {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_synic_scontrol__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_scontrol__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_synic_scontrol__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_synic_scontrol__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_scontrol__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_scontrol__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_scontrol__bindgen_ty_1))
    );
}
impl hv_synic_scontrol__bindgen_ty_1 {
    #[inline]
    pub fn enable(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: __u64, reserved: __u64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u64 = unsafe { ::std::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_synic_scontrol() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_scontrol> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_scontrol>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_scontrol))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_scontrol>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_synic_scontrol))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_scontrol),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_synic_scontrol {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_synic_siefp {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_synic_siefp__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_siefp__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_synic_siefp__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_synic_siefp__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_siefp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_siefp__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_siefp__bindgen_ty_1))
    );
}
impl hv_synic_siefp__bindgen_ty_1 {
    #[inline]
    pub fn siefp_enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_siefp_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_preserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn base_siefp_gpa(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_base_siefp_gpa(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        siefp_enabled: __u64,
        preserved: __u64,
        base_siefp_gpa: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let siefp_enabled: u64 = unsafe { ::std::mem::transmute(siefp_enabled) };
            siefp_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let preserved: u64 = unsafe { ::std::mem::transmute(preserved) };
            preserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let base_siefp_gpa: u64 = unsafe { ::std::mem::transmute(base_siefp_gpa) };
            base_siefp_gpa as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_synic_siefp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_siefp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_siefp>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_siefp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_siefp>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_synic_siefp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_siefp),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_synic_siefp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_synic_sirbp {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_synic_sirbp__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synic_sirbp__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_synic_sirbp__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_synic_sirbp__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_sirbp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_sirbp__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synic_sirbp__bindgen_ty_1))
    );
}
impl hv_synic_sirbp__bindgen_ty_1 {
    #[inline]
    pub fn sirbp_enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sirbp_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_preserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn base_sirbp_gpa(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_base_sirbp_gpa(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sirbp_enabled: __u64,
        preserved: __u64,
        base_sirbp_gpa: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sirbp_enabled: u64 = unsafe { ::std::mem::transmute(sirbp_enabled) };
            sirbp_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let preserved: u64 = unsafe { ::std::mem::transmute(preserved) };
            preserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let base_sirbp_gpa: u64 = unsafe { ::std::mem::transmute(base_sirbp_gpa) };
            base_sirbp_gpa as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_synic_sirbp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synic_sirbp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synic_sirbp>(),
        8usize,
        concat!("Size of: ", stringify!(hv_synic_sirbp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synic_sirbp>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_synic_sirbp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synic_sirbp),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_synic_sirbp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_interrupt_control {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_interrupt_control__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_interrupt_control__bindgen_ty_1 {
    pub interrupt_type: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_interrupt_control__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_interrupt_control__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_interrupt_control__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_interrupt_control__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_interrupt_control__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_interrupt_control__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_interrupt_control__bindgen_ty_1),
            "::",
            stringify!(interrupt_type)
        )
    );
}
impl hv_interrupt_control__bindgen_ty_1 {
    #[inline]
    pub fn level_triggered(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_triggered(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn logical_dest_mode(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest_mode(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        level_triggered: __u32,
        logical_dest_mode: __u32,
        rsvd: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let level_triggered: u32 = unsafe { ::std::mem::transmute(level_triggered) };
            level_triggered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let logical_dest_mode: u32 = unsafe { ::std::mem::transmute(logical_dest_mode) };
            logical_dest_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let rsvd: u32 = unsafe { ::std::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_interrupt_control() {
    const UNINIT: ::std::mem::MaybeUninit<hv_interrupt_control> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_interrupt_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_interrupt_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_interrupt_control>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_interrupt_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_interrupt_control),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_interrupt_control {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_local_interrupt_controller_state {
    pub apic_id: __u32,
    pub apic_version: __u32,
    pub apic_ldr: __u32,
    pub apic_dfr: __u32,
    pub apic_spurious: __u32,
    pub apic_isr: [__u32; 8usize],
    pub apic_tmr: [__u32; 8usize],
    pub apic_irr: [__u32; 8usize],
    pub apic_esr: __u32,
    pub apic_icr_high: __u32,
    pub apic_icr_low: __u32,
    pub apic_lvt_timer: __u32,
    pub apic_lvt_thermal: __u32,
    pub apic_lvt_perfmon: __u32,
    pub apic_lvt_lint0: __u32,
    pub apic_lvt_lint1: __u32,
    pub apic_lvt_error: __u32,
    pub apic_lvt_cmci: __u32,
    pub apic_error_status: __u32,
    pub apic_initial_count: __u32,
    pub apic_counter_value: __u32,
    pub apic_divide_configuration: __u32,
    pub apic_remote_read: __u32,
}
#[test]
fn bindgen_test_layout_hv_local_interrupt_controller_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_local_interrupt_controller_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_local_interrupt_controller_state>(),
        176usize,
        concat!("Size of: ", stringify!(hv_local_interrupt_controller_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_local_interrupt_controller_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_local_interrupt_controller_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_ldr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_ldr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_dfr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_dfr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_spurious) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_spurious)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_isr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_isr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_tmr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_tmr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_irr) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_irr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_esr) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_icr_high) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_icr_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_icr_low) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_icr_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_timer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_thermal) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_thermal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_perfmon) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_perfmon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_lint0) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_lint0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_lint1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_lint1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_error) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_lvt_cmci) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_cmci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_error_status) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_error_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_initial_count) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_initial_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_counter_value) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_counter_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_divide_configuration) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_divide_configuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apic_remote_read) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_remote_read)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stimer_state {
    pub flags: hv_stimer_state__bindgen_ty_1,
    pub resvd: __u32,
    pub config: __u64,
    pub count: __u64,
    pub adjustment: __u64,
    pub undelivered_exp_time: __u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_stimer_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_stimer_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_stimer_state__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_stimer_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stimer_state__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_stimer_state__bindgen_ty_1))
    );
}
impl hv_stimer_state__bindgen_ty_1 {
    #[inline]
    pub fn undelivered_msg_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_undelivered_msg_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        undelivered_msg_pending: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let undelivered_msg_pending: u32 =
                unsafe { ::std::mem::transmute(undelivered_msg_pending) };
            undelivered_msg_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_stimer_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_stimer_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_stimer_state>(),
        40usize,
        concat!("Size of: ", stringify!(hv_stimer_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_stimer_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_stimer_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resvd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_state),
            "::",
            stringify!(resvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_state),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_state),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adjustment) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_state),
            "::",
            stringify!(adjustment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).undelivered_exp_time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_stimer_state),
            "::",
            stringify!(undelivered_exp_time)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_synthetic_timers_state {
    pub timers: [hv_stimer_state; 4usize],
    pub reserved: [__u64; 5usize],
}
#[test]
fn bindgen_test_layout_hv_synthetic_timers_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_synthetic_timers_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_synthetic_timers_state>(),
        200usize,
        concat!("Size of: ", stringify!(hv_synthetic_timers_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_synthetic_timers_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_synthetic_timers_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synthetic_timers_state),
            "::",
            stringify!(timers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_synthetic_timers_state),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_vp_execution_state {
    pub as_uint16: __u16,
    pub __bindgen_anon_1: hv_x64_vp_execution_state__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_vp_execution_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_vp_execution_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vp_execution_state__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_vp_execution_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vp_execution_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_vp_execution_state__bindgen_ty_1)
        )
    );
}
impl hv_x64_vp_execution_state__bindgen_ty_1 {
    #[inline]
    pub fn cpl(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cpl(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cr0_pe(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cr0_pe(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cr0_am(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cr0_am(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn efer_lma(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_efer_lma(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_active(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_debug_active(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interruption_pending(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_interruption_pending(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vtl(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_vtl(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enclave_mode(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enclave_mode(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interrupt_shadow(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_interrupt_shadow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virtualization_fault_active(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_virtualization_fault_active(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpl: __u16,
        cr0_pe: __u16,
        cr0_am: __u16,
        efer_lma: __u16,
        debug_active: __u16,
        interruption_pending: __u16,
        vtl: __u16,
        enclave_mode: __u16,
        interrupt_shadow: __u16,
        virtualization_fault_active: __u16,
        reserved: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cpl: u16 = unsafe { ::std::mem::transmute(cpl) };
            cpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cr0_pe: u16 = unsafe { ::std::mem::transmute(cr0_pe) };
            cr0_pe as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cr0_am: u16 = unsafe { ::std::mem::transmute(cr0_am) };
            cr0_am as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let efer_lma: u16 = unsafe { ::std::mem::transmute(efer_lma) };
            efer_lma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let debug_active: u16 = unsafe { ::std::mem::transmute(debug_active) };
            debug_active as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let interruption_pending: u16 = unsafe { ::std::mem::transmute(interruption_pending) };
            interruption_pending as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let vtl: u16 = unsafe { ::std::mem::transmute(vtl) };
            vtl as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enclave_mode: u16 = unsafe { ::std::mem::transmute(enclave_mode) };
            enclave_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let interrupt_shadow: u16 = unsafe { ::std::mem::transmute(interrupt_shadow) };
            interrupt_shadow as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let virtualization_fault_active: u16 =
                unsafe { ::std::mem::transmute(virtualization_fault_active) };
            virtualization_fault_active as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_vp_execution_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_vp_execution_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vp_execution_state>(),
        2usize,
        concat!("Size of: ", stringify!(hv_x64_vp_execution_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vp_execution_state>(),
        2usize,
        concat!("Alignment of ", stringify!(hv_x64_vp_execution_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vp_execution_state),
            "::",
            stringify!(as_uint16)
        )
    );
}
impl Default for hv_x64_vp_execution_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_intercept_message_header {
    pub vp_index: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub intercept_access_type: __u8,
    pub execution_state: hv_x64_vp_execution_state,
    pub cs_segment: hv_x64_segment_register,
    pub rip: __u64,
    pub rflags: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_intercept_message_header() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_intercept_message_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_intercept_message_header>(),
        40usize,
        concat!("Size of: ", stringify!(hv_x64_intercept_message_header))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_intercept_message_header>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_intercept_message_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_access_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(intercept_access_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execution_state) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(execution_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs_segment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(cs_segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rflags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(rflags)
        )
    );
}
impl Default for hv_x64_intercept_message_header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hv_x64_intercept_message_header {
    #[inline]
    pub fn instruction_length(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_instruction_length(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cr8(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_cr8(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        instruction_length: __u8,
        cr8: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let instruction_length: u8 = unsafe { ::std::mem::transmute(instruction_length) };
            instruction_length as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let cr8: u8 = unsafe { ::std::mem::transmute(cr8) };
            cr8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_hypercall_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub rax: __u64,
    pub rbx: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub r8: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub xmmregisters: [hv_u128; 6usize],
    pub __bindgen_anon_1: hv_x64_hypercall_intercept_message__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_hypercall_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_hypercall_intercept_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_hypercall_intercept_message__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_hypercall_intercept_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_hypercall_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_hypercall_intercept_message__bindgen_ty_1)
        )
    );
}
impl hv_x64_hypercall_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn isolated(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isolated(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isolated: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isolated: u32 = unsafe { ::std::mem::transmute(isolated) };
            isolated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_hypercall_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_hypercall_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_hypercall_intercept_message>(),
        196usize,
        concat!("Size of: ", stringify!(hv_x64_hypercall_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_hypercall_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_hypercall_intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmmregisters) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(xmmregisters)
        )
    );
}
impl Default for hv_x64_hypercall_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_access_info {
    pub source_value: hv_register_value,
    pub destination_register: __u32,
    pub source_address: __u64,
    pub destination_address: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_register_access_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_register_access_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_access_info>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_register_access_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_access_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_register_access_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(source_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_register) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(destination_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(destination_address)
        )
    );
}
impl Default for hv_x64_register_access_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_register_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub __bindgen_anon_1: hv_x64_register_intercept_message__bindgen_ty_1,
    pub reserved8: __u8,
    pub reserved16: __u16,
    pub register_name: __u32,
    pub access_info: hv_x64_register_access_info,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_register_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_register_intercept_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_register_intercept_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_intercept_message__bindgen_ty_1)
        )
    );
}
impl hv_x64_register_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn is_memory_op(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_memory_op(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_memory_op: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_memory_op: u8 = unsafe { ::std::mem::transmute(is_memory_op) };
            is_memory_op as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_register_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_register_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_intercept_message>(),
        64usize,
        concat!("Size of: ", stringify!(hv_x64_register_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved8) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved16) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(reserved16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_name) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(register_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(access_info)
        )
    );
}
impl Default for hv_x64_register_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_memory_access_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_x64_memory_access_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_memory_access_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_memory_access_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_memory_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_memory_access_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_memory_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_memory_access_info__bindgen_ty_1)
        )
    );
}
impl hv_x64_memory_access_info__bindgen_ty_1 {
    #[inline]
    pub fn gva_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gva_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gva_gpa_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gva_gpa_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hypercall_output_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hypercall_output_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tlb_locked_no_overlay(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tlb_locked_no_overlay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gva_valid: __u8,
        gva_gpa_valid: __u8,
        hypercall_output_pending: __u8,
        tlb_locked_no_overlay: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gva_valid: u8 = unsafe { ::std::mem::transmute(gva_valid) };
            gva_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gva_gpa_valid: u8 = unsafe { ::std::mem::transmute(gva_gpa_valid) };
            gva_gpa_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hypercall_output_pending: u8 =
                unsafe { ::std::mem::transmute(hypercall_output_pending) };
            hypercall_output_pending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tlb_locked_no_overlay: u8 = unsafe { ::std::mem::transmute(tlb_locked_no_overlay) };
            tlb_locked_no_overlay as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_memory_access_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_memory_access_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_memory_access_info>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_memory_access_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_memory_access_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_memory_access_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_access_info),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_x64_memory_access_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_io_port_access_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_x64_io_port_access_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_io_port_access_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_io_port_access_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_io_port_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_io_port_access_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_io_port_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_io_port_access_info__bindgen_ty_1)
        )
    );
}
impl hv_x64_io_port_access_info__bindgen_ty_1 {
    #[inline]
    pub fn access_size(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_access_size(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn string_op(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_string_op(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rep_prefix(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rep_prefix(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        access_size: __u8,
        string_op: __u8,
        rep_prefix: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let access_size: u8 = unsafe { ::std::mem::transmute(access_size) };
            access_size as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let string_op: u8 = unsafe { ::std::mem::transmute(string_op) };
            string_op as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rep_prefix: u8 = unsafe { ::std::mem::transmute(rep_prefix) };
            rep_prefix as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_io_port_access_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_io_port_access_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_io_port_access_info>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_io_port_access_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_io_port_access_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_io_port_access_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_access_info),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_x64_io_port_access_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_exception_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_x64_exception_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_exception_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_exception_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_exception_info__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_exception_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_exception_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_exception_info__bindgen_ty_1)
        )
    );
}
impl hv_x64_exception_info__bindgen_ty_1 {
    #[inline]
    pub fn error_code_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_error_code_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn software_exception(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_software_exception(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        error_code_valid: __u8,
        software_exception: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let error_code_valid: u8 = unsafe { ::std::mem::transmute(error_code_valid) };
            error_code_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let software_exception: u8 = unsafe { ::std::mem::transmute(software_exception) };
            software_exception as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_exception_info() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_exception_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_exception_info>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_exception_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_exception_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_exception_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_info),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_x64_exception_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_memory_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub cache_type: __u32,
    pub instruction_byte_count: __u8,
    pub memory_access_info: hv_x64_memory_access_info,
    pub tpr_priority: __u8,
    pub reserved1: __u8,
    pub guest_virtual_address: __u64,
    pub guest_physical_address: __u64,
    pub instruction_bytes: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_hv_x64_memory_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_memory_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_memory_intercept_message>(),
        80usize,
        concat!("Size of: ", stringify!(hv_x64_memory_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_memory_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_memory_intercept_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(cache_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_byte_count) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(instruction_byte_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_access_info) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(memory_access_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpr_priority) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(tpr_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guest_virtual_address) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(guest_virtual_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guest_physical_address) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(guest_physical_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_bytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(instruction_bytes)
        )
    );
}
impl Default for hv_x64_memory_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_cpuid_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub rax: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rbx: __u64,
    pub default_result_rax: __u64,
    pub default_result_rcx: __u64,
    pub default_result_rdx: __u64,
    pub default_result_rbx: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_cpuid_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_cpuid_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_cpuid_intercept_message>(),
        104usize,
        concat!("Size of: ", stringify!(hv_x64_cpuid_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_cpuid_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_cpuid_intercept_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_result_rax) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_result_rcx) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_result_rdx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_result_rbx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rbx)
        )
    );
}
impl Default for hv_x64_cpuid_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_msr_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub msr_number: __u32,
    pub reserved: __u32,
    pub rdx: __u64,
    pub rax: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_msr_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_msr_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_intercept_message>(),
        64usize,
        concat!("Size of: ", stringify!(hv_x64_msr_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_msr_intercept_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msr_number) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(msr_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(rax)
        )
    );
}
impl Default for hv_x64_msr_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_io_port_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub port_number: __u16,
    pub access_info: hv_x64_io_port_access_info,
    pub instruction_byte_count: __u8,
    pub reserved: __u32,
    pub rax: __u64,
    pub instruction_bytes: [__u8; 16usize],
    pub ds_segment: hv_x64_segment_register,
    pub es_segment: hv_x64_segment_register,
    pub rcx: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_io_port_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_io_port_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_io_port_intercept_message>(),
        128usize,
        concat!("Size of: ", stringify!(hv_x64_io_port_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_io_port_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_io_port_intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_number) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(port_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_info) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(access_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_byte_count) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(instruction_byte_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_bytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(instruction_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ds_segment) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(ds_segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).es_segment) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(es_segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rdi)
        )
    );
}
impl Default for hv_x64_io_port_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_exception_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub exception_vector: __u16,
    pub exception_info: hv_x64_exception_info,
    pub instruction_byte_count: __u8,
    pub error_code: __u32,
    pub exception_parameter: __u64,
    pub reserved: __u64,
    pub instruction_bytes: [__u8; 16usize],
    pub ds_segment: hv_x64_segment_register,
    pub ss_segment: hv_x64_segment_register,
    pub rax: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rbx: __u64,
    pub rsp: __u64,
    pub rbp: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_exception_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_exception_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_exception_intercept_message>(),
        240usize,
        concat!("Size of: ", stringify!(hv_x64_exception_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_exception_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_exception_intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_vector) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(exception_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_info) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(exception_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_byte_count) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(instruction_byte_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_parameter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(exception_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction_bytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(instruction_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ds_segment) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(ds_segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_segment) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(ss_segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r11) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r12) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r13) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r14) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r15) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r15)
        )
    );
}
impl Default for hv_x64_exception_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_invalid_vp_register_message {
    pub vp_index: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_invalid_vp_register_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_invalid_vp_register_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_invalid_vp_register_message>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_invalid_vp_register_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_invalid_vp_register_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_invalid_vp_register_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_invalid_vp_register_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_invalid_vp_register_message),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_unrecoverable_exception_message {
    pub header: hv_x64_intercept_message_header,
}
#[test]
fn bindgen_test_layout_hv_x64_unrecoverable_exception_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_unrecoverable_exception_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_unrecoverable_exception_message>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_unrecoverable_exception_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_unrecoverable_exception_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_unrecoverable_exception_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unrecoverable_exception_message),
            "::",
            stringify!(header)
        )
    );
}
impl Default for hv_x64_unrecoverable_exception_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_unsupported_feature_message {
    pub vp_index: __u32,
    pub feature_code: __u32,
    pub feature_parameter: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_unsupported_feature_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_unsupported_feature_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_unsupported_feature_message>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_unsupported_feature_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_unsupported_feature_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_unsupported_feature_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unsupported_feature_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unsupported_feature_message),
            "::",
            stringify!(feature_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unsupported_feature_message),
            "::",
            stringify!(feature_parameter)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_halt_message {
    pub header: hv_x64_intercept_message_header,
}
#[test]
fn bindgen_test_layout_hv_x64_halt_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_halt_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_halt_message>(),
        40usize,
        concat!("Size of: ", stringify!(hv_x64_halt_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_halt_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_halt_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_halt_message),
            "::",
            stringify!(header)
        )
    );
}
impl Default for hv_x64_halt_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_interruption_deliverable_message {
    pub header: hv_x64_intercept_message_header,
    pub deliverable_type: __u32,
    pub rsvd: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_interruption_deliverable_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_interruption_deliverable_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_interruption_deliverable_message>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_interruption_deliverable_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_interruption_deliverable_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_interruption_deliverable_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interruption_deliverable_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deliverable_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interruption_deliverable_message),
            "::",
            stringify!(deliverable_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interruption_deliverable_message),
            "::",
            stringify!(rsvd)
        )
    );
}
impl Default for hv_x64_interruption_deliverable_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_sint_deliverable_message {
    pub header: hv_x64_intercept_message_header,
    pub deliverable_sints: __u16,
    pub rsvd1: __u16,
    pub rsvd2: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_sint_deliverable_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_sint_deliverable_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_sint_deliverable_message>(),
        48usize,
        concat!("Size of: ", stringify!(hv_x64_sint_deliverable_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_sint_deliverable_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_sint_deliverable_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sint_deliverable_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deliverable_sints) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sint_deliverable_message),
            "::",
            stringify!(deliverable_sints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd1) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sint_deliverable_message),
            "::",
            stringify!(rsvd1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sint_deliverable_message),
            "::",
            stringify!(rsvd2)
        )
    );
}
impl Default for hv_x64_sint_deliverable_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_sipi_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub target_vp_index: __u32,
    pub interrupt_vector: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_sipi_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_sipi_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_sipi_intercept_message>(),
        48usize,
        concat!("Size of: ", stringify!(hv_x64_sipi_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_sipi_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_sipi_intercept_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sipi_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vp_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sipi_intercept_message),
            "::",
            stringify!(target_vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_vector) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sipi_intercept_message),
            "::",
            stringify!(interrupt_vector)
        )
    );
}
impl Default for hv_x64_sipi_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_gpa_attribute_intercept_message {
    pub vp_index: __u32,
    pub __bindgen_anon_1: hv_x64_gpa_attribute_intercept_message__bindgen_ty_1,
    pub ranges: [hv_gpa_page_range; 29usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_gpa_attribute_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_gpa_attribute_intercept_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_gpa_attribute_intercept_message__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_gpa_attribute_intercept_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_gpa_attribute_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_gpa_attribute_intercept_message__bindgen_ty_1)
        )
    );
}
impl hv_x64_gpa_attribute_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn range_count(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_range_count(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn adjust(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adjust(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_visibility(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_host_visibility(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn memory_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_memory_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        range_count: __u32,
        adjust: __u32,
        host_visibility: __u32,
        memory_type: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let range_count: u32 = unsafe { ::std::mem::transmute(range_count) };
            range_count as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let adjust: u32 = unsafe { ::std::mem::transmute(adjust) };
            adjust as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let host_visibility: u32 = unsafe { ::std::mem::transmute(host_visibility) };
            host_visibility as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let memory_type: u32 = unsafe { ::std::mem::transmute(memory_type) };
            memory_type as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_gpa_attribute_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_gpa_attribute_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_gpa_attribute_intercept_message>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_gpa_attribute_intercept_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_gpa_attribute_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_gpa_attribute_intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_gpa_attribute_intercept_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ranges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_gpa_attribute_intercept_message),
            "::",
            stringify!(ranges)
        )
    );
}
impl Default for hv_x64_gpa_attribute_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_register_x64_cpuid_result_parameters {
    pub input: hv_register_x64_cpuid_result_parameters__bindgen_ty_1,
    pub result: hv_register_x64_cpuid_result_parameters__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_register_x64_cpuid_result_parameters__bindgen_ty_1 {
    pub eax: __u32,
    pub ecx: __u32,
    pub subleaf_specific: __u8,
    pub always_override: __u8,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_hv_register_x64_cpuid_result_parameters__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_x64_cpuid_result_parameters__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subleaf_specific) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(subleaf_specific)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).always_override) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(always_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_register_x64_cpuid_result_parameters__bindgen_ty_2 {
    pub eax: __u32,
    pub eax_mask: __u32,
    pub ebx: __u32,
    pub ebx_mask: __u32,
    pub ecx: __u32,
    pub ecx_mask: __u32,
    pub edx: __u32,
    pub edx_mask: __u32,
}
#[test]
fn bindgen_test_layout_hv_register_x64_cpuid_result_parameters__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_x64_cpuid_result_parameters__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(eax_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebx_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ebx_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx_mask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ecx_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(edx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edx_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(edx_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_register_x64_cpuid_result_parameters() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_x64_cpuid_result_parameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_cpuid_result_parameters>(),
        44usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_cpuid_result_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_cpuid_result_parameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_cpuid_result_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters),
            "::",
            stringify!(result)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_register_x64_msr_result_parameters {
    pub msr_index: __u32,
    pub access_type: __u32,
    pub action: __u32,
}
#[test]
fn bindgen_test_layout_hv_register_x64_msr_result_parameters() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_x64_msr_result_parameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_msr_result_parameters>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_msr_result_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_msr_result_parameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_msr_result_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msr_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_msr_result_parameters),
            "::",
            stringify!(msr_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_msr_result_parameters),
            "::",
            stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_msr_result_parameters),
            "::",
            stringify!(action)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_register_intercept_result_parameters {
    pub cpuid: hv_register_x64_cpuid_result_parameters,
    pub msr: hv_register_x64_msr_result_parameters,
}
#[test]
fn bindgen_test_layout_hv_register_intercept_result_parameters() {
    const UNINIT: ::std::mem::MaybeUninit<hv_register_intercept_result_parameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_register_intercept_result_parameters>(),
        44usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_intercept_result_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_intercept_result_parameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_intercept_result_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_intercept_result_parameters),
            "::",
            stringify!(cpuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_intercept_result_parameters),
            "::",
            stringify!(msr)
        )
    );
}
impl Default for hv_register_intercept_result_parameters {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_vmgexit_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub ghcb_msr: __u64,
    pub __bindgen_anon_1: hv_x64_vmgexit_intercept_message__bindgen_ty_1,
    pub __bindgen_anon_2: hv_x64_vmgexit_intercept_message__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_vmgexit_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_vmgexit_intercept_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vmgexit_intercept_message__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vmgexit_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_1)
        )
    );
}
impl hv_x64_vmgexit_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn ghcb_page_valid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ghcb_page_valid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ghcb_page_valid: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ghcb_page_valid: u64 = unsafe { ::std::mem::transmute(ghcb_page_valid) };
            ghcb_page_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_vmgexit_intercept_message__bindgen_ty_2 {
    pub ghcb_usage: __u32,
    pub rserved_ghcb_page: __u32,
    pub __bindgen_anon_1: hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1 {
    pub ghcb_protocol_version: __u16,
    pub reserved_st: [__u16; 3usize],
    pub sw_exit_code: __u64,
    pub sw_exit_info1: __u64,
    pub sw_exit_info2: __u64,
    pub sw_scratch: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghcb_protocol_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ghcb_protocol_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_st) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_exit_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sw_exit_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_exit_info1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sw_exit_info1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_exit_info2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sw_exit_info2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_scratch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sw_scratch)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_x64_vmgexit_intercept_message__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_vmgexit_intercept_message__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vmgexit_intercept_message__bindgen_ty_2>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vmgexit_intercept_message__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghcb_usage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2),
            "::",
            stringify!(ghcb_usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rserved_ghcb_page) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message__bindgen_ty_2),
            "::",
            stringify!(rserved_ghcb_page)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_x64_vmgexit_intercept_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_x64_vmgexit_intercept_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vmgexit_intercept_message>(),
        104usize,
        concat!("Size of: ", stringify!(hv_x64_vmgexit_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vmgexit_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_vmgexit_intercept_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghcb_msr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vmgexit_intercept_message),
            "::",
            stringify!(ghcb_msr)
        )
    );
}
impl Default for hv_x64_vmgexit_intercept_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_async_completion_message_payload {
    pub partition_id: __u64,
    pub status: __u32,
    pub completion_count: __u32,
    pub sub_status: __u64,
}
#[test]
fn bindgen_test_layout_hv_async_completion_message_payload() {
    const UNINIT: ::std::mem::MaybeUninit<hv_async_completion_message_payload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_async_completion_message_payload>(),
        24usize,
        concat!("Size of: ", stringify!(hv_async_completion_message_payload))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_async_completion_message_payload>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_async_completion_message_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_async_completion_message_payload),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_async_completion_message_payload),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completion_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_async_completion_message_payload),
            "::",
            stringify!(completion_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_async_completion_message_payload),
            "::",
            stringify!(sub_status)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_translate_virtual_address {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub padding: __u32,
    pub control_flags: __u64,
    pub gva_page: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_translate_virtual_address() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_translate_virtual_address> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_translate_virtual_address>(),
        32usize,
        concat!("Size of: ", stringify!(hv_input_translate_virtual_address))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_translate_virtual_address>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_translate_virtual_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_translate_virtual_address),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_translate_virtual_address),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_translate_virtual_address),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_translate_virtual_address),
            "::",
            stringify!(control_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gva_page) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_translate_virtual_address),
            "::",
            stringify!(gva_page)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_translate_virtual_address {
    pub translation_result: hv_translate_gva_result,
    pub gpa_page: __u64,
}
#[test]
fn bindgen_test_layout_hv_output_translate_virtual_address() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_translate_virtual_address> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_translate_virtual_address>(),
        16usize,
        concat!("Size of: ", stringify!(hv_output_translate_virtual_address))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_translate_virtual_address>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_output_translate_virtual_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).translation_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_translate_virtual_address),
            "::",
            stringify!(translation_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa_page) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_translate_virtual_address),
            "::",
            stringify!(gpa_page)
        )
    );
}
impl Default for hv_output_translate_virtual_address {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_cache_type_HV_CACHE_TYPE_UNCACHED: hv_cache_type = 0;
pub const hv_cache_type_HV_CACHE_TYPE_WRITE_COMBINING: hv_cache_type = 1;
pub const hv_cache_type_HV_CACHE_TYPE_WRITE_THROUGH: hv_cache_type = 4;
pub const hv_cache_type_HV_CACHE_TYPE_WRITE_PROTECTED: hv_cache_type = 5;
pub const hv_cache_type_HV_CACHE_TYPE_WRITE_BACK: hv_cache_type = 6;
pub type hv_cache_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_register_intercept_result {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub intercept_type: __u32,
    pub parameters: hv_register_intercept_result_parameters,
}
#[test]
fn bindgen_test_layout_hv_input_register_intercept_result() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_register_intercept_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_register_intercept_result>(),
        60usize,
        concat!("Size of: ", stringify!(hv_input_register_intercept_result))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_register_intercept_result>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_register_intercept_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_register_intercept_result),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_register_intercept_result),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_register_intercept_result),
            "::",
            stringify!(intercept_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_register_intercept_result),
            "::",
            stringify!(parameters)
        )
    );
}
impl Default for hv_input_register_intercept_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_delete_vp {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_delete_vp__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_delete_vp__bindgen_ty_1 {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub reserved: [__u8; 4usize],
}
#[test]
fn bindgen_test_layout_hv_delete_vp__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_delete_vp__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_delete_vp__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(hv_delete_vp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_delete_vp__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_delete_vp__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_delete_vp__bindgen_ty_1),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_delete_vp__bindgen_ty_1),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_delete_vp__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_delete_vp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_delete_vp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_delete_vp>(),
        16usize,
        concat!("Size of: ", stringify!(hv_delete_vp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_delete_vp>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_delete_vp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_delete_vp),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_delete_vp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_assert_virtual_interrupt {
    pub partition_id: __u64,
    pub control: hv_interrupt_control,
    pub dest_addr: __u64,
    pub vector: __u32,
    pub target_vtl: __u8,
    pub rsvd_z0: __u8,
    pub rsvd_z1: __u16,
}
#[test]
fn bindgen_test_layout_hv_input_assert_virtual_interrupt() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_assert_virtual_interrupt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_assert_virtual_interrupt>(),
        32usize,
        concat!("Size of: ", stringify!(hv_input_assert_virtual_interrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_assert_virtual_interrupt>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_assert_virtual_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(dest_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vtl) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(target_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_z0) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(rsvd_z0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_z1) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_assert_virtual_interrupt),
            "::",
            stringify!(rsvd_z1)
        )
    );
}
impl Default for hv_input_assert_virtual_interrupt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_create_port {
    pub port_partition_id: __u64,
    pub port_id: hv_port_id,
    pub port_vtl: __u8,
    pub min_connection_vtl: __u8,
    pub padding: __u16,
    pub connection_partition_id: __u64,
    pub port_info: hv_port_info,
    pub proximity_domain_info: hv_proximity_domain_info,
}
#[test]
fn bindgen_test_layout_hv_input_create_port() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_create_port> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_create_port>(),
        56usize,
        concat!("Size of: ", stringify!(hv_input_create_port))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_create_port>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_create_port))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(port_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(port_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_connection_vtl) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(min_connection_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_partition_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(connection_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proximity_domain_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_create_port),
            "::",
            stringify!(proximity_domain_info)
        )
    );
}
impl Default for hv_input_create_port {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_input_delete_port {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_input_delete_port__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hv_input_delete_port__bindgen_ty_1 {
    pub port_partition_id: __u64,
    pub port_id: hv_port_id,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_delete_port__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_delete_port__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_delete_port__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_delete_port__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_delete_port__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_delete_port__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_delete_port__bindgen_ty_1),
            "::",
            stringify!(port_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_delete_port__bindgen_ty_1),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_delete_port__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hv_input_delete_port__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_input_delete_port() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_delete_port> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_delete_port>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_delete_port))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_delete_port>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_delete_port))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_delete_port),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_input_delete_port {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_connect_port {
    pub connection_partition_id: __u64,
    pub connection_id: hv_connection_id,
    pub connection_vtl: __u8,
    pub rsvdz0: __u8,
    pub rsvdz1: __u16,
    pub port_partition_id: __u64,
    pub port_id: hv_port_id,
    pub reserved2: __u32,
    pub connection_info: hv_connection_info,
    pub proximity_domain_info: hv_proximity_domain_info,
}
#[test]
fn bindgen_test_layout_hv_input_connect_port() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_connect_port> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_connect_port>(),
        72usize,
        concat!("Size of: ", stringify!(hv_input_connect_port))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_connect_port>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_connect_port))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(connection_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(connection_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(connection_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz0) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(rsvdz0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvdz1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(rsvdz1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_partition_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(port_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(connection_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proximity_domain_info) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_connect_port),
            "::",
            stringify!(proximity_domain_info)
        )
    );
}
impl Default for hv_input_connect_port {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_input_disconnect_port {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_input_disconnect_port__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_disconnect_port__bindgen_ty_1 {
    pub connection_partition_id: __u64,
    pub connection_id: hv_connection_id,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_input_disconnect_port__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_disconnect_port__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_disconnect_port__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_input_disconnect_port__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_disconnect_port__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_disconnect_port__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_disconnect_port__bindgen_ty_1),
            "::",
            stringify!(connection_partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_disconnect_port__bindgen_ty_1),
            "::",
            stringify!(connection_id)
        )
    );
}
impl Default for hv_input_disconnect_port__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hv_input_disconnect_port__bindgen_ty_1 {
    #[inline]
    pub fn is_doorbell(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_doorbell(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_doorbell: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_doorbell: u32 = unsafe { ::std::mem::transmute(is_doorbell) };
            is_doorbell as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_input_disconnect_port() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_disconnect_port> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_disconnect_port>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_disconnect_port))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_disconnect_port>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_disconnect_port))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_disconnect_port),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_input_disconnect_port {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_input_notify_port_ring_empty {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_input_notify_port_ring_empty__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_notify_port_ring_empty__bindgen_ty_1 {
    pub sint_index: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_notify_port_ring_empty__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_notify_port_ring_empty__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_notify_port_ring_empty__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_input_notify_port_ring_empty__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_notify_port_ring_empty__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_notify_port_ring_empty__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_notify_port_ring_empty__bindgen_ty_1),
            "::",
            stringify!(sint_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_notify_port_ring_empty__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_input_notify_port_ring_empty() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_notify_port_ring_empty> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_notify_port_ring_empty>(),
        8usize,
        concat!("Size of: ", stringify!(hv_input_notify_port_ring_empty))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_notify_port_ring_empty>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_notify_port_ring_empty))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_notify_port_ring_empty),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_input_notify_port_ring_empty {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_signal_event_direct {
    pub target_partition: __u64,
    pub target_vp: __u32,
    pub target_vtl: __u8,
    pub target_sint: __u8,
    pub flag_number: __u16,
}
#[test]
fn bindgen_test_layout_hv_input_signal_event_direct() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_signal_event_direct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_signal_event_direct>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_signal_event_direct))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_signal_event_direct>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_signal_event_direct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_partition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_signal_event_direct),
            "::",
            stringify!(target_partition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_signal_event_direct),
            "::",
            stringify!(target_vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_signal_event_direct),
            "::",
            stringify!(target_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_sint) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_signal_event_direct),
            "::",
            stringify!(target_sint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag_number) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_signal_event_direct),
            "::",
            stringify!(flag_number)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_signal_event_direct {
    pub newly_signaled: __u8,
    pub reserved: [__u8; 7usize],
}
#[test]
fn bindgen_test_layout_hv_output_signal_event_direct() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_signal_event_direct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_signal_event_direct>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_signal_event_direct))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_signal_event_direct>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_signal_event_direct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).newly_signaled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_signal_event_direct),
            "::",
            stringify!(newly_signaled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_signal_event_direct),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_post_message_direct {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub vtl: __u8,
    pub padding: [__u8; 3usize],
    pub sint_index: __u32,
    pub message: [__u8; 256usize],
    pub padding2: __u32,
}
#[test]
fn bindgen_test_layout_hv_input_post_message_direct() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_post_message_direct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_post_message_direct>(),
        280usize,
        concat!("Size of: ", stringify!(hv_input_post_message_direct))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_post_message_direct>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_post_message_direct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(sint_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_post_message_direct),
            "::",
            stringify!(padding2)
        )
    );
}
impl Default for hv_input_post_message_direct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_state_data_xsave {
    pub flags: __u64,
    pub states: hv_x64_xsave_xfem_register,
}
#[test]
fn bindgen_test_layout_hv_vp_state_data_xsave() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_state_data_xsave> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_state_data_xsave>(),
        16usize,
        concat!("Size of: ", stringify!(hv_vp_state_data_xsave))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_state_data_xsave>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vp_state_data_xsave))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data_xsave),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).states) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data_xsave),
            "::",
            stringify!(states)
        )
    );
}
impl Default for hv_vp_state_data_xsave {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_LOCAL_INTERRUPT_CONTROLLER_STATE:
    hv_get_set_vp_state_type = -2147483648;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_XSAVE: hv_get_set_vp_state_type =
    -2147483647;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_SIM_PAGE: hv_get_set_vp_state_type =
    -2147483646;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_SIEF_PAGE: hv_get_set_vp_state_type =
    -2147483645;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_SYNTHETIC_TIMERS: hv_get_set_vp_state_type =
    4;
pub type hv_get_set_vp_state_type = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_state_data {
    pub type_: __u32,
    pub rsvd: __u32,
    pub xsave: hv_vp_state_data_xsave,
}
#[test]
fn bindgen_test_layout_hv_vp_state_data() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_state_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_state_data>(),
        24usize,
        concat!("Size of: ", stringify!(hv_vp_state_data))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_state_data>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vp_state_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsave) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data),
            "::",
            stringify!(xsave)
        )
    );
}
impl Default for hv_vp_state_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_get_vp_state {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub input_vtl: __u8,
    pub rsvd0: __u8,
    pub rsvd1: __u16,
    pub state_data: hv_vp_state_data,
    pub output_data_pfns: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_input_get_vp_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_get_vp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_vp_state>(),
        40usize,
        concat!("Size of: ", stringify!(hv_input_get_vp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_vp_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_get_vp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(input_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd0) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(rsvd0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(rsvd1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(state_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_data_pfns) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_vp_state),
            "::",
            stringify!(output_data_pfns)
        )
    );
}
impl Default for hv_input_get_vp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_output_get_vp_state {
    pub synthetic_timers_state: hv_synthetic_timers_state,
}
#[test]
fn bindgen_test_layout_hv_output_get_vp_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_get_vp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_get_vp_state>(),
        200usize,
        concat!("Size of: ", stringify!(hv_output_get_vp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_get_vp_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_get_vp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).synthetic_timers_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_get_vp_state),
            "::",
            stringify!(synthetic_timers_state)
        )
    );
}
impl Default for hv_output_get_vp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_input_set_vp_state_data {
    pub pfns: __u64,
    pub bytes: __u8,
}
#[test]
fn bindgen_test_layout_hv_input_set_vp_state_data() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_set_vp_state_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_set_vp_state_data>(),
        8usize,
        concat!("Size of: ", stringify!(hv_input_set_vp_state_data))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_set_vp_state_data>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_set_vp_state_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state_data),
            "::",
            stringify!(pfns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state_data),
            "::",
            stringify!(bytes)
        )
    );
}
impl Default for hv_input_set_vp_state_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct hv_input_set_vp_state {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub input_vtl: __u8,
    pub rsvd0: __u8,
    pub rsvd1: __u16,
    pub state_data: hv_vp_state_data,
    pub data: __IncompleteArrayField<hv_input_set_vp_state_data>,
}
#[test]
fn bindgen_test_layout_hv_input_set_vp_state() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_set_vp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_set_vp_state>(),
        40usize,
        concat!("Size of: ", stringify!(hv_input_set_vp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_set_vp_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_set_vp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_vtl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(input_vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd0) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(rsvd0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(rsvd1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(state_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_set_vp_state),
            "::",
            stringify!(data)
        )
    );
}
impl Default for hv_input_set_vp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_vp_dispatch_state_HV_VP_DISPATCH_STATE_INVALID: hv_vp_dispatch_state = 0;
pub const hv_vp_dispatch_state_HV_VP_DISPATCH_STATE_BLOCKED: hv_vp_dispatch_state = 1;
pub const hv_vp_dispatch_state_HV_VP_DISPATCH_STATE_READY: hv_vp_dispatch_state = 2;
pub type hv_vp_dispatch_state = ::std::os::raw::c_uint;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_INVALID: hv_vp_dispatch_event = 0;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_SUSPEND: hv_vp_dispatch_event = 1;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_INTERCEPT: hv_vp_dispatch_event = 2;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_INTERNAL: hv_vp_dispatch_event = 3;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_PREEMPTED: hv_vp_dispatch_event = 4;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_CANCELLED: hv_vp_dispatch_event = 5;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_SCHEDULER: hv_vp_dispatch_event = 6;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_LONGSPINWAIT: hv_vp_dispatch_event = 7;
pub const hv_vp_dispatch_event_HV_VP_DISPATCH_EVENT_TIMESLICEEND: hv_vp_dispatch_event = 8;
pub type hv_vp_dispatch_event = ::std::os::raw::c_uint;
#[repr(C, packed)]
pub struct hv_vp_signal_bitset_scheduler_message {
    pub partition_id: __u64,
    pub overflow_count: __u32,
    pub vp_count: __u16,
    pub reserved: __u16,
    pub vp_bitset: hv_vp_signal_bitset_scheduler_message__bindgen_ty_1,
}
#[repr(C)]
pub struct hv_vp_signal_bitset_scheduler_message__bindgen_ty_1 {
    pub bitset: __BindgenUnionField<hv_vpset>,
    pub bitset_buffer: __BindgenUnionField<[__u64; 18usize]>,
    pub bindgen_union_field: [u64; 18usize],
}
#[test]
fn bindgen_test_layout_hv_vp_signal_bitset_scheduler_message__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_signal_bitset_scheduler_message__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_signal_bitset_scheduler_message__bindgen_ty_1>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_signal_bitset_scheduler_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_signal_bitset_scheduler_message__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_signal_bitset_scheduler_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitset_buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message__bindgen_ty_1),
            "::",
            stringify!(bitset_buffer)
        )
    );
}
impl Default for hv_vp_signal_bitset_scheduler_message__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_signal_bitset_scheduler_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_signal_bitset_scheduler_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_signal_bitset_scheduler_message>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_signal_bitset_scheduler_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_signal_bitset_scheduler_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_signal_bitset_scheduler_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message),
            "::",
            stringify!(overflow_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message),
            "::",
            stringify!(vp_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_bitset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_bitset_scheduler_message),
            "::",
            stringify!(vp_bitset)
        )
    );
}
impl Default for hv_vp_signal_bitset_scheduler_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_eventlog_message_payload {
    pub type_: __u32,
    pub buffer_index: __u32,
}
#[test]
fn bindgen_test_layout_hv_eventlog_message_payload() {
    const UNINIT: ::std::mem::MaybeUninit<hv_eventlog_message_payload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_eventlog_message_payload>(),
        8usize,
        concat!("Size of: ", stringify!(hv_eventlog_message_payload))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_eventlog_message_payload>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_eventlog_message_payload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_eventlog_message_payload),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_eventlog_message_payload),
            "::",
            stringify!(buffer_index)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_vp_signal_pair_scheduler_message {
    pub overflow_count: __u32,
    pub vp_count: __u8,
    pub reserved1: [__u8; 3usize],
    pub partition_ids: [__u64; 19usize],
    pub vp_indexes: [__u32; 19usize],
    pub reserved2: [__u8; 4usize],
}
#[test]
fn bindgen_test_layout_hv_vp_signal_pair_scheduler_message() {
    const UNINIT: ::std::mem::MaybeUninit<hv_vp_signal_pair_scheduler_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_vp_signal_pair_scheduler_message>(),
        240usize,
        concat!("Size of: ", stringify!(hv_vp_signal_pair_scheduler_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_signal_pair_scheduler_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_signal_pair_scheduler_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_pair_scheduler_message),
            "::",
            stringify!(overflow_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_pair_scheduler_message),
            "::",
            stringify!(vp_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_pair_scheduler_message),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_ids) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_pair_scheduler_message),
            "::",
            stringify!(partition_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_indexes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_pair_scheduler_message),
            "::",
            stringify!(vp_indexes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_signal_pair_scheduler_message),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_dispatch_vp {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub flags: __u32,
    pub time_slice: __u64,
    pub spec_ctrl: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_dispatch_vp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_dispatch_vp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_dispatch_vp>(),
        32usize,
        concat!("Size of: ", stringify!(hv_input_dispatch_vp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_dispatch_vp>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_dispatch_vp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_dispatch_vp),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_dispatch_vp),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_dispatch_vp),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_slice) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_dispatch_vp),
            "::",
            stringify!(time_slice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spec_ctrl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_dispatch_vp),
            "::",
            stringify!(spec_ctrl)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_output_dispatch_vp {
    pub dispatch_state: __u32,
    pub dispatch_event: __u32,
}
#[test]
fn bindgen_test_layout_hv_output_dispatch_vp() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_dispatch_vp> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_dispatch_vp>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_dispatch_vp))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_dispatch_vp>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_dispatch_vp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_dispatch_vp),
            "::",
            stringify!(dispatch_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch_event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_dispatch_vp),
            "::",
            stringify!(dispatch_event)
        )
    );
}
#[repr(C, packed)]
pub struct hv_input_modify_sparse_spa_page_host_access {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub flags: __u32,
    pub partition_id: __u64,
    pub spa_page_list: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_input_modify_sparse_spa_page_host_access() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_modify_sparse_spa_page_host_access> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_modify_sparse_spa_page_host_access>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_input_modify_sparse_spa_page_host_access)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_modify_sparse_spa_page_host_access>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_modify_sparse_spa_page_host_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_modify_sparse_spa_page_host_access),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_modify_sparse_spa_page_host_access),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spa_page_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_modify_sparse_spa_page_host_access),
            "::",
            stringify!(spa_page_list)
        )
    );
}
impl Default for hv_input_modify_sparse_spa_page_host_access {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hv_input_modify_sparse_spa_page_host_access {
    #[inline]
    pub fn host_access(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_host_access(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        host_access: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let host_access: u32 = unsafe { ::std::mem::transmute(host_access) };
            host_access as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_psp_cpuid_leaf {
    pub eax_in: __u32,
    pub ecx_in: __u32,
    pub xfem_in: __u64,
    pub xss_in: __u64,
    pub eax_out: __u32,
    pub ebx_out: __u32,
    pub ecx_out: __u32,
    pub edx_out: __u32,
    pub reserved_z: __u64,
}
#[test]
fn bindgen_test_layout_hv_psp_cpuid_leaf() {
    const UNINIT: ::std::mem::MaybeUninit<hv_psp_cpuid_leaf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_psp_cpuid_leaf>(),
        48usize,
        concat!("Size of: ", stringify!(hv_psp_cpuid_leaf))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_psp_cpuid_leaf>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_psp_cpuid_leaf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax_in) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(eax_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx_in) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(ecx_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfem_in) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(xfem_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xss_in) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(xss_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(eax_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebx_out) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(ebx_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx_out) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(ecx_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edx_out) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(edx_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_z) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_leaf),
            "::",
            stringify!(reserved_z)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_psp_cpuid_page {
    pub count: __u32,
    pub reserved_z1: __u32,
    pub reserved_z2: __u64,
    pub cpuid_leaf_info: [hv_psp_cpuid_leaf; 64usize],
}
#[test]
fn bindgen_test_layout_hv_psp_cpuid_page() {
    const UNINIT: ::std::mem::MaybeUninit<hv_psp_cpuid_page> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_psp_cpuid_page>(),
        3088usize,
        concat!("Size of: ", stringify!(hv_psp_cpuid_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_psp_cpuid_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_psp_cpuid_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_page),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_z1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_page),
            "::",
            stringify!(reserved_z1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_z2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_page),
            "::",
            stringify!(reserved_z2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuid_leaf_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_psp_cpuid_page),
            "::",
            stringify!(cpuid_leaf_info)
        )
    );
}
impl Default for hv_psp_cpuid_page {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_NORMAL: hv_isolated_page_type = 0;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_VMSA: hv_isolated_page_type = 1;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_ZERO: hv_isolated_page_type = 2;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_UNMEASURED: hv_isolated_page_type = 3;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_SECRETS: hv_isolated_page_type = 4;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_CPUID: hv_isolated_page_type = 5;
pub const hv_isolated_page_type_HV_ISOLATED_PAGE_TYPE_COUNT: hv_isolated_page_type = 6;
pub type hv_isolated_page_type = ::std::os::raw::c_uint;
pub const hv_isolated_page_size_HV_ISOLATED_PAGE_SIZE_4KB: hv_isolated_page_size = 0;
pub const hv_isolated_page_size_HV_ISOLATED_PAGE_SIZE_2MB: hv_isolated_page_size = 1;
pub type hv_isolated_page_size = ::std::os::raw::c_uint;
#[repr(C, packed)]
pub struct hv_input_import_isolated_pages {
    pub partition_id: __u64,
    pub page_type: __u32,
    pub page_size: __u32,
    pub page_number: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_hv_input_import_isolated_pages() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_import_isolated_pages> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_import_isolated_pages>(),
        16usize,
        concat!("Size of: ", stringify!(hv_input_import_isolated_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_import_isolated_pages>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_import_isolated_pages))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_import_isolated_pages),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_import_isolated_pages),
            "::",
            stringify!(page_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_import_isolated_pages),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_import_isolated_pages),
            "::",
            stringify!(page_number)
        )
    );
}
impl Default for hv_input_import_isolated_pages {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_sev_vmgexit_offload {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_sev_vmgexit_offload__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_sev_vmgexit_offload__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_sev_vmgexit_offload__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_sev_vmgexit_offload__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_sev_vmgexit_offload__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_sev_vmgexit_offload__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_sev_vmgexit_offload__bindgen_ty_1)
        )
    );
}
impl hv_sev_vmgexit_offload__bindgen_ty_1 {
    #[inline]
    pub fn nae_rdtsc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_rdtsc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_cpuid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_cpuid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_reserved_io_port(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_reserved_io_port(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_rdmsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_rdmsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_wrmsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_wrmsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_vmmcall(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_vmmcall(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_wbinvd(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_wbinvd(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nae_snp_page_state_change(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nae_snp_page_state_change(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn msr_cpuid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_msr_cpuid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msr_snp_page_state_change(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_msr_snp_page_state_change(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nae_rdtsc: __u64,
        nae_cpuid: __u64,
        nae_reserved_io_port: __u64,
        nae_rdmsr: __u64,
        nae_wrmsr: __u64,
        nae_vmmcall: __u64,
        nae_wbinvd: __u64,
        nae_snp_page_state_change: __u64,
        reserved0: __u64,
        msr_cpuid: __u64,
        msr_snp_page_state_change: __u64,
        reserved1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nae_rdtsc: u64 = unsafe { ::std::mem::transmute(nae_rdtsc) };
            nae_rdtsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nae_cpuid: u64 = unsafe { ::std::mem::transmute(nae_cpuid) };
            nae_cpuid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nae_reserved_io_port: u64 = unsafe { ::std::mem::transmute(nae_reserved_io_port) };
            nae_reserved_io_port as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nae_rdmsr: u64 = unsafe { ::std::mem::transmute(nae_rdmsr) };
            nae_rdmsr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nae_wrmsr: u64 = unsafe { ::std::mem::transmute(nae_wrmsr) };
            nae_wrmsr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nae_vmmcall: u64 = unsafe { ::std::mem::transmute(nae_vmmcall) };
            nae_vmmcall as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let nae_wbinvd: u64 = unsafe { ::std::mem::transmute(nae_wbinvd) };
            nae_wbinvd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nae_snp_page_state_change: u64 =
                unsafe { ::std::mem::transmute(nae_snp_page_state_change) };
            nae_snp_page_state_change as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved0: u64 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let msr_cpuid: u64 = unsafe { ::std::mem::transmute(msr_cpuid) };
            msr_cpuid as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let msr_snp_page_state_change: u64 =
                unsafe { ::std::mem::transmute(msr_snp_page_state_change) };
            msr_snp_page_state_change as u64
        });
        __bindgen_bitfield_unit.set(34usize, 30u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_sev_vmgexit_offload() {
    const UNINIT: ::std::mem::MaybeUninit<hv_sev_vmgexit_offload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_sev_vmgexit_offload>(),
        8usize,
        concat!("Size of: ", stringify!(hv_sev_vmgexit_offload))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_sev_vmgexit_offload>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_sev_vmgexit_offload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_sev_vmgexit_offload),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_sev_vmgexit_offload {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_SUCCESS: hv_access_gpa_result_code = 0;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_UNMAPPED: hv_access_gpa_result_code = 1;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_READ_INTERCEPT: hv_access_gpa_result_code = 2;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_WRITE_INTERCEPT: hv_access_gpa_result_code = 3;
pub const hv_access_gpa_result_code_HV_ACCESS_GPA_ILLEGAL_OVERLAY_ACCESS:
    hv_access_gpa_result_code = 4;
pub type hv_access_gpa_result_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_access_gpa_result {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_access_gpa_result__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_access_gpa_result__bindgen_ty_1 {
    pub result_code: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_hv_access_gpa_result__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hv_access_gpa_result__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_access_gpa_result__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_access_gpa_result__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_access_gpa_result__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_access_gpa_result__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_access_gpa_result__bindgen_ty_1),
            "::",
            stringify!(result_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_access_gpa_result__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_access_gpa_result() {
    const UNINIT: ::std::mem::MaybeUninit<hv_access_gpa_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_access_gpa_result>(),
        8usize,
        concat!("Size of: ", stringify!(hv_access_gpa_result))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_access_gpa_result>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_access_gpa_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_access_gpa_result),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_access_gpa_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_access_gpa_control_flags {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_access_gpa_control_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_access_gpa_control_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_access_gpa_control_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_access_gpa_control_flags__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_access_gpa_control_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_access_gpa_control_flags__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_access_gpa_control_flags__bindgen_ty_1)
        )
    );
}
impl hv_access_gpa_control_flags__bindgen_ty_1 {
    #[inline]
    pub fn cache_type(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_cache_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache_type: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cache_type: u64 = unsafe { ::std::mem::transmute(cache_type) };
            cache_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_access_gpa_control_flags() {
    const UNINIT: ::std::mem::MaybeUninit<hv_access_gpa_control_flags> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_access_gpa_control_flags>(),
        8usize,
        concat!("Size of: ", stringify!(hv_access_gpa_control_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_access_gpa_control_flags>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_access_gpa_control_flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_access_gpa_control_flags),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_access_gpa_control_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_read_gpa {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub byte_count: __u32,
    pub base_gpa: __u64,
    pub control_flags: hv_access_gpa_control_flags,
}
#[test]
fn bindgen_test_layout_hv_input_read_gpa() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_read_gpa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_read_gpa>(),
        32usize,
        concat!("Size of: ", stringify!(hv_input_read_gpa))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_read_gpa>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_read_gpa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_read_gpa),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_read_gpa),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_read_gpa),
            "::",
            stringify!(byte_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_gpa) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_read_gpa),
            "::",
            stringify!(base_gpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_read_gpa),
            "::",
            stringify!(control_flags)
        )
    );
}
impl Default for hv_input_read_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_read_gpa {
    pub access_result: hv_access_gpa_result,
    pub data: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_hv_output_read_gpa() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_read_gpa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_read_gpa>(),
        24usize,
        concat!("Size of: ", stringify!(hv_output_read_gpa))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_read_gpa>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_read_gpa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_read_gpa),
            "::",
            stringify!(access_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_read_gpa),
            "::",
            stringify!(data)
        )
    );
}
impl Default for hv_output_read_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_write_gpa {
    pub partition_id: __u64,
    pub vp_index: __u32,
    pub byte_count: __u32,
    pub base_gpa: __u64,
    pub control_flags: hv_access_gpa_control_flags,
    pub data: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_hv_input_write_gpa() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_write_gpa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_write_gpa>(),
        48usize,
        concat!("Size of: ", stringify!(hv_input_write_gpa))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_write_gpa>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_input_write_gpa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_write_gpa),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_write_gpa),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_write_gpa),
            "::",
            stringify!(byte_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_gpa) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_write_gpa),
            "::",
            stringify!(base_gpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_write_gpa),
            "::",
            stringify!(control_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_write_gpa),
            "::",
            stringify!(data)
        )
    );
}
impl Default for hv_input_write_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_output_write_gpa {
    pub access_result: hv_access_gpa_result,
}
#[test]
fn bindgen_test_layout_hv_output_write_gpa() {
    const UNINIT: ::std::mem::MaybeUninit<hv_output_write_gpa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_output_write_gpa>(),
        8usize,
        concat!("Size of: ", stringify!(hv_output_write_gpa))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_output_write_gpa>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_output_write_gpa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_output_write_gpa),
            "::",
            stringify!(access_result)
        )
    );
}
impl Default for hv_output_write_gpa {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct hv_input_issue_psp_guest_request {
    pub partition_id: __u64,
    pub request_page: __u64,
    pub response_page: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_issue_psp_guest_request() {
    const UNINIT: ::std::mem::MaybeUninit<hv_input_issue_psp_guest_request> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hv_input_issue_psp_guest_request>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_issue_psp_guest_request))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_issue_psp_guest_request>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_issue_psp_guest_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_issue_psp_guest_request),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_page) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_issue_psp_guest_request),
            "::",
            stringify!(request_page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_page) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_issue_psp_guest_request),
            "::",
            stringify!(response_page)
        )
    );
}
pub const MSHV_CAP_RSVD: _bindgen_ty_2 = 0;
pub const MSHV_CAP_VTL_REGISTER_PAGE: _bindgen_ty_2 = 1;
pub const MSHV_CAP_VTL_RETURN_ACTION: _bindgen_ty_2 = 2;
pub const MSHV_CAP_VTL_DR6_SHARED: _bindgen_ty_2 = 3;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_version_info {
    pub mshv_uapi_version: __u32,
    pub rsvd_0: [__u32; 3usize],
    pub mshv_api_version: __u32,
    pub rsvd_1: __u32,
    pub mshv_capabilities: __u64,
}
#[test]
fn bindgen_test_layout_mshv_version_info() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_version_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_version_info>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_version_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_version_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_version_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mshv_uapi_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_version_info),
            "::",
            stringify!(mshv_uapi_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_version_info),
            "::",
            stringify!(rsvd_0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mshv_api_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_version_info),
            "::",
            stringify!(mshv_api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd_1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_version_info),
            "::",
            stringify!(rsvd_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mshv_capabilities) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_version_info),
            "::",
            stringify!(mshv_capabilities)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_create_partition {
    pub flags: __u64,
    pub partition_creation_properties: hv_partition_creation_properties,
    pub synthetic_processor_features: hv_partition_synthetic_processor_features,
    pub isolation_properties: hv_partition_isolation_properties,
}
#[test]
fn bindgen_test_layout_mshv_create_partition() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_create_partition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_create_partition>(),
        48usize,
        concat!("Size of: ", stringify!(mshv_create_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_create_partition>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_create_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).partition_creation_properties) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(partition_creation_properties)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).synthetic_processor_features) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(synthetic_processor_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isolation_properties) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(isolation_properties)
        )
    );
}
impl Default for mshv_create_partition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_user_mem_region {
    pub size: __u64,
    pub guest_pfn: __u64,
    pub userspace_addr: __u64,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_mshv_user_mem_region() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_user_mem_region> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_user_mem_region>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_user_mem_region))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_user_mem_region>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_user_mem_region))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guest_pfn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(guest_pfn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userspace_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(userspace_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_create_vp {
    pub vp_index: __u32,
}
#[test]
fn bindgen_test_layout_mshv_create_vp() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_create_vp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_create_vp>(),
        4usize,
        concat!("Size of: ", stringify!(mshv_create_vp))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_create_vp>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_create_vp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_vp),
            "::",
            stringify!(vp_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_vp_registers {
    pub count: ::std::os::raw::c_int,
    pub regs: *mut hv_register_assoc,
}
#[test]
fn bindgen_test_layout_mshv_vp_registers() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_vp_registers> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_vp_registers>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_vp_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_vp_registers>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_vp_registers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_registers),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_registers),
            "::",
            stringify!(regs)
        )
    );
}
impl Default for mshv_vp_registers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_install_intercept {
    pub access_type_mask: __u32,
    pub intercept_type: hv_intercept_type,
    pub intercept_parameter: hv_intercept_parameters,
}
#[test]
fn bindgen_test_layout_mshv_install_intercept() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_install_intercept> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_install_intercept>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_install_intercept))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_install_intercept>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_install_intercept))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_type_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_install_intercept),
            "::",
            stringify!(access_type_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_install_intercept),
            "::",
            stringify!(intercept_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_install_intercept),
            "::",
            stringify!(intercept_parameter)
        )
    );
}
impl Default for mshv_install_intercept {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_assert_interrupt {
    pub control: hv_interrupt_control,
    pub dest_addr: __u64,
    pub vector: __u32,
    pub rsvd: __u32,
}
#[test]
fn bindgen_test_layout_mshv_assert_interrupt() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_assert_interrupt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_assert_interrupt>(),
        24usize,
        concat!("Size of: ", stringify!(mshv_assert_interrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_assert_interrupt>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_assert_interrupt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(dest_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(rsvd)
        )
    );
}
impl Default for mshv_assert_interrupt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSHV_VP_STATE_LAPIC: _bindgen_ty_3 = 0;
pub const MSHV_VP_STATE_XSAVE: _bindgen_ty_3 = 1;
pub const MSHV_VP_STATE_SIMP: _bindgen_ty_3 = 2;
pub const MSHV_VP_STATE_SIEFP: _bindgen_ty_3 = 3;
pub const MSHV_VP_STATE_SYNTHETIC_TIMERS: _bindgen_ty_3 = 4;
pub const MSHV_VP_STATE_COUNT: _bindgen_ty_3 = 5;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_get_set_vp_state {
    pub type_: __u8,
    pub rsvd: [__u8; 3usize],
    pub buf_sz: __u32,
    pub buf_ptr: __u64,
}
#[test]
fn bindgen_test_layout_mshv_get_set_vp_state() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_get_set_vp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_get_set_vp_state>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_get_set_vp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_get_set_vp_state>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_get_set_vp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_set_vp_state),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_set_vp_state),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_sz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_set_vp_state),
            "::",
            stringify!(buf_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_set_vp_state),
            "::",
            stringify!(buf_ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_partition_property {
    pub property_code: hv_partition_property_code,
    pub property_value: __u64,
}
#[test]
fn bindgen_test_layout_mshv_partition_property() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_partition_property> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_partition_property>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_partition_property))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_partition_property>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_partition_property))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_partition_property),
            "::",
            stringify!(property_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_partition_property),
            "::",
            stringify!(property_value)
        )
    );
}
impl Default for mshv_partition_property {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_translate_gva {
    pub gva: __u64,
    pub flags: __u64,
    pub result: *mut hv_translate_gva_result,
    pub gpa: *mut __u64,
}
#[test]
fn bindgen_test_layout_mshv_translate_gva() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_translate_gva> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_translate_gva>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_translate_gva))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_translate_gva>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_translate_gva))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gva) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(gva)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(gpa)
        )
    );
}
impl Default for mshv_translate_gva {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_irqfd {
    pub fd: __s32,
    pub resamplefd: __s32,
    pub gsi: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_mshv_irqfd() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_irqfd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_irqfd>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_irqfd))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_irqfd>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_irqfd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resamplefd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(resamplefd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(gsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(flags)
        )
    );
}
pub const mshv_ioeventfd_flag_nr_datamatch: _bindgen_ty_4 = 0;
pub const mshv_ioeventfd_flag_nr_pio: _bindgen_ty_4 = 1;
pub const mshv_ioeventfd_flag_nr_deassign: _bindgen_ty_4 = 2;
pub const mshv_ioeventfd_flag_nr_max: _bindgen_ty_4 = 3;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_ioeventfd {
    pub datamatch: __u64,
    pub addr: __u64,
    pub len: __u32,
    pub fd: __s32,
    pub flags: __u32,
    pub pad: [__u8; 4usize],
}
#[test]
fn bindgen_test_layout_mshv_ioeventfd() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_ioeventfd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_ioeventfd>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_ioeventfd))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_ioeventfd>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_ioeventfd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datamatch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(datamatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_msi_routing_entry {
    pub gsi: __u32,
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
}
#[test]
fn bindgen_test_layout_mshv_msi_routing_entry() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_msi_routing_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_msi_routing_entry>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_msi_routing_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_msi_routing_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_msi_routing_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(gsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_lo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(address_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_hi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(address_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mshv_msi_routing {
    pub nr: __u32,
    pub pad: __u32,
    pub entries: __IncompleteArrayField<mshv_msi_routing_entry>,
}
#[test]
fn bindgen_test_layout_mshv_msi_routing() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_msi_routing> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_msi_routing>(),
        8usize,
        concat!("Size of: ", stringify!(mshv_msi_routing))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_msi_routing>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_msi_routing))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_register_intercept_result {
    pub intercept_type: __u32,
    pub parameters: hv_register_intercept_result_parameters,
}
#[test]
fn bindgen_test_layout_mshv_register_intercept_result() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_register_intercept_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_register_intercept_result>(),
        48usize,
        concat!("Size of: ", stringify!(mshv_register_intercept_result))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_register_intercept_result>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_register_intercept_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intercept_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_intercept_result),
            "::",
            stringify!(intercept_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_intercept_result),
            "::",
            stringify!(parameters)
        )
    );
}
impl Default for mshv_register_intercept_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_signal_event_direct {
    pub vp: __u32,
    pub vtl: __u8,
    pub sint: __u8,
    pub flag: __u16,
    pub newly_signaled: __u8,
}
#[test]
fn bindgen_test_layout_mshv_signal_event_direct() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_signal_event_direct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_signal_event_direct>(),
        12usize,
        concat!("Size of: ", stringify!(mshv_signal_event_direct))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_signal_event_direct>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_signal_event_direct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_signal_event_direct),
            "::",
            stringify!(vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_signal_event_direct),
            "::",
            stringify!(vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_signal_event_direct),
            "::",
            stringify!(sint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_signal_event_direct),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).newly_signaled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_signal_event_direct),
            "::",
            stringify!(newly_signaled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_post_message_direct {
    pub vp: __u32,
    pub vtl: __u8,
    pub sint: __u8,
    pub length: __u16,
    pub message: *const __u8,
}
#[test]
fn bindgen_test_layout_mshv_post_message_direct() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_post_message_direct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_post_message_direct>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_post_message_direct))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_post_message_direct>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_post_message_direct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_post_message_direct),
            "::",
            stringify!(vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_post_message_direct),
            "::",
            stringify!(vtl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sint) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_post_message_direct),
            "::",
            stringify!(sint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_post_message_direct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_post_message_direct),
            "::",
            stringify!(message)
        )
    );
}
impl Default for mshv_post_message_direct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_register_deliverabilty_notifications {
    pub vp: __u32,
    pub pad: __u32,
    pub flag: __u64,
}
#[test]
fn bindgen_test_layout_mshv_register_deliverabilty_notifications() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_register_deliverabilty_notifications> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_register_deliverabilty_notifications>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(mshv_register_deliverabilty_notifications)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_register_deliverabilty_notifications>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mshv_register_deliverabilty_notifications)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_deliverabilty_notifications),
            "::",
            stringify!(vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_deliverabilty_notifications),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_deliverabilty_notifications),
            "::",
            stringify!(flag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_get_vp_cpuid_values {
    pub function: __u32,
    pub index: __u32,
    pub xfem: __u64,
    pub xss: __u64,
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
}
#[test]
fn bindgen_test_layout_mshv_get_vp_cpuid_values() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_get_vp_cpuid_values> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_get_vp_cpuid_values>(),
        40usize,
        concat!("Size of: ", stringify!(mshv_get_vp_cpuid_values))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_get_vp_cpuid_values>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_get_vp_cpuid_values))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(xfem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(xss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebx) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edx) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_vp_cpuid_values),
            "::",
            stringify!(edx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_trace_config {
    pub mode: __u32,
    pub max_buffers_count: __u32,
    pub pages_per_buffer: __u32,
    pub buffers_threshold: __u32,
    pub time_basis: __u32,
    pub system_time: __u64,
}
#[test]
fn bindgen_test_layout_mshv_trace_config() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_trace_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_trace_config>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_trace_config))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_trace_config>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_trace_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_trace_config),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_buffers_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_trace_config),
            "::",
            stringify!(max_buffers_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pages_per_buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_trace_config),
            "::",
            stringify!(pages_per_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers_threshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_trace_config),
            "::",
            stringify!(buffers_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_basis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_trace_config),
            "::",
            stringify!(time_basis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_trace_config),
            "::",
            stringify!(system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mshv_modify_gpa_host_access {
    pub host_access: __u32,
    pub flags: __u32,
    pub acquire: __u8,
    pub gpa_list_size: __u64,
    pub gpa_list: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_mshv_modify_gpa_host_access() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_modify_gpa_host_access> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_modify_gpa_host_access>(),
        24usize,
        concat!("Size of: ", stringify!(mshv_modify_gpa_host_access))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_modify_gpa_host_access>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_modify_gpa_host_access))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_modify_gpa_host_access),
            "::",
            stringify!(host_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_modify_gpa_host_access),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_modify_gpa_host_access),
            "::",
            stringify!(acquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa_list_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_modify_gpa_host_access),
            "::",
            stringify!(gpa_list_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpa_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_modify_gpa_host_access),
            "::",
            stringify!(gpa_list)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct mshv_import_isolated_pages {
    pub page_type: hv_isolated_page_type,
    pub page_size: hv_isolated_page_size,
    pub num_pages: __u64,
    pub page_number: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_mshv_import_isolated_pages() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_import_isolated_pages> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_import_isolated_pages>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_import_isolated_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_import_isolated_pages>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_import_isolated_pages))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_import_isolated_pages),
            "::",
            stringify!(page_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_import_isolated_pages),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_pages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_import_isolated_pages),
            "::",
            stringify!(num_pages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_import_isolated_pages),
            "::",
            stringify!(page_number)
        )
    );
}
impl Default for mshv_import_isolated_pages {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_complete_isolated_import {
    pub import_data: hv_partition_complete_isolated_import_data,
}
#[test]
fn bindgen_test_layout_mshv_complete_isolated_import() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_complete_isolated_import> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_complete_isolated_import>(),
        3334usize,
        concat!("Size of: ", stringify!(mshv_complete_isolated_import))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_complete_isolated_import>(),
        1usize,
        concat!("Alignment of ", stringify!(mshv_complete_isolated_import))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).import_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_complete_isolated_import),
            "::",
            stringify!(import_data)
        )
    );
}
impl Default for mshv_complete_isolated_import {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_issue_psp_guest_request {
    pub req_gpa: __u64,
    pub rsp_gpa: __u64,
}
#[test]
fn bindgen_test_layout_mshv_issue_psp_guest_request() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_issue_psp_guest_request> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_issue_psp_guest_request>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_issue_psp_guest_request))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_issue_psp_guest_request>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_issue_psp_guest_request))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_gpa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_issue_psp_guest_request),
            "::",
            stringify!(req_gpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp_gpa) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_issue_psp_guest_request),
            "::",
            stringify!(rsp_gpa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_root_hvcall {
    pub code: __u16,
    pub reps: __u16,
    pub in_sz: __u16,
    pub out_sz: __u16,
    pub status: __u16,
    pub rsvd: [__u16; 3usize],
    pub in_ptr: __u64,
    pub out_ptr: __u64,
}
#[test]
fn bindgen_test_layout_mshv_root_hvcall() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_root_hvcall> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_root_hvcall>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_root_hvcall))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_root_hvcall>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_root_hvcall))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reps) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(reps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_sz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(in_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_sz) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(out_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(rsvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(in_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_ptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_root_hvcall),
            "::",
            stringify!(out_ptr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_get_gpa_pages_access_state {
    pub count: __u32,
    pub flags: __u64,
    pub hv_gpa_page_number: __u64,
    pub states: *mut hv_gpa_page_access_state,
}
#[test]
fn bindgen_test_layout_mshv_get_gpa_pages_access_state() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_get_gpa_pages_access_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_get_gpa_pages_access_state>(),
        28usize,
        concat!("Size of: ", stringify!(mshv_get_gpa_pages_access_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_get_gpa_pages_access_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mshv_get_gpa_pages_access_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hv_gpa_page_number) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(hv_gpa_page_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).states) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(states)
        )
    );
}
impl Default for mshv_get_gpa_pages_access_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_create_device {
    pub type_: __u32,
    pub fd: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_mshv_create_device() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_create_device> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_create_device>(),
        12usize,
        concat!("Size of: ", stringify!(mshv_create_device))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_create_device>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_create_device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_device),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_device),
            "::",
            stringify!(flags)
        )
    );
}
pub const mshv_device_type_MSHV_DEV_TYPE_VFIO: mshv_device_type = 0;
pub const mshv_device_type_MSHV_DEV_TYPE_MAX: mshv_device_type = 1;
pub type mshv_device_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_device_attr {
    pub flags: __u32,
    pub group: __u32,
    pub attr: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_mshv_device_attr() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_device_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_device_attr>(),
        24usize,
        concat!("Size of: ", stringify!(mshv_device_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_device_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_device_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_read_write_gpa {
    pub base_gpa: __u64,
    pub byte_count: __u32,
    pub flags: __u32,
    pub data: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_mshv_read_write_gpa() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_read_write_gpa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_read_write_gpa>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_read_write_gpa))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_read_write_gpa>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_read_write_gpa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_gpa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_read_write_gpa),
            "::",
            stringify!(base_gpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_read_write_gpa),
            "::",
            stringify!(byte_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_read_write_gpa),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_read_write_gpa),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
pub struct mshv_sev_snp_ap_create {
    pub vp_id: __u64,
    pub vmsa_gpa: __u64,
}
#[test]
fn bindgen_test_layout_mshv_sev_snp_ap_create() {
    const UNINIT: ::std::mem::MaybeUninit<mshv_sev_snp_ap_create> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mshv_sev_snp_ap_create>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_sev_snp_ap_create))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_sev_snp_ap_create>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_sev_snp_ap_create))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_sev_snp_ap_create),
            "::",
            stringify!(vp_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmsa_gpa) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_sev_snp_ap_create),
            "::",
            stringify!(vmsa_gpa)
        )
    );
}
