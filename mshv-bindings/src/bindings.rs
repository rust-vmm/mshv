/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const HV_PARTITION_PROCESSOR_FEATURE_BANKS: u32 = 2;
pub const HV_INTERCEPT_ACCESS_READ: u32 = 0;
pub const HV_INTERCEPT_ACCESS_WRITE: u32 = 1;
pub const HV_INTERCEPT_ACCESS_EXECUTE: u32 = 2;
pub const HV_HYPERCALL_INTERCEPT_MAX_XMM_REGISTERS: u32 = 6;
pub const HV_CACHE_TYPE_UNCACHED: u32 = 0;
pub const HV_CACHE_TYPE_WRITE_COMBINING: u32 = 1;
pub const HV_CACHE_TYPE_WRITE_THROUGH: u32 = 4;
pub const HV_CACHE_TYPE_WRITE_PROTECTED: u32 = 5;
pub const HV_CACHE_TYPE_WRITE_BACK: u32 = 6;
pub const HV_UNSUPPORTED_FEATURE_INTERCEPT: u32 = 1;
pub const HV_UNSUPPORTED_FEATURE_TASK_SWITCH_TSS: u32 = 2;
pub const HV_X64_PENDING_INTERRUPT: u32 = 0;
pub const HV_X64_PENDING_NMI: u32 = 2;
pub const HV_X64_PENDING_EXCEPTION: u32 = 3;
pub const HV_INTERCEPT_ACCESS_MASK_NONE: u32 = 0;
pub const HV_INTERCEPT_ACCESS_MASK_READ: u32 = 1;
pub const HV_INTERCEPT_ACCESS_MASK_WRITE: u32 = 2;
pub const HV_INTERCEPT_ACCESS_MASK_EXECUTE: u32 = 4;
pub const HV_INTERRUPT_VECTOR_NONE: u32 = 4294967295;
pub const HV_XSAVE_DATA_NO_XMM_REGISTERS: u32 = 1;
pub const HV_X64_REGISTER_CLASS_GENERAL: u32 = 0;
pub const HV_X64_REGISTER_CLASS_IP: u32 = 1;
pub const HV_X64_REGISTER_CLASS_XMM: u32 = 2;
pub const HV_X64_REGISTER_CLASS_SEGMENT: u32 = 3;
pub const HV_X64_REGISTER_CLASS_FLAGS: u32 = 4;
pub const HV_VP_REGISTER_PAGE_VERSION_1: u32 = 1;
pub const HV_PARTITION_SYNTHETIC_PROCESSOR_FEATURES_BANKS: u32 = 1;
pub const HV_MESSAGE_SIZE: u32 = 256;
pub const HV_MESSAGE_PAYLOAD_BYTE_COUNT: u32 = 240;
pub const HV_MESSAGE_PAYLOAD_QWORD_COUNT: u32 = 30;
pub const HV_ANY_VP: u32 = 4294967295;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_MASK: u32 = 7;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_ANY: u32 = 0;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_BYTE: u32 = 1;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_WORD: u32 = 2;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_DWORD: u32 = 3;
pub const HV_DOORBELL_FLAG_TRIGGER_SIZE_QWORD: u32 = 4;
pub const HV_DOORBELL_FLAG_TRIGGER_ANY_VALUE: u32 = 2147483648;
pub const HV_PARTITION_CREATION_FLAG_SMT_ENABLED_GUEST: u32 = 1;
pub const HV_PARTITION_CREATION_FLAG_GPA_LARGE_PAGES_DISABLED: u32 = 8;
pub const HV_PARTITION_CREATION_FLAG_GPA_SUPER_PAGES_ENABLED: u32 = 16;
pub const HV_PARTITION_CREATION_FLAG_LAPIC_ENABLED: u32 = 8192;
pub const HV_MAP_GPA_PERMISSIONS_NONE: u32 = 0;
pub const HV_MAP_GPA_READABLE: u32 = 1;
pub const HV_MAP_GPA_WRITABLE: u32 = 2;
pub const HV_MAP_GPA_KERNEL_EXECUTABLE: u32 = 4;
pub const HV_MAP_GPA_USER_EXECUTABLE: u32 = 8;
pub const HV_MAP_GPA_EXECUTABLE: u32 = 12;
pub const HV_MAP_GPA_PERMISSIONS_MASK: u32 = 15;
pub const HV_GET_SET_VP_STATE_TYPE_PFN: u32 = 2147483648;
pub const HV_TRANSLATE_GVA_VALIDATE_READ: u32 = 1;
pub const HV_TRANSLATE_GVA_VALIDATE_WRITE: u32 = 2;
pub const HV_TRANSLATE_GVA_VALIDATE_EXECUTE: u32 = 4;
pub const HV_TRANSLATE_GVA_PRIVILEGE_EXCEMP: u32 = 8;
pub const HV_TRANSLATE_GVA_SET_PAGE_TABLE_BITS: u32 = 16;
pub const HV_TRANSLATE_GVA_TLB_FLUSH_INHIBIT: u32 = 32;
pub const HV_TRANSLATE_GVA_CONTROL_MASK: u32 = 63;
pub const MSHV_CAP_CORE_API_STABLE: u32 = 0;
pub const MSHV_VP_MAX_REGISTERS: u32 = 128;
pub const MSHV_IRQFD_FLAG_DEASSIGN: u32 = 1;
pub const MSHV_IRQFD_FLAG_RESAMPLE: u32 = 2;
pub const MSHV_IOCTL: u32 = 184;
pub const MSHV_CREATE_DEVICE_TEST: u32 = 1;
pub const MSHV_DEV_VFIO_GROUP: u32 = 1;
pub const MSHV_DEV_VFIO_GROUP_ADD: u32 = 1;
pub const MSHV_DEV_VFIO_GROUP_DEL: u32 = 2;
pub type bool_ = bool;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_processor_features {
    pub __bindgen_anon_1: hv_partition_processor_features__bindgen_ty_1,
    pub as_uint64: [__u64; 2usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_partition_processor_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_processor_features__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_features__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_processor_features__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_features__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_processor_features__bindgen_ty_1)
        )
    );
}
impl hv_partition_processor_features__bindgen_ty_1 {
    #[inline]
    pub fn sse3_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse3_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lahf_sahf_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lahf_sahf_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssse3_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssse3_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4_1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse4_1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4_2_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse4_2_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse4a_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sse4a_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xop_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xop_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pop_cnt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pop_cnt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmpxchg16b_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cmpxchg16b_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn altmovcr8_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_altmovcr8_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lzcnt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lzcnt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mis_align_sse_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mis_align_sse_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmx_ext_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmx_ext_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amd3dnow_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_amd3dnow_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_amd3dnow_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_extended_amd3dnow_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn page_1gb_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_page_1gb_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aes_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_aes_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pclmulqdq_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pclmulqdq_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcid_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pcid_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fma4_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fma4_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn f16c_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_f16c_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_rand_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_rand_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_wr_fs_gs_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_wr_fs_gs_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smep_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smep_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_fast_string_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enhanced_fast_string_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bmi1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bmi1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bmi2_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bmi2_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hle_support_deprecated(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hle_support_deprecated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtm_support_deprecated(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rtm_support_deprecated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movbe_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_movbe_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn npiep1_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_npiep1_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dep_x87_fpu_save_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dep_x87_fpu_save_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_seed_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_seed_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adx_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_adx_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intel_prefetch_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intel_prefetch_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smap_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_smap_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hle_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hle_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtm_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rtm_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdtscp_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdtscp_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clflushopt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clflushopt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clwb_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clwb_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sha_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x87_pointers_saved_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_x87_pointers_saved_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invpcid_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_invpcid_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibrs_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ibrs_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stibp_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_stibp_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibpb_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ibpb_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unrestricted_guest_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_unrestricted_guest_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mdd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mdd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_short_rep_mov_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fast_short_rep_mov_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l1dcache_flush_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_l1dcache_flush_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdcl_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdcl_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ibrs_all_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ibrs_all_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_l1df_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_skip_l1df_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssb_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ssb_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsb_a_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rsb_a_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virt_spec_ctrl_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_virt_spec_ctrl_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_pid_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rd_pid_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn umip_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_umip_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbs_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mbs_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_clear_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mb_clear_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn taa_no_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_taa_no_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsx_ctrl_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsx_ctrl_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_bank0(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_bank0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acount_mcount_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_acount_mcount_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_invariant_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsc_invariant_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_zero_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cl_zero_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdpru_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdpru_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn la57_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_la57_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbec_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(69usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mbec_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(69usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nested_virt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(70usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nested_virt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(70usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psfd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_psfd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_ss_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_ss_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_ibt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(73usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_ibt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(73usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vmx_exception_inject_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_vmx_exception_inject_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enqcmd_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enqcmd_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn umwait_tpause_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_umwait_tpause_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movdiri_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_movdiri_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn movdir64b_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_movdir64b_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cldemote_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cldemote_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn serialize_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_serialize_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_deadline_tmr_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsc_deadline_tmr_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsc_adjust_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tsc_adjust_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fzlrep_movsb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fzlrep_movsb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsrep_stosb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fsrep_stosb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsrep_cmpsb(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fsrep_cmpsb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_bank1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(86usize, 42u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_bank1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(86usize, 42u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sse3_support: __u64,
        lahf_sahf_support: __u64,
        ssse3_support: __u64,
        sse4_1_support: __u64,
        sse4_2_support: __u64,
        sse4a_support: __u64,
        xop_support: __u64,
        pop_cnt_support: __u64,
        cmpxchg16b_support: __u64,
        altmovcr8_support: __u64,
        lzcnt_support: __u64,
        mis_align_sse_support: __u64,
        mmx_ext_support: __u64,
        amd3dnow_support: __u64,
        extended_amd3dnow_support: __u64,
        page_1gb_support: __u64,
        aes_support: __u64,
        pclmulqdq_support: __u64,
        pcid_support: __u64,
        fma4_support: __u64,
        f16c_support: __u64,
        rd_rand_support: __u64,
        rd_wr_fs_gs_support: __u64,
        smep_support: __u64,
        enhanced_fast_string_support: __u64,
        bmi1_support: __u64,
        bmi2_support: __u64,
        hle_support_deprecated: __u64,
        rtm_support_deprecated: __u64,
        movbe_support: __u64,
        npiep1_support: __u64,
        dep_x87_fpu_save_support: __u64,
        rd_seed_support: __u64,
        adx_support: __u64,
        intel_prefetch_support: __u64,
        smap_support: __u64,
        hle_support: __u64,
        rtm_support: __u64,
        rdtscp_support: __u64,
        clflushopt_support: __u64,
        clwb_support: __u64,
        sha_support: __u64,
        x87_pointers_saved_support: __u64,
        invpcid_support: __u64,
        ibrs_support: __u64,
        stibp_support: __u64,
        ibpb_support: __u64,
        unrestricted_guest_support: __u64,
        mdd_support: __u64,
        fast_short_rep_mov_support: __u64,
        l1dcache_flush_support: __u64,
        rdcl_no_support: __u64,
        ibrs_all_support: __u64,
        skip_l1df_support: __u64,
        ssb_no_support: __u64,
        rsb_a_no_support: __u64,
        virt_spec_ctrl_support: __u64,
        rd_pid_support: __u64,
        umip_support: __u64,
        mbs_no_support: __u64,
        mb_clear_support: __u64,
        taa_no_support: __u64,
        tsx_ctrl_support: __u64,
        reserved_bank0: __u64,
        acount_mcount_support: __u64,
        tsc_invariant_support: __u64,
        cl_zero_support: __u64,
        rdpru_support: __u64,
        la57_support: __u64,
        mbec_support: __u64,
        nested_virt_support: __u64,
        psfd_support: __u64,
        cet_ss_support: __u64,
        cet_ibt_support: __u64,
        vmx_exception_inject_support: __u64,
        enqcmd_support: __u64,
        umwait_tpause_support: __u64,
        movdiri_support: __u64,
        movdir64b_support: __u64,
        cldemote_support: __u64,
        serialize_support: __u64,
        tsc_deadline_tmr_support: __u64,
        tsc_adjust_support: __u64,
        fzlrep_movsb: __u64,
        fsrep_stosb: __u64,
        fsrep_cmpsb: __u64,
        reserved_bank1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sse3_support: u64 = unsafe { ::std::mem::transmute(sse3_support) };
            sse3_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lahf_sahf_support: u64 = unsafe { ::std::mem::transmute(lahf_sahf_support) };
            lahf_sahf_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ssse3_support: u64 = unsafe { ::std::mem::transmute(ssse3_support) };
            ssse3_support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sse4_1_support: u64 = unsafe { ::std::mem::transmute(sse4_1_support) };
            sse4_1_support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sse4_2_support: u64 = unsafe { ::std::mem::transmute(sse4_2_support) };
            sse4_2_support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sse4a_support: u64 = unsafe { ::std::mem::transmute(sse4a_support) };
            sse4a_support as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let xop_support: u64 = unsafe { ::std::mem::transmute(xop_support) };
            xop_support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pop_cnt_support: u64 = unsafe { ::std::mem::transmute(pop_cnt_support) };
            pop_cnt_support as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cmpxchg16b_support: u64 = unsafe { ::std::mem::transmute(cmpxchg16b_support) };
            cmpxchg16b_support as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let altmovcr8_support: u64 = unsafe { ::std::mem::transmute(altmovcr8_support) };
            altmovcr8_support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let lzcnt_support: u64 = unsafe { ::std::mem::transmute(lzcnt_support) };
            lzcnt_support as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mis_align_sse_support: u64 =
                unsafe { ::std::mem::transmute(mis_align_sse_support) };
            mis_align_sse_support as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mmx_ext_support: u64 = unsafe { ::std::mem::transmute(mmx_ext_support) };
            mmx_ext_support as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let amd3dnow_support: u64 = unsafe { ::std::mem::transmute(amd3dnow_support) };
            amd3dnow_support as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let extended_amd3dnow_support: u64 =
                unsafe { ::std::mem::transmute(extended_amd3dnow_support) };
            extended_amd3dnow_support as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let page_1gb_support: u64 = unsafe { ::std::mem::transmute(page_1gb_support) };
            page_1gb_support as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let aes_support: u64 = unsafe { ::std::mem::transmute(aes_support) };
            aes_support as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pclmulqdq_support: u64 = unsafe { ::std::mem::transmute(pclmulqdq_support) };
            pclmulqdq_support as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pcid_support: u64 = unsafe { ::std::mem::transmute(pcid_support) };
            pcid_support as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let fma4_support: u64 = unsafe { ::std::mem::transmute(fma4_support) };
            fma4_support as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let f16c_support: u64 = unsafe { ::std::mem::transmute(f16c_support) };
            f16c_support as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rd_rand_support: u64 = unsafe { ::std::mem::transmute(rd_rand_support) };
            rd_rand_support as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rd_wr_fs_gs_support: u64 = unsafe { ::std::mem::transmute(rd_wr_fs_gs_support) };
            rd_wr_fs_gs_support as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let smep_support: u64 = unsafe { ::std::mem::transmute(smep_support) };
            smep_support as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let enhanced_fast_string_support: u64 =
                unsafe { ::std::mem::transmute(enhanced_fast_string_support) };
            enhanced_fast_string_support as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bmi1_support: u64 = unsafe { ::std::mem::transmute(bmi1_support) };
            bmi1_support as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let bmi2_support: u64 = unsafe { ::std::mem::transmute(bmi2_support) };
            bmi2_support as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let hle_support_deprecated: u64 =
                unsafe { ::std::mem::transmute(hle_support_deprecated) };
            hle_support_deprecated as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rtm_support_deprecated: u64 =
                unsafe { ::std::mem::transmute(rtm_support_deprecated) };
            rtm_support_deprecated as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let movbe_support: u64 = unsafe { ::std::mem::transmute(movbe_support) };
            movbe_support as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let npiep1_support: u64 = unsafe { ::std::mem::transmute(npiep1_support) };
            npiep1_support as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dep_x87_fpu_save_support: u64 =
                unsafe { ::std::mem::transmute(dep_x87_fpu_save_support) };
            dep_x87_fpu_save_support as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let rd_seed_support: u64 = unsafe { ::std::mem::transmute(rd_seed_support) };
            rd_seed_support as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let adx_support: u64 = unsafe { ::std::mem::transmute(adx_support) };
            adx_support as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let intel_prefetch_support: u64 =
                unsafe { ::std::mem::transmute(intel_prefetch_support) };
            intel_prefetch_support as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let smap_support: u64 = unsafe { ::std::mem::transmute(smap_support) };
            smap_support as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let hle_support: u64 = unsafe { ::std::mem::transmute(hle_support) };
            hle_support as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let rtm_support: u64 = unsafe { ::std::mem::transmute(rtm_support) };
            rtm_support as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let rdtscp_support: u64 = unsafe { ::std::mem::transmute(rdtscp_support) };
            rdtscp_support as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let clflushopt_support: u64 = unsafe { ::std::mem::transmute(clflushopt_support) };
            clflushopt_support as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let clwb_support: u64 = unsafe { ::std::mem::transmute(clwb_support) };
            clwb_support as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let sha_support: u64 = unsafe { ::std::mem::transmute(sha_support) };
            sha_support as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let x87_pointers_saved_support: u64 =
                unsafe { ::std::mem::transmute(x87_pointers_saved_support) };
            x87_pointers_saved_support as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let invpcid_support: u64 = unsafe { ::std::mem::transmute(invpcid_support) };
            invpcid_support as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let ibrs_support: u64 = unsafe { ::std::mem::transmute(ibrs_support) };
            ibrs_support as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let stibp_support: u64 = unsafe { ::std::mem::transmute(stibp_support) };
            stibp_support as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let ibpb_support: u64 = unsafe { ::std::mem::transmute(ibpb_support) };
            ibpb_support as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let unrestricted_guest_support: u64 =
                unsafe { ::std::mem::transmute(unrestricted_guest_support) };
            unrestricted_guest_support as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let mdd_support: u64 = unsafe { ::std::mem::transmute(mdd_support) };
            mdd_support as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let fast_short_rep_mov_support: u64 =
                unsafe { ::std::mem::transmute(fast_short_rep_mov_support) };
            fast_short_rep_mov_support as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let l1dcache_flush_support: u64 =
                unsafe { ::std::mem::transmute(l1dcache_flush_support) };
            l1dcache_flush_support as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let rdcl_no_support: u64 = unsafe { ::std::mem::transmute(rdcl_no_support) };
            rdcl_no_support as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let ibrs_all_support: u64 = unsafe { ::std::mem::transmute(ibrs_all_support) };
            ibrs_all_support as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let skip_l1df_support: u64 = unsafe { ::std::mem::transmute(skip_l1df_support) };
            skip_l1df_support as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let ssb_no_support: u64 = unsafe { ::std::mem::transmute(ssb_no_support) };
            ssb_no_support as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let rsb_a_no_support: u64 = unsafe { ::std::mem::transmute(rsb_a_no_support) };
            rsb_a_no_support as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let virt_spec_ctrl_support: u64 =
                unsafe { ::std::mem::transmute(virt_spec_ctrl_support) };
            virt_spec_ctrl_support as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let rd_pid_support: u64 = unsafe { ::std::mem::transmute(rd_pid_support) };
            rd_pid_support as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let umip_support: u64 = unsafe { ::std::mem::transmute(umip_support) };
            umip_support as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let mbs_no_support: u64 = unsafe { ::std::mem::transmute(mbs_no_support) };
            mbs_no_support as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let mb_clear_support: u64 = unsafe { ::std::mem::transmute(mb_clear_support) };
            mb_clear_support as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let taa_no_support: u64 = unsafe { ::std::mem::transmute(taa_no_support) };
            taa_no_support as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let tsx_ctrl_support: u64 = unsafe { ::std::mem::transmute(tsx_ctrl_support) };
            tsx_ctrl_support as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let reserved_bank0: u64 = unsafe { ::std::mem::transmute(reserved_bank0) };
            reserved_bank0 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let acount_mcount_support: u64 =
                unsafe { ::std::mem::transmute(acount_mcount_support) };
            acount_mcount_support as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let tsc_invariant_support: u64 =
                unsafe { ::std::mem::transmute(tsc_invariant_support) };
            tsc_invariant_support as u64
        });
        __bindgen_bitfield_unit.set(66usize, 1u8, {
            let cl_zero_support: u64 = unsafe { ::std::mem::transmute(cl_zero_support) };
            cl_zero_support as u64
        });
        __bindgen_bitfield_unit.set(67usize, 1u8, {
            let rdpru_support: u64 = unsafe { ::std::mem::transmute(rdpru_support) };
            rdpru_support as u64
        });
        __bindgen_bitfield_unit.set(68usize, 1u8, {
            let la57_support: u64 = unsafe { ::std::mem::transmute(la57_support) };
            la57_support as u64
        });
        __bindgen_bitfield_unit.set(69usize, 1u8, {
            let mbec_support: u64 = unsafe { ::std::mem::transmute(mbec_support) };
            mbec_support as u64
        });
        __bindgen_bitfield_unit.set(70usize, 1u8, {
            let nested_virt_support: u64 = unsafe { ::std::mem::transmute(nested_virt_support) };
            nested_virt_support as u64
        });
        __bindgen_bitfield_unit.set(71usize, 1u8, {
            let psfd_support: u64 = unsafe { ::std::mem::transmute(psfd_support) };
            psfd_support as u64
        });
        __bindgen_bitfield_unit.set(72usize, 1u8, {
            let cet_ss_support: u64 = unsafe { ::std::mem::transmute(cet_ss_support) };
            cet_ss_support as u64
        });
        __bindgen_bitfield_unit.set(73usize, 1u8, {
            let cet_ibt_support: u64 = unsafe { ::std::mem::transmute(cet_ibt_support) };
            cet_ibt_support as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let vmx_exception_inject_support: u64 =
                unsafe { ::std::mem::transmute(vmx_exception_inject_support) };
            vmx_exception_inject_support as u64
        });
        __bindgen_bitfield_unit.set(75usize, 1u8, {
            let enqcmd_support: u64 = unsafe { ::std::mem::transmute(enqcmd_support) };
            enqcmd_support as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let umwait_tpause_support: u64 =
                unsafe { ::std::mem::transmute(umwait_tpause_support) };
            umwait_tpause_support as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let movdiri_support: u64 = unsafe { ::std::mem::transmute(movdiri_support) };
            movdiri_support as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let movdir64b_support: u64 = unsafe { ::std::mem::transmute(movdir64b_support) };
            movdir64b_support as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let cldemote_support: u64 = unsafe { ::std::mem::transmute(cldemote_support) };
            cldemote_support as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let serialize_support: u64 = unsafe { ::std::mem::transmute(serialize_support) };
            serialize_support as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let tsc_deadline_tmr_support: u64 =
                unsafe { ::std::mem::transmute(tsc_deadline_tmr_support) };
            tsc_deadline_tmr_support as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let tsc_adjust_support: u64 = unsafe { ::std::mem::transmute(tsc_adjust_support) };
            tsc_adjust_support as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let fzlrep_movsb: u64 = unsafe { ::std::mem::transmute(fzlrep_movsb) };
            fzlrep_movsb as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let fsrep_stosb: u64 = unsafe { ::std::mem::transmute(fsrep_stosb) };
            fsrep_stosb as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let fsrep_cmpsb: u64 = unsafe { ::std::mem::transmute(fsrep_cmpsb) };
            fsrep_cmpsb as u64
        });
        __bindgen_bitfield_unit.set(86usize, 42u8, {
            let reserved_bank1: u64 = unsafe { ::std::mem::transmute(reserved_bank1) };
            reserved_bank1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_processor_features() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_features>(),
        16usize,
        concat!("Size of: ", stringify!(hv_partition_processor_features))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_features>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_partition_processor_features))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_partition_processor_features>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_processor_features),
            "::",
            stringify!(as_uint64)
        )
    );
}
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_FAULT:
    hv_unimplemented_msr_action = 0;
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_IGNORE_WRITE_READ_ZERO:
    hv_unimplemented_msr_action = 1;
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_COUNT:
    hv_unimplemented_msr_action = 2;
pub type hv_unimplemented_msr_action = ::std::os::raw::c_uint;
impl Default for hv_partition_processor_features {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_processor_xsave_features {
    pub __bindgen_anon_1: hv_partition_processor_xsave_features__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_partition_processor_xsave_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_processor_xsave_features__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_xsave_features__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_processor_xsave_features__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_xsave_features__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_processor_xsave_features__bindgen_ty_1)
        )
    );
}
impl hv_partition_processor_xsave_features__bindgen_ty_1 {
    #[inline]
    pub fn xsave_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsave_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xsaveopt_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xsaveopt_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_support(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_support(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xsave_support: __u64,
        xsaveopt_support: __u64,
        avx_support: __u64,
        reserved1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xsave_support: u64 = unsafe { ::std::mem::transmute(xsave_support) };
            xsave_support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xsaveopt_support: u64 = unsafe { ::std::mem::transmute(xsaveopt_support) };
            xsaveopt_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let avx_support: u64 = unsafe { ::std::mem::transmute(avx_support) };
            avx_support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let reserved1: u64 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_processor_xsave_features() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_processor_xsave_features>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_processor_xsave_features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_processor_xsave_features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_processor_xsave_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_partition_processor_xsave_features>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_processor_xsave_features),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_processor_xsave_features {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_partition_creation_properties {
    pub disabled_processor_features: hv_partition_processor_features,
    pub disabled_processor_xsave_features: hv_partition_processor_xsave_features,
}
#[test]
fn bindgen_test_layout_hv_partition_creation_properties() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_creation_properties>(),
        24usize,
        concat!("Size of: ", stringify!(hv_partition_creation_properties))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_creation_properties>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_creation_properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_partition_creation_properties>())).disabled_processor_features
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_creation_properties),
            "::",
            stringify!(disabled_processor_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_partition_creation_properties>()))
                .disabled_processor_xsave_features as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_creation_properties),
            "::",
            stringify!(disabled_processor_xsave_features)
        )
    );
}
impl Default for hv_partition_creation_properties {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum hv_register_name {
    HV_REGISTER_EXPLICIT_SUSPEND = 0,
    HV_REGISTER_INTERCEPT_SUSPEND = 1,
    HV_REGISTER_INSTRUCTION_EMULATION_HINTS = 2,
    HV_REGISTER_DISPATCH_SUSPEND = 3,
    HV_REGISTER_INTERNAL_ACTIVITY_STATE = 4,
    HV_REGISTER_HYPERVISOR_VERSION = 256,
    HV_REGISTER_PRIVILEGES_AND_FEATURES_INFO = 512,
    HV_REGISTER_FEATURES_INFO = 513,
    HV_REGISTER_IMPLEMENTATION_LIMITS_INFO = 514,
    HV_REGISTER_HARDWARE_FEATURES_INFO = 515,
    HV_REGISTER_CPU_MANAGEMENT_FEATURES_INFO = 516,
    HV_REGISTER_SVM_FEATURES_INFO = 517,
    HV_REGISTER_SKIP_LEVEL_FEATURES_INFO = 518,
    HV_REGISTER_NESTED_VIRT_FEATURES_INFO = 519,
    HV_REGISTER_IPT_FEATURES_INFO = 520,
    HV_REGISTER_GUEST_CRASH_P0 = 528,
    HV_REGISTER_GUEST_CRASH_P1 = 529,
    HV_REGISTER_GUEST_CRASH_P2 = 530,
    HV_REGISTER_GUEST_CRASH_P3 = 531,
    HV_REGISTER_GUEST_CRASH_P4 = 532,
    HV_REGISTER_GUEST_CRASH_CTL = 533,
    HV_REGISTER_POWER_STATE_CONFIG_C1 = 544,
    HV_REGISTER_POWER_STATE_TRIGGER_C1 = 545,
    HV_REGISTER_POWER_STATE_CONFIG_C2 = 546,
    HV_REGISTER_POWER_STATE_TRIGGER_C2 = 547,
    HV_REGISTER_POWER_STATE_CONFIG_C3 = 548,
    HV_REGISTER_POWER_STATE_TRIGGER_C3 = 549,
    HV_REGISTER_PROCESSOR_CLOCK_FREQUENCY = 576,
    HV_REGISTER_INTERRUPT_CLOCK_FREQUENCY = 577,
    HV_REGISTER_GUEST_IDLE = 592,
    HV_REGISTER_DEBUG_DEVICE_OPTIONS = 608,
    HV_REGISTER_MEMORY_ZEROING_CONTROL = 624,
    HV_REGISTER_PENDING_EVENT0 = 65540,
    HV_REGISTER_PENDING_EVENT1 = 65541,
    HV_REGISTER_VP_RUNTIME = 589824,
    HV_REGISTER_GUEST_OS_ID = 589826,
    HV_REGISTER_VP_INDEX = 589827,
    HV_REGISTER_TIME_REF_COUNT = 589828,
    HV_REGISTER_CPU_MANAGEMENT_VERSION = 589831,
    HV_REGISTER_VP_ASSIST_PAGE = 589843,
    HV_REGISTER_VP_ROOT_SIGNAL_COUNT = 589844,
    HV_REGISTER_REFERENCE_TSC = 589847,
    HV_REGISTER_STATS_PARTITION_RETAIL = 589856,
    HV_REGISTER_STATS_PARTITION_INTERNAL = 589857,
    HV_REGISTER_STATS_VP_RETAIL = 589858,
    HV_REGISTER_STATS_VP_INTERNAL = 589859,
    HV_REGISTER_NESTED_VP_INDEX = 593923,
    HV_REGISTER_SINT0 = 655360,
    HV_REGISTER_SINT1 = 655361,
    HV_REGISTER_SINT2 = 655362,
    HV_REGISTER_SINT3 = 655363,
    HV_REGISTER_SINT4 = 655364,
    HV_REGISTER_SINT5 = 655365,
    HV_REGISTER_SINT6 = 655366,
    HV_REGISTER_SINT7 = 655367,
    HV_REGISTER_SINT8 = 655368,
    HV_REGISTER_SINT9 = 655369,
    HV_REGISTER_SINT10 = 655370,
    HV_REGISTER_SINT11 = 655371,
    HV_REGISTER_SINT12 = 655372,
    HV_REGISTER_SINT13 = 655373,
    HV_REGISTER_SINT14 = 655374,
    HV_REGISTER_SINT15 = 655375,
    HV_REGISTER_SCONTROL = 655376,
    HV_REGISTER_SVERSION = 655377,
    HV_REGISTER_SIFP = 655378,
    HV_REGISTER_SIPP = 655379,
    HV_REGISTER_EOM = 655380,
    HV_REGISTER_SIRBP = 655381,
    HV_REGISTER_NESTED_SINT0 = 659456,
    HV_REGISTER_NESTED_SINT1 = 659457,
    HV_REGISTER_NESTED_SINT2 = 659458,
    HV_REGISTER_NESTED_SINT3 = 659459,
    HV_REGISTER_NESTED_SINT4 = 659460,
    HV_REGISTER_NESTED_SINT5 = 659461,
    HV_REGISTER_NESTED_SINT6 = 659462,
    HV_REGISTER_NESTED_SINT7 = 659463,
    HV_REGISTER_NESTED_SINT8 = 659464,
    HV_REGISTER_NESTED_SINT9 = 659465,
    HV_REGISTER_NESTED_SINT10 = 659466,
    HV_REGISTER_NESTED_SINT11 = 659467,
    HV_REGISTER_NESTED_SINT12 = 659468,
    HV_REGISTER_NESTED_SINT13 = 659469,
    HV_REGISTER_NESTED_SINT14 = 659470,
    HV_REGISTER_NESTED_SINT15 = 659471,
    HV_REGISTER_NESTED_SCONTROL = 659472,
    HV_REGISTER_NESTED_SVERSION = 659473,
    HV_REGISTER_NESTED_SIFP = 659474,
    HV_REGISTER_NESTED_SIPP = 659475,
    HV_REGISTER_NESTED_EOM = 659476,
    HV_REGISTER_NESTED_SIRBP = 659477,
    HV_REGISTER_STIMER0_CONFIG = 720896,
    HV_REGISTER_STIMER0_COUNT = 720897,
    HV_REGISTER_STIMER1_CONFIG = 720898,
    HV_REGISTER_STIMER1_COUNT = 720899,
    HV_REGISTER_STIMER2_CONFIG = 720900,
    HV_REGISTER_STIMER2_COUNT = 720901,
    HV_REGISTER_STIMER3_CONFIG = 720902,
    HV_REGISTER_STIMER3_COUNT = 720903,
    HV_REGISTER_STIME_UNHALTED_TIMER_CONFIG = 721152,
    HV_REGISTER_STIME_UNHALTED_TIMER_COUNT = 721153,
    HV_REGISTER_VSM_CODE_PAGE_OFFSETS = 851970,
    HV_REGISTER_VSM_VP_STATUS = 851971,
    HV_REGISTER_VSM_PARTITION_STATUS = 851972,
    HV_REGISTER_VSM_VINA = 851973,
    HV_REGISTER_VSM_CAPABILITIES = 851974,
    HV_REGISTER_VSM_PARTITION_CONFIG = 851975,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL0 = 851984,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL1 = 851985,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL2 = 851986,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL3 = 851987,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL4 = 851988,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL5 = 851989,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL6 = 851990,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL7 = 851991,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL8 = 851992,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL9 = 851993,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL10 = 851994,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL11 = 851995,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL12 = 851996,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL13 = 851997,
    HV_REGISTER_VSM_VP_SECURE_CONFIG_VTL14 = 851998,
    HV_REGISTER_VSM_VP_WAIT_FOR_TLB_LOCK = 852000,
    HV_REGISTER_ISOLATION_CAPABILITIES = 852224,
    HV_REGISTER_PENDING_INTERRUPTION = 65538,
    HV_REGISTER_INTERRUPT_STATE = 65539,
    HV_X64_REGISTER_DELIVERABILITY_NOTIFICATIONS = 65542,
    HV_X64_REGISTER_RAX = 131072,
    HV_X64_REGISTER_RCX = 131073,
    HV_X64_REGISTER_RDX = 131074,
    HV_X64_REGISTER_RBX = 131075,
    HV_X64_REGISTER_RSP = 131076,
    HV_X64_REGISTER_RBP = 131077,
    HV_X64_REGISTER_RSI = 131078,
    HV_X64_REGISTER_RDI = 131079,
    HV_X64_REGISTER_R8 = 131080,
    HV_X64_REGISTER_R9 = 131081,
    HV_X64_REGISTER_R10 = 131082,
    HV_X64_REGISTER_R11 = 131083,
    HV_X64_REGISTER_R12 = 131084,
    HV_X64_REGISTER_R13 = 131085,
    HV_X64_REGISTER_R14 = 131086,
    HV_X64_REGISTER_R15 = 131087,
    HV_X64_REGISTER_RIP = 131088,
    HV_X64_REGISTER_RFLAGS = 131089,
    HV_X64_REGISTER_XMM0 = 196608,
    HV_X64_REGISTER_XMM1 = 196609,
    HV_X64_REGISTER_XMM2 = 196610,
    HV_X64_REGISTER_XMM3 = 196611,
    HV_X64_REGISTER_XMM4 = 196612,
    HV_X64_REGISTER_XMM5 = 196613,
    HV_X64_REGISTER_XMM6 = 196614,
    HV_X64_REGISTER_XMM7 = 196615,
    HV_X64_REGISTER_XMM8 = 196616,
    HV_X64_REGISTER_XMM9 = 196617,
    HV_X64_REGISTER_XMM10 = 196618,
    HV_X64_REGISTER_XMM11 = 196619,
    HV_X64_REGISTER_XMM12 = 196620,
    HV_X64_REGISTER_XMM13 = 196621,
    HV_X64_REGISTER_XMM14 = 196622,
    HV_X64_REGISTER_XMM15 = 196623,
    HV_X64_REGISTER_FP_MMX0 = 196624,
    HV_X64_REGISTER_FP_MMX1 = 196625,
    HV_X64_REGISTER_FP_MMX2 = 196626,
    HV_X64_REGISTER_FP_MMX3 = 196627,
    HV_X64_REGISTER_FP_MMX4 = 196628,
    HV_X64_REGISTER_FP_MMX5 = 196629,
    HV_X64_REGISTER_FP_MMX6 = 196630,
    HV_X64_REGISTER_FP_MMX7 = 196631,
    HV_X64_REGISTER_FP_CONTROL_STATUS = 196632,
    HV_X64_REGISTER_XMM_CONTROL_STATUS = 196633,
    HV_X64_REGISTER_CR0 = 262144,
    HV_X64_REGISTER_CR2 = 262145,
    HV_X64_REGISTER_CR3 = 262146,
    HV_X64_REGISTER_CR4 = 262147,
    HV_X64_REGISTER_CR8 = 262148,
    HV_X64_REGISTER_XFEM = 262149,
    HV_X64_REGISTER_INTERMEDIATE_CR0 = 266240,
    HV_X64_REGISTER_INTERMEDIATE_CR4 = 266243,
    HV_X64_REGISTER_INTERMEDIATE_CR8 = 266244,
    HV_X64_REGISTER_DR0 = 327680,
    HV_X64_REGISTER_DR1 = 327681,
    HV_X64_REGISTER_DR2 = 327682,
    HV_X64_REGISTER_DR3 = 327683,
    HV_X64_REGISTER_DR6 = 327684,
    HV_X64_REGISTER_DR7 = 327685,
    HV_X64_REGISTER_ES = 393216,
    HV_X64_REGISTER_CS = 393217,
    HV_X64_REGISTER_SS = 393218,
    HV_X64_REGISTER_DS = 393219,
    HV_X64_REGISTER_FS = 393220,
    HV_X64_REGISTER_GS = 393221,
    HV_X64_REGISTER_LDTR = 393222,
    HV_X64_REGISTER_TR = 393223,
    HV_X64_REGISTER_IDTR = 458752,
    HV_X64_REGISTER_GDTR = 458753,
    HV_X64_REGISTER_TSC = 524288,
    HV_X64_REGISTER_EFER = 524289,
    HV_X64_REGISTER_KERNEL_GS_BASE = 524290,
    HV_X64_REGISTER_APIC_BASE = 524291,
    HV_X64_REGISTER_PAT = 524292,
    HV_X64_REGISTER_SYSENTER_CS = 524293,
    HV_X64_REGISTER_SYSENTER_EIP = 524294,
    HV_X64_REGISTER_SYSENTER_ESP = 524295,
    HV_X64_REGISTER_STAR = 524296,
    HV_X64_REGISTER_LSTAR = 524297,
    HV_X64_REGISTER_CSTAR = 524298,
    HV_X64_REGISTER_SFMASK = 524299,
    HV_X64_REGISTER_INITIAL_APIC_ID = 524300,
    HV_X64_REGISTER_MSR_MTRR_CAP = 524301,
    HV_X64_REGISTER_MSR_MTRR_DEF_TYPE = 524302,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE0 = 524304,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE1 = 524305,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE2 = 524306,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE3 = 524307,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE4 = 524308,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE5 = 524309,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE6 = 524310,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE7 = 524311,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE8 = 524312,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASE9 = 524313,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASEA = 524314,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASEB = 524315,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASEC = 524316,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASED = 524317,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASEE = 524318,
    HV_X64_REGISTER_MSR_MTRR_PHYS_BASEF = 524319,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK0 = 524352,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK1 = 524353,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK2 = 524354,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK3 = 524355,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK4 = 524356,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK5 = 524357,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK6 = 524358,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK7 = 524359,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK8 = 524360,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASK9 = 524361,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASKA = 524362,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASKB = 524363,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASKC = 524364,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASKD = 524365,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASKE = 524366,
    HV_X64_REGISTER_MSR_MTRR_PHYS_MASKF = 524367,
    HV_X64_REGISTER_MSR_MTRR_FIX64K00000 = 524400,
    HV_X64_REGISTER_MSR_MTRR_FIX16K80000 = 524401,
    HV_X64_REGISTER_MSR_MTRR_FIX16KA0000 = 524402,
    HV_X64_REGISTER_MSR_MTRR_FIX4KC0000 = 524403,
    HV_X64_REGISTER_MSR_MTRR_FIX4KC8000 = 524404,
    HV_X64_REGISTER_MSR_MTRR_FIX4KD0000 = 524405,
    HV_X64_REGISTER_MSR_MTRR_FIX4KD8000 = 524406,
    HV_X64_REGISTER_MSR_MTRR_FIX4KE0000 = 524407,
    HV_X64_REGISTER_MSR_MTRR_FIX4KE8000 = 524408,
    HV_X64_REGISTER_MSR_MTRR_FIX4KF0000 = 524409,
    HV_X64_REGISTER_MSR_MTRR_FIX4KF8000 = 524410,
    HV_X64_REGISTER_TSC_AUX = 524411,
    HV_X64_REGISTER_BNDCFGS = 524412,
    HV_X64_REGISTER_DEBUG_CTL = 524413,
    HV_X64_REGISTER_AVAILABLE0008007E = 524414,
    HV_X64_REGISTER_AVAILABLE0008007F = 524415,
    HV_X64_REGISTER_SGX_LAUNCH_CONTROL0 = 524416,
    HV_X64_REGISTER_SGX_LAUNCH_CONTROL1 = 524417,
    HV_X64_REGISTER_SGX_LAUNCH_CONTROL2 = 524418,
    HV_X64_REGISTER_SGX_LAUNCH_CONTROL3 = 524419,
    HV_X64_REGISTER_SPEC_CTRL = 524420,
    HV_X64_REGISTER_PRED_CMD = 524421,
    HV_X64_REGISTER_VIRT_SPEC_CTRL = 524422,
    HV_X64_REGISTER_TSC_ADJUST = 524438,
    HV_X64_REGISTER_MSR_IA32_MISC_ENABLE = 524448,
    HV_X64_REGISTER_IA32_FEATURE_CONTROL = 524449,
    HV_X64_REGISTER_IA32_VMX_BASIC = 524450,
    HV_X64_REGISTER_IA32_VMX_PINBASED_CTLS = 524451,
    HV_X64_REGISTER_IA32_VMX_PROCBASED_CTLS = 524452,
    HV_X64_REGISTER_IA32_VMX_EXIT_CTLS = 524453,
    HV_X64_REGISTER_IA32_VMX_ENTRY_CTLS = 524454,
    HV_X64_REGISTER_IA32_VMX_MISC = 524455,
    HV_X64_REGISTER_IA32_VMX_CR0_FIXED0 = 524456,
    HV_X64_REGISTER_IA32_VMX_CR0_FIXED1 = 524457,
    HV_X64_REGISTER_IA32_VMX_CR4_FIXED0 = 524458,
    HV_X64_REGISTER_IA32_VMX_CR4_FIXED1 = 524459,
    HV_X64_REGISTER_IA32_VMX_VMCS_ENUM = 524460,
    HV_X64_REGISTER_IA32_VMX_PROCBASED_CTLS2 = 524461,
    HV_X64_REGISTER_IA32_VMX_EPT_VPID_CAP = 524462,
    HV_X64_REGISTER_IA32_VMX_TRUE_PINBASED_CTLS = 524463,
    HV_X64_REGISTER_IA32_VMX_TRUE_PROCBASED_CTLS = 524464,
    HV_X64_REGISTER_IA32_VMX_TRUE_EXIT_CTLS = 524465,
    HV_X64_REGISTER_IA32_VMX_TRUE_ENTRY_CTLS = 524466,
    HV_X64_REGISTER_PERF_GLOBAL_CTRL = 528384,
    HV_X64_REGISTER_PERF_GLOBAL_STATUS = 528385,
    HV_X64_REGISTER_PERF_GLOBAL_IN_USE = 528386,
    HV_X64_REGISTER_FIXED_CTR_CTRL = 528387,
    HV_X64_REGISTER_DS_AREA = 528388,
    HV_X64_REGISTER_PEBS_ENABLE = 528389,
    HV_X64_REGISTER_PEBS_LD_LAT = 528390,
    HV_X64_REGISTER_PEBS_FRONTEND = 528391,
    HV_X64_REGISTER_PERF_EVT_SEL0 = 528640,
    HV_X64_REGISTER_PMC0 = 528896,
    HV_X64_REGISTER_FIXED_CTR0 = 529152,
    HV_X64_REGISTER_LBR_TOS = 532480,
    HV_X64_REGISTER_LBR_SELECT = 532481,
    HV_X64_REGISTER_LER_FROM_LIP = 532482,
    HV_X64_REGISTER_LER_TO_LIP = 532483,
    HV_X64_REGISTER_LBR_FROM0 = 532736,
    HV_X64_REGISTER_LBR_TO0 = 532992,
    HV_X64_REGISTER_LBR_INFO0 = 537344,
    HV_X64_REGISTER_RTIT_CTL = 528392,
    HV_X64_REGISTER_RTIT_STATUS = 528393,
    HV_X64_REGISTER_RTIT_OUTPUT_BASE = 528394,
    HV_X64_REGISTER_RTIT_OUTPUT_MASK_PTRS = 528395,
    HV_X64_REGISTER_RTIT_CR3_MATCH = 528396,
    HV_X64_REGISTER_RTIT_ADDR0A = 529408,
    HV_X64_REGISTER_APIC_ID = 542722,
    HV_X64_REGISTER_APIC_VERSION = 542723,
    HV_X64_REGISTER_HYPERCALL = 589825,
    HV_X64_REGISTER_SYNTHETIC_EOI = 589840,
    HV_X64_REGISTER_SYNTHETIC_ICR = 589841,
    HV_X64_REGISTER_SYNTHETIC_TPR = 589842,
    HV_X64_REGISTER_EMULATED_TIMER_PERIOD = 589872,
    HV_X64_REGISTER_EMULATED_TIMER_CONTROL = 589873,
    HV_X64_REGISTER_PM_TIMER_ASSIST = 589874,
    HV_X64_REGISTER_CR_INTERCEPT_CONTROL = 917504,
    HV_X64_REGISTER_CR_INTERCEPT_CR0_MASK = 917505,
    HV_X64_REGISTER_CR_INTERCEPT_CR4_MASK = 917506,
    HV_X64_REGISTER_CR_INTERCEPT_IA32_MISC_ENABLE_MASK = 917507,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_u128 {
    pub low_part: __u64,
    pub high_part: __u64,
}
#[test]
fn bindgen_test_layout_hv_u128() {
    assert_eq!(
        ::std::mem::size_of::<hv_u128>(),
        16usize,
        concat!("Size of: ", stringify!(hv_u128))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_u128>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_u128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_u128>())).high_part as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_u128),
            "::",
            stringify!(high_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_u128>())).low_part as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_u128),
            "::",
            stringify!(low_part)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_fp_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_fp_register__bindgen_ty_1 {
    pub mantissa: __u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_fp_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_register__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_fp_register__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_register__bindgen_ty_1>())).mantissa as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_register__bindgen_ty_1),
            "::",
            stringify!(mantissa)
        )
    );
}
impl hv_x64_fp_register__bindgen_ty_1 {
    #[inline]
    pub fn biased_exponent(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        biased_exponent: __u64,
        sign: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let biased_exponent: u64 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sign: u64 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_fp_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_fp_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_register>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_fp_register))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_fp_register>())).as_uint128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_register),
            "::",
            stringify!(as_uint128)
        )
    );
}
impl Default for hv_x64_fp_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_control_status_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_fp_control_status_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_fp_control_status_register__bindgen_ty_1 {
    pub fp_control: __u16,
    pub fp_status: __u16,
    pub fp_tag: __u8,
    pub reserved: __u8,
    pub last_fp_op: __u16,
    pub __bindgen_anon_1: hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_rip: __u64,
    pub __bindgen_anon_1:
        hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_eip: __u32,
    pub last_fp_cs: __u16,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .last_fp_eip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_eip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .last_fp_cs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .padding as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1>(
            )))
            .last_fp_rip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_rip)
        )
    );
}
impl Default for hv_x64_fp_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_control_status_register__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_control_status_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register__bindgen_ty_1>())).fp_control
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(fp_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register__bindgen_ty_1>())).fp_status
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(fp_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register__bindgen_ty_1>())).fp_tag
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(fp_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register__bindgen_ty_1>())).reserved
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register__bindgen_ty_1>())).last_fp_op
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register__bindgen_ty_1),
            "::",
            stringify!(last_fp_op)
        )
    );
}
impl Default for hv_x64_fp_control_status_register__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_fp_control_status_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_fp_control_status_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_fp_control_status_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_fp_control_status_register>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_fp_control_status_register)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_fp_control_status_register>())).as_uint128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_fp_control_status_register),
            "::",
            stringify!(as_uint128)
        )
    );
}
impl Default for hv_x64_fp_control_status_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_x64_xmm_control_status_register {
    pub as_uint128: hv_u128,
    pub __bindgen_anon_1: hv_x64_xmm_control_status_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_xmm_control_status_register__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1,
    pub xmm_status_control: __u32,
    pub xmm_status_control_mask: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_rdp: __u64,
    pub __bindgen_anon_1:
        hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub last_fp_dp: __u32,
    pub last_fp_ds: __u16,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .last_fp_dp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(last_fp_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .last_fp_ds as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(last_fp_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .padding as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1>(
            )))
            .last_fp_rdp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(last_fp_rdp)
        )
    );
}
impl Default for hv_x64_xmm_control_status_register__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xmm_control_status_register__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xmm_control_status_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xmm_control_status_register__bindgen_ty_1>()))
                .xmm_status_control as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1),
            "::",
            stringify!(xmm_status_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xmm_control_status_register__bindgen_ty_1>()))
                .xmm_status_control_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register__bindgen_ty_1),
            "::",
            stringify!(xmm_status_control_mask)
        )
    );
}
impl Default for hv_x64_xmm_control_status_register__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_xmm_control_status_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xmm_control_status_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_xmm_control_status_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xmm_control_status_register>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xmm_control_status_register)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xmm_control_status_register>())).as_uint128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xmm_control_status_register),
            "::",
            stringify!(as_uint128)
        )
    );
}
impl Default for hv_x64_xmm_control_status_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_segment_register {
    pub base: __u64,
    pub limit: __u32,
    pub selector: __u16,
    pub __bindgen_anon_1: hv_x64_segment_register__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_segment_register__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1,
    pub attributes: __u16,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl hv_x64_segment_register__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_type(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_segment_type(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn non_system_segment(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_non_system_segment(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn descriptor_privilege_level(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_descriptor_privilege_level(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn present(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_present(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn available(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_available(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _long(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__long(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _default(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__default(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn granularity(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_granularity(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_type: __u16,
        non_system_segment: __u16,
        descriptor_privilege_level: __u16,
        present: __u16,
        reserved: __u16,
        available: __u16,
        _long: __u16,
        _default: __u16,
        granularity: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let segment_type: u16 = unsafe { ::std::mem::transmute(segment_type) };
            segment_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let non_system_segment: u16 = unsafe { ::std::mem::transmute(non_system_segment) };
            non_system_segment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let descriptor_privilege_level: u16 =
                unsafe { ::std::mem::transmute(descriptor_privilege_level) };
            descriptor_privilege_level as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let present: u16 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let available: u16 = unsafe { ::std::mem::transmute(available) };
            available as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let _long: u16 = unsafe { ::std::mem::transmute(_long) };
            _long as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let _default: u16 = unsafe { ::std::mem::transmute(_default) };
            _default as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let granularity: u16 = unsafe { ::std::mem::transmute(granularity) };
            granularity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_segment_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_segment_register__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_segment_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_segment_register__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_segment_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_segment_register__bindgen_ty_1>())).attributes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register__bindgen_ty_1),
            "::",
            stringify!(attributes)
        )
    );
}
impl Default for hv_x64_segment_register__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_x64_segment_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_segment_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_segment_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_segment_register>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_segment_register))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_segment_register>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_segment_register>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_segment_register>())).selector as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_segment_register),
            "::",
            stringify!(selector)
        )
    );
}
impl Default for hv_x64_segment_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_table_register {
    pub pad: [__u16; 3usize],
    pub limit: __u16,
    pub base: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_table_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_table_register>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_table_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_table_register>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_table_register))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_table_register>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_table_register),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_table_register>())).limit as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_table_register),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_table_register>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_table_register),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_explicit_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_explicit_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_explicit_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_explicit_suspend_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_explicit_suspend_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_explicit_suspend_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_explicit_suspend_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_explicit_suspend_register__bindgen_ty_1)
        )
    );
}
impl hv_explicit_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_explicit_suspend_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_explicit_suspend_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_explicit_suspend_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_explicit_suspend_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_explicit_suspend_register))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_explicit_suspend_register>())).as_uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_explicit_suspend_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_explicit_suspend_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_intercept_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_intercept_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_intercept_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_intercept_suspend_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_intercept_suspend_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_intercept_suspend_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_intercept_suspend_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_intercept_suspend_register__bindgen_ty_1)
        )
    );
}
impl hv_intercept_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_intercept_suspend_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_intercept_suspend_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_intercept_suspend_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_intercept_suspend_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_intercept_suspend_register))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_intercept_suspend_register>())).as_uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_suspend_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_intercept_suspend_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_dispatch_suspend_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_dispatch_suspend_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_dispatch_suspend_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_dispatch_suspend_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_dispatch_suspend_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_dispatch_suspend_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_dispatch_suspend_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_dispatch_suspend_register__bindgen_ty_1)
        )
    );
}
impl hv_dispatch_suspend_register__bindgen_ty_1 {
    #[inline]
    pub fn suspended(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        suspended: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let suspended: u64 = unsafe { ::std::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_dispatch_suspend_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_dispatch_suspend_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_dispatch_suspend_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_dispatch_suspend_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_dispatch_suspend_register))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_dispatch_suspend_register>())).as_uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_dispatch_suspend_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_dispatch_suspend_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_interrupt_state_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_interrupt_state_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_interrupt_state_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_interrupt_state_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_interrupt_state_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_interrupt_state_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_interrupt_state_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_interrupt_state_register__bindgen_ty_1)
        )
    );
}
impl hv_x64_interrupt_state_register__bindgen_ty_1 {
    #[inline]
    pub fn interrupt_shadow(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_interrupt_shadow(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nmi_masked(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_nmi_masked(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt_shadow: __u64,
        nmi_masked: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt_shadow: u64 = unsafe { ::std::mem::transmute(interrupt_shadow) };
            interrupt_shadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nmi_masked: u64 = unsafe { ::std::mem::transmute(nmi_masked) };
            nmi_masked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_interrupt_state_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_interrupt_state_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_interrupt_state_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_interrupt_state_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_interrupt_state_register))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_interrupt_state_register>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interrupt_state_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_interrupt_state_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_pending_interruption_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_pending_interruption_register__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_pending_interruption_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub error_code: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_pending_interruption_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_interruption_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_interruption_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_interruption_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_interruption_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_interruption_register__bindgen_ty_1>()))
                .error_code as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_interruption_register__bindgen_ty_1),
            "::",
            stringify!(error_code)
        )
    );
}
impl hv_x64_pending_interruption_register__bindgen_ty_1 {
    #[inline]
    pub fn interruption_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interruption_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interruption_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_interruption_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn deliver_error_code(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deliver_error_code(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instruction_length(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_instruction_length(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nested_event(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nested_event(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn interruption_vector(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_interruption_vector(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interruption_pending: __u32,
        interruption_type: __u32,
        deliver_error_code: __u32,
        instruction_length: __u32,
        nested_event: __u32,
        reserved: __u32,
        interruption_vector: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interruption_pending: u32 = unsafe { ::std::mem::transmute(interruption_pending) };
            interruption_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let interruption_type: u32 = unsafe { ::std::mem::transmute(interruption_type) };
            interruption_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let deliver_error_code: u32 = unsafe { ::std::mem::transmute(deliver_error_code) };
            deliver_error_code as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let instruction_length: u32 = unsafe { ::std::mem::transmute(instruction_length) };
            instruction_length as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let nested_event: u32 = unsafe { ::std::mem::transmute(nested_event) };
            nested_event as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let interruption_vector: u32 = unsafe { ::std::mem::transmute(interruption_vector) };
            interruption_vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_pending_interruption_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_interruption_register>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_interruption_register)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_interruption_register>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_interruption_register)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_interruption_register>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_interruption_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_pending_interruption_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_msr_npiep_config_contents {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_msr_npiep_config_contents__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_msr_npiep_config_contents__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_msr_npiep_config_contents__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_npiep_config_contents__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_msr_npiep_config_contents__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_npiep_config_contents__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_msr_npiep_config_contents__bindgen_ty_1)
        )
    );
}
impl hv_x64_msr_npiep_config_contents__bindgen_ty_1 {
    #[inline]
    pub fn prevents_gdt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_gdt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevents_idt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_idt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevents_ldt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_ldt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevents_tr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_prevents_tr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prevents_gdt: __u64,
        prevents_idt: __u64,
        prevents_ldt: __u64,
        prevents_tr: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let prevents_gdt: u64 = unsafe { ::std::mem::transmute(prevents_gdt) };
            prevents_gdt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prevents_idt: u64 = unsafe { ::std::mem::transmute(prevents_idt) };
            prevents_idt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let prevents_ldt: u64 = unsafe { ::std::mem::transmute(prevents_ldt) };
            prevents_ldt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let prevents_tr: u64 = unsafe { ::std::mem::transmute(prevents_tr) };
            prevents_tr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_msr_npiep_config_contents() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_npiep_config_contents>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_msr_npiep_config_contents))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_npiep_config_contents>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_msr_npiep_config_contents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_msr_npiep_config_contents>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_npiep_config_contents),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_msr_npiep_config_contents {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_pending_exception_event {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_x64_pending_exception_event__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_pending_exception_event__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub error_code: __u32,
    pub exception_parameter: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_pending_exception_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_exception_event__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_exception_event__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_exception_event__bindgen_ty_1>())).error_code
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_exception_event__bindgen_ty_1>()))
                .exception_parameter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_exception_event__bindgen_ty_1),
            "::",
            stringify!(exception_parameter)
        )
    );
}
impl hv_x64_pending_exception_event__bindgen_ty_1 {
    #[inline]
    pub fn event_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_event_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn event_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn deliver_error_code(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deliver_error_code(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn vector(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        event_pending: __u32,
        event_type: __u32,
        reserved0: __u32,
        deliver_error_code: __u32,
        reserved1: __u32,
        vector: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let event_pending: u32 = unsafe { ::std::mem::transmute(event_pending) };
            event_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let event_type: u32 = unsafe { ::std::mem::transmute(event_type) };
            event_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let deliver_error_code: u32 = unsafe { ::std::mem::transmute(deliver_error_code) };
            deliver_error_code as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_pending_exception_event() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_exception_event>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_pending_exception_event))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_exception_event>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_pending_exception_event))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_exception_event>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_exception_event),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_pending_exception_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_pending_virtualization_fault_event {
    pub as_uint64: [__u64; 2usize],
    pub __bindgen_anon_1: hv_x64_pending_virtualization_fault_event__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_pending_virtualization_fault_event__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub code: __u32,
    pub parameter1: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_pending_virtualization_fault_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_virtualization_fault_event__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_virtualization_fault_event__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_virtualization_fault_event__bindgen_ty_1>())).code
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_virtualization_fault_event__bindgen_ty_1>()))
                .parameter1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_virtualization_fault_event__bindgen_ty_1),
            "::",
            stringify!(parameter1)
        )
    );
}
impl hv_x64_pending_virtualization_fault_event__bindgen_ty_1 {
    #[inline]
    pub fn event_pending(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_event_pending(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn event_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn parameter0(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_parameter0(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        event_pending: __u32,
        event_type: __u32,
        reserved0: __u32,
        reserved1: __u32,
        parameter0: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let event_pending: u32 = unsafe { ::std::mem::transmute(event_pending) };
            event_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let event_type: u32 = unsafe { ::std::mem::transmute(event_type) };
            event_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let parameter0: u32 = unsafe { ::std::mem::transmute(parameter0) };
            parameter0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_pending_virtualization_fault_event() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_pending_virtualization_fault_event>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_pending_virtualization_fault_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_pending_virtualization_fault_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_pending_virtualization_fault_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_pending_virtualization_fault_event>())).as_uint64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_pending_virtualization_fault_event),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_pending_virtualization_fault_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_register_value {
    pub reg128: hv_u128,
    pub reg64: __u64,
    pub reg32: __u32,
    pub reg16: __u16,
    pub reg8: __u8,
    pub fp: hv_x64_fp_register,
    pub fp_control_status: hv_x64_fp_control_status_register,
    pub xmm_control_status: hv_x64_xmm_control_status_register,
    pub segment: hv_x64_segment_register,
    pub table: hv_x64_table_register,
    pub explicit_suspend: hv_explicit_suspend_register,
    pub intercept_suspend: hv_intercept_suspend_register,
    pub dispatch_suspend: hv_dispatch_suspend_register,
    pub interrupt_state: hv_x64_interrupt_state_register,
    pub pending_interruption: hv_x64_pending_interruption_register,
    pub npiep_config: hv_x64_msr_npiep_config_contents,
    pub pending_exception_event: hv_x64_pending_exception_event,
    pub pending_virtualization_fault_event: hv_x64_pending_virtualization_fault_event,
}
#[test]
fn bindgen_test_layout_hv_register_value() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_value>(),
        16usize,
        concat!("Size of: ", stringify!(hv_register_value))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_value>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_register_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).reg128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg128)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).reg64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).reg32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).reg16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).reg8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(reg8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).fp_control_status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(fp_control_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).xmm_control_status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(xmm_control_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).explicit_suspend as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(explicit_suspend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).intercept_suspend as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(intercept_suspend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).dispatch_suspend as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(dispatch_suspend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).interrupt_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(interrupt_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).pending_interruption as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(pending_interruption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_value>())).npiep_config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(npiep_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).pending_exception_event as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(pending_exception_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_value>())).pending_virtualization_fault_event
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_value),
            "::",
            stringify!(pending_virtualization_fault_event)
        )
    );
}
impl Default for hv_register_value {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_vp_execution_state {
    pub as_uint16: __u16,
    pub __bindgen_anon_1: hv_x64_vp_execution_state__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_vp_execution_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_vp_execution_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vp_execution_state__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_vp_execution_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vp_execution_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_vp_execution_state__bindgen_ty_1)
        )
    );
}
impl hv_x64_vp_execution_state__bindgen_ty_1 {
    #[inline]
    pub fn cpl(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cpl(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cr0_pe(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cr0_pe(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cr0_am(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cr0_am(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn efer_lma(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_efer_lma(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_active(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_debug_active(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interruption_pending(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_interruption_pending(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vtl(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_vtl(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enclave_mode(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enclave_mode(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interrupt_shadow(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_interrupt_shadow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virtualization_fault_active(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_virtualization_fault_active(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpl: __u16,
        cr0_pe: __u16,
        cr0_am: __u16,
        efer_lma: __u16,
        debug_active: __u16,
        interruption_pending: __u16,
        vtl: __u16,
        enclave_mode: __u16,
        interrupt_shadow: __u16,
        virtualization_fault_active: __u16,
        reserved: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cpl: u16 = unsafe { ::std::mem::transmute(cpl) };
            cpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cr0_pe: u16 = unsafe { ::std::mem::transmute(cr0_pe) };
            cr0_pe as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cr0_am: u16 = unsafe { ::std::mem::transmute(cr0_am) };
            cr0_am as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let efer_lma: u16 = unsafe { ::std::mem::transmute(efer_lma) };
            efer_lma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let debug_active: u16 = unsafe { ::std::mem::transmute(debug_active) };
            debug_active as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let interruption_pending: u16 = unsafe { ::std::mem::transmute(interruption_pending) };
            interruption_pending as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let vtl: u16 = unsafe { ::std::mem::transmute(vtl) };
            vtl as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enclave_mode: u16 = unsafe { ::std::mem::transmute(enclave_mode) };
            enclave_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let interrupt_shadow: u16 = unsafe { ::std::mem::transmute(interrupt_shadow) };
            interrupt_shadow as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let virtualization_fault_active: u16 =
                unsafe { ::std::mem::transmute(virtualization_fault_active) };
            virtualization_fault_active as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_vp_execution_state() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_vp_execution_state>(),
        2usize,
        concat!("Size of: ", stringify!(hv_x64_vp_execution_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_vp_execution_state>(),
        2usize,
        concat!("Alignment of ", stringify!(hv_x64_vp_execution_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_vp_execution_state>())).as_uint16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_vp_execution_state),
            "::",
            stringify!(as_uint16)
        )
    );
}
impl Default for hv_x64_vp_execution_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_intercept_message_header {
    pub vp_index: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub intercept_access_type: __u8,
    pub execution_state: hv_x64_vp_execution_state,
    pub cs_segment: hv_x64_segment_register,
    pub rip: __u64,
    pub rflags: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_intercept_message_header() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_intercept_message_header>(),
        40usize,
        concat!("Size of: ", stringify!(hv_x64_intercept_message_header))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_intercept_message_header>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_intercept_message_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_intercept_message_header>())).vp_index as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_intercept_message_header>())).intercept_access_type
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(intercept_access_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_intercept_message_header>())).execution_state as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(execution_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_intercept_message_header>())).cs_segment as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(cs_segment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_intercept_message_header>())).rip as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_intercept_message_header>())).rflags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_intercept_message_header),
            "::",
            stringify!(rflags)
        )
    );
}
impl Default for hv_x64_intercept_message_header {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl hv_x64_intercept_message_header {
    #[inline]
    pub fn instruction_length(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_instruction_length(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cr8(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_cr8(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        instruction_length: __u8,
        cr8: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let instruction_length: u8 = unsafe { ::std::mem::transmute(instruction_length) };
            instruction_length as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let cr8: u8 = unsafe { ::std::mem::transmute(cr8) };
            cr8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_hypercall_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub rax: __u64,
    pub rbx: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub r8: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub xmmregisters: [hv_u128; 6usize],
    pub __bindgen_anon_1: hv_x64_hypercall_intercept_message__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_hypercall_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_hypercall_intercept_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_hypercall_intercept_message__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_hypercall_intercept_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_hypercall_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_hypercall_intercept_message__bindgen_ty_1)
        )
    );
}
impl hv_x64_hypercall_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn isolated(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isolated(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isolated: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isolated: u32 = unsafe { ::std::mem::transmute(isolated) };
            isolated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_hypercall_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_hypercall_intercept_message>(),
        196usize,
        concat!("Size of: ", stringify!(hv_x64_hypercall_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_hypercall_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_hypercall_intercept_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).rax as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).rbx as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).rcx as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).rdx as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).r8 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).rsi as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).rdi as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_hypercall_intercept_message>())).xmmregisters as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_hypercall_intercept_message),
            "::",
            stringify!(xmmregisters)
        )
    );
}
impl Default for hv_x64_hypercall_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_register_access_info {
    pub source_value: hv_register_value,
    pub destination_register: __u32,
    pub source_address: __u64,
    pub destination_address: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_register_access_info() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_access_info>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_register_access_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_access_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_register_access_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_access_info>())).source_value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(source_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_access_info>())).destination_register as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(destination_register)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_access_info>())).source_address as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_access_info>())).destination_address as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_access_info),
            "::",
            stringify!(destination_address)
        )
    );
}
impl Default for hv_x64_register_access_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_register_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub __bindgen_anon_1: hv_x64_register_intercept_message__bindgen_ty_1,
    pub reserved8: __u8,
    pub reserved16: __u16,
    pub register_name: __u32,
    pub access_info: hv_x64_register_access_info,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_register_intercept_message__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_register_intercept_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_register_intercept_message__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_intercept_message__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_intercept_message__bindgen_ty_1)
        )
    );
}
impl hv_x64_register_intercept_message__bindgen_ty_1 {
    #[inline]
    pub fn is_memory_op(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_memory_op(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_memory_op: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_memory_op: u8 = unsafe { ::std::mem::transmute(is_memory_op) };
            is_memory_op as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_register_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_register_intercept_message>(),
        64usize,
        concat!("Size of: ", stringify!(hv_x64_register_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_register_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_register_intercept_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_intercept_message>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_intercept_message>())).reserved8 as *const _
                as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(reserved8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_intercept_message>())).reserved16 as *const _
                as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(reserved16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_intercept_message>())).register_name as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(register_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_register_intercept_message>())).access_info as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_register_intercept_message),
            "::",
            stringify!(access_info)
        )
    );
}
impl Default for hv_x64_register_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_memory_access_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_x64_memory_access_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_memory_access_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_memory_access_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_memory_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_memory_access_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_memory_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_memory_access_info__bindgen_ty_1)
        )
    );
}
impl hv_x64_memory_access_info__bindgen_ty_1 {
    #[inline]
    pub fn gva_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gva_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gva_gpa_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gva_gpa_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hypercall_output_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hypercall_output_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tlb_locked_no_overlay(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tlb_locked_no_overlay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gva_valid: __u8,
        gva_gpa_valid: __u8,
        hypercall_output_pending: __u8,
        tlb_locked_no_overlay: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gva_valid: u8 = unsafe { ::std::mem::transmute(gva_valid) };
            gva_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gva_gpa_valid: u8 = unsafe { ::std::mem::transmute(gva_gpa_valid) };
            gva_gpa_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hypercall_output_pending: u8 =
                unsafe { ::std::mem::transmute(hypercall_output_pending) };
            hypercall_output_pending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tlb_locked_no_overlay: u8 = unsafe { ::std::mem::transmute(tlb_locked_no_overlay) };
            tlb_locked_no_overlay as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_memory_access_info() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_memory_access_info>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_memory_access_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_memory_access_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_memory_access_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_access_info>())).as_uint8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_access_info),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_x64_memory_access_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_io_port_access_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_x64_io_port_access_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_io_port_access_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_io_port_access_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_io_port_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_io_port_access_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_io_port_access_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_io_port_access_info__bindgen_ty_1)
        )
    );
}
impl hv_x64_io_port_access_info__bindgen_ty_1 {
    #[inline]
    pub fn access_size(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_access_size(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn string_op(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_string_op(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rep_prefix(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rep_prefix(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        access_size: __u8,
        string_op: __u8,
        rep_prefix: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let access_size: u8 = unsafe { ::std::mem::transmute(access_size) };
            access_size as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let string_op: u8 = unsafe { ::std::mem::transmute(string_op) };
            string_op as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rep_prefix: u8 = unsafe { ::std::mem::transmute(rep_prefix) };
            rep_prefix as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_io_port_access_info() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_io_port_access_info>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_io_port_access_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_io_port_access_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_io_port_access_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_access_info>())).as_uint8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_access_info),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_x64_io_port_access_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_exception_info {
    pub as_uint8: __u8,
    pub __bindgen_anon_1: hv_x64_exception_info__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_exception_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_exception_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_exception_info__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_exception_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_exception_info__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_exception_info__bindgen_ty_1)
        )
    );
}
impl hv_x64_exception_info__bindgen_ty_1 {
    #[inline]
    pub fn error_code_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_error_code_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn software_exception(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_software_exception(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        error_code_valid: __u8,
        software_exception: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let error_code_valid: u8 = unsafe { ::std::mem::transmute(error_code_valid) };
            error_code_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let software_exception: u8 = unsafe { ::std::mem::transmute(software_exception) };
            software_exception as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_exception_info() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_exception_info>(),
        1usize,
        concat!("Size of: ", stringify!(hv_x64_exception_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_exception_info>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_exception_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_exception_info>())).as_uint8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_info),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_x64_exception_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_memory_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub cache_type: __u32,
    pub instruction_byte_count: __u8,
    pub memory_access_info: hv_x64_memory_access_info,
    pub tpr_priority: __u8,
    pub reserved1: __u8,
    pub guest_virtual_address: __u64,
    pub guest_physical_address: __u64,
    pub instruction_bytes: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_hv_x64_memory_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_memory_intercept_message>(),
        80usize,
        concat!("Size of: ", stringify!(hv_x64_memory_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_memory_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_memory_intercept_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).cache_type as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(cache_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).instruction_byte_count
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(instruction_byte_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).memory_access_info
                as *const _ as usize
        },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(memory_access_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).tpr_priority as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(tpr_priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).reserved1 as *const _
                as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).guest_virtual_address
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(guest_virtual_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).guest_physical_address
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(guest_physical_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_memory_intercept_message>())).instruction_bytes
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_memory_intercept_message),
            "::",
            stringify!(instruction_bytes)
        )
    );
}
impl Default for hv_x64_memory_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_cpuid_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub rax: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rbx: __u64,
    pub default_result_rax: __u64,
    pub default_result_rcx: __u64,
    pub default_result_rdx: __u64,
    pub default_result_rbx: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_cpuid_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_cpuid_intercept_message>(),
        104usize,
        concat!("Size of: ", stringify!(hv_x64_cpuid_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_cpuid_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_cpuid_intercept_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).rax as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).rcx as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).rdx as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).rbx as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).default_result_rax
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).default_result_rcx
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).default_result_rdx
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_cpuid_intercept_message>())).default_result_rbx
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_cpuid_intercept_message),
            "::",
            stringify!(default_result_rbx)
        )
    );
}
impl Default for hv_x64_cpuid_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_msr_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub msr_number: __u32,
    pub reserved: __u32,
    pub rdx: __u64,
    pub rax: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_msr_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_msr_intercept_message>(),
        64usize,
        concat!("Size of: ", stringify!(hv_x64_msr_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_msr_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_msr_intercept_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_msr_intercept_message>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_msr_intercept_message>())).msr_number as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(msr_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_msr_intercept_message>())).reserved as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_msr_intercept_message>())).rdx as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_msr_intercept_message>())).rax as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_msr_intercept_message),
            "::",
            stringify!(rax)
        )
    );
}
impl Default for hv_x64_msr_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_io_port_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub port_number: __u16,
    pub access_info: hv_x64_io_port_access_info,
    pub instruction_byte_count: __u8,
    pub reserved: __u32,
    pub rax: __u64,
    pub instruction_bytes: [__u8; 16usize],
    pub ds_segment: hv_x64_segment_register,
    pub es_segment: hv_x64_segment_register,
    pub rcx: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_io_port_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_io_port_intercept_message>(),
        128usize,
        concat!("Size of: ", stringify!(hv_x64_io_port_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_io_port_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_io_port_intercept_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).port_number as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(port_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).access_info as *const _
                as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(access_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).instruction_byte_count
                as *const _ as usize
        },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(instruction_byte_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).reserved as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).rax as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).instruction_bytes
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(instruction_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).ds_segment as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(ds_segment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).es_segment as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(es_segment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).rcx as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).rsi as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_io_port_intercept_message>())).rdi as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_io_port_intercept_message),
            "::",
            stringify!(rdi)
        )
    );
}
impl Default for hv_x64_io_port_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_exception_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub exception_vector: __u16,
    pub exception_info: hv_x64_exception_info,
    pub instruction_byte_count: __u8,
    pub error_code: __u32,
    pub exception_parameter: __u64,
    pub reserved: __u64,
    pub instruction_bytes: [__u8; 16usize],
    pub ds_segment: hv_x64_segment_register,
    pub ss_segment: hv_x64_segment_register,
    pub rax: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rbx: __u64,
    pub rsp: __u64,
    pub rbp: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_exception_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_exception_intercept_message>(),
        240usize,
        concat!("Size of: ", stringify!(hv_x64_exception_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_exception_intercept_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_exception_intercept_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).exception_vector
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(exception_vector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).exception_info
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(exception_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).instruction_byte_count
                as *const _ as usize
        },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(instruction_byte_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).error_code as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).exception_parameter
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(exception_parameter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).reserved as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).instruction_bytes
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(instruction_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).ds_segment as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(ds_segment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).ss_segment as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(ss_segment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rax as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rcx as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rdx as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rbx as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rsp as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rbp as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rsi as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).rdi as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r8 as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r9 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r10 as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r11 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r12 as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r13 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r14 as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_exception_intercept_message>())).r15 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_exception_intercept_message),
            "::",
            stringify!(r15)
        )
    );
}
impl Default for hv_x64_exception_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_invalid_vp_register_message {
    pub vp_index: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_invalid_vp_register_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_invalid_vp_register_message>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_invalid_vp_register_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_invalid_vp_register_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_invalid_vp_register_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_invalid_vp_register_message>())).vp_index as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_invalid_vp_register_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_invalid_vp_register_message>())).reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_invalid_vp_register_message),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_unrecoverable_exception_message {
    pub header: hv_x64_intercept_message_header,
}
#[test]
fn bindgen_test_layout_hv_x64_unrecoverable_exception_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_unrecoverable_exception_message>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_unrecoverable_exception_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_unrecoverable_exception_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_unrecoverable_exception_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_unrecoverable_exception_message>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unrecoverable_exception_message),
            "::",
            stringify!(header)
        )
    );
}
impl Default for hv_x64_unrecoverable_exception_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_unsupported_feature_message {
    pub vp_index: __u32,
    pub feature_code: __u32,
    pub feature_parameter: __u64,
}
#[test]
fn bindgen_test_layout_hv_x64_unsupported_feature_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_unsupported_feature_message>(),
        16usize,
        concat!("Size of: ", stringify!(hv_x64_unsupported_feature_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_unsupported_feature_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_unsupported_feature_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_unsupported_feature_message>())).vp_index as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unsupported_feature_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_unsupported_feature_message>())).feature_code as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unsupported_feature_message),
            "::",
            stringify!(feature_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_unsupported_feature_message>())).feature_parameter
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_unsupported_feature_message),
            "::",
            stringify!(feature_parameter)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_halt_message {
    pub header: hv_x64_intercept_message_header,
}
#[test]
fn bindgen_test_layout_hv_x64_halt_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_halt_message>(),
        40usize,
        concat!("Size of: ", stringify!(hv_x64_halt_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_halt_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_halt_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_x64_halt_message>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_halt_message),
            "::",
            stringify!(header)
        )
    );
}
impl Default for hv_x64_halt_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_interruption_deliverable_message {
    pub header: hv_x64_intercept_message_header,
    pub deliverable_type: __u32,
    pub rsvd: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_interruption_deliverable_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_interruption_deliverable_message>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_interruption_deliverable_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_interruption_deliverable_message>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_interruption_deliverable_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_interruption_deliverable_message>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interruption_deliverable_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_interruption_deliverable_message>())).deliverable_type
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interruption_deliverable_message),
            "::",
            stringify!(deliverable_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_interruption_deliverable_message>())).rsvd as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_interruption_deliverable_message),
            "::",
            stringify!(rsvd)
        )
    );
}
impl Default for hv_x64_interruption_deliverable_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_x64_sipi_intercept_message {
    pub header: hv_x64_intercept_message_header,
    pub target_vp_index: __u32,
    pub interrupt_vector: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_sipi_intercept_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_sipi_intercept_message>(),
        48usize,
        concat!("Size of: ", stringify!(hv_x64_sipi_intercept_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_sipi_intercept_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_sipi_intercept_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_sipi_intercept_message>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sipi_intercept_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_sipi_intercept_message>())).target_vp_index as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sipi_intercept_message),
            "::",
            stringify!(target_vp_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_sipi_intercept_message>())).interrupt_vector as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_sipi_intercept_message),
            "::",
            stringify!(interrupt_vector)
        )
    );
}
impl Default for hv_x64_sipi_intercept_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_apic_eoi_message {
    pub vp_index: __u32,
    pub interrupt_vector: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_apic_eoi_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_apic_eoi_message>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_apic_eoi_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_apic_eoi_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_x64_apic_eoi_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_apic_eoi_message>())).vp_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_apic_eoi_message),
            "::",
            stringify!(vp_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_apic_eoi_message>())).interrupt_vector as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_apic_eoi_message),
            "::",
            stringify!(interrupt_vector)
        )
    );
}
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_IO_PORT: hv_intercept_type = 0;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_MSR: hv_intercept_type = 1;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_CPUID: hv_intercept_type = 2;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_EXCEPTION: hv_intercept_type = 3;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_REGISTER: hv_intercept_type = 4;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_MMIO: hv_intercept_type = 5;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_GLOBAL_CPUID: hv_intercept_type = 6;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_APIC_SMI: hv_intercept_type = 7;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_HYPERCALL: hv_intercept_type = 8;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_APIC_INIT_SIPI: hv_intercept_type = 9;
pub const hv_intercept_type_HV_INTERCEPT_MC_UPDATE_PATCH_LEVEL_MSR_READ: hv_intercept_type = 10;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_X64_APIC_WRITE: hv_intercept_type = 11;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_MAX: hv_intercept_type = 12;
pub const hv_intercept_type_HV_INTERCEPT_TYPE_INVALID: hv_intercept_type = 4294967295;
pub type hv_intercept_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_intercept_parameters {
    pub as_uint64: __u64,
    pub io_port: __u16,
    pub cpuid_index: __u32,
    pub apic_write_mask: __u32,
    pub exception_vector: __u16,
}
#[test]
fn bindgen_test_layout_hv_intercept_parameters() {
    assert_eq!(
        ::std::mem::size_of::<hv_intercept_parameters>(),
        8usize,
        concat!("Size of: ", stringify!(hv_intercept_parameters))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_intercept_parameters>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_intercept_parameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_intercept_parameters>())).as_uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(as_uint64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_intercept_parameters>())).io_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(io_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_intercept_parameters>())).cpuid_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(cpuid_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_intercept_parameters>())).apic_write_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(apic_write_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_intercept_parameters>())).exception_vector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_intercept_parameters),
            "::",
            stringify!(exception_vector)
        )
    );
}
impl Default for hv_intercept_parameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_FIXED: hv_interrupt_type = 0;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_LOWESTPRIORITY: hv_interrupt_type = 1;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_SMI: hv_interrupt_type = 2;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_REMOTEREAD: hv_interrupt_type = 3;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_NMI: hv_interrupt_type = 4;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_INIT: hv_interrupt_type = 5;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_SIPI: hv_interrupt_type = 6;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_EXTINT: hv_interrupt_type = 7;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_LOCALINT0: hv_interrupt_type = 8;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_LOCALINT1: hv_interrupt_type = 9;
pub const hv_interrupt_type_HV_X64_INTERRUPT_TYPE_MAXIMUM: hv_interrupt_type = 10;
pub type hv_interrupt_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_interrupt_control {
    pub __bindgen_anon_1: hv_interrupt_control__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_interrupt_control__bindgen_ty_1 {
    pub interrupt_type: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_interrupt_control__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_interrupt_control__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_interrupt_control__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_interrupt_control__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_interrupt_control__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_interrupt_control__bindgen_ty_1>())).interrupt_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_interrupt_control__bindgen_ty_1),
            "::",
            stringify!(interrupt_type)
        )
    );
}
impl hv_interrupt_control__bindgen_ty_1 {
    #[inline]
    pub fn level_triggered(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_triggered(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn logical_dest_mode(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest_mode(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        level_triggered: __u32,
        logical_dest_mode: __u32,
        rsvd: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let level_triggered: u32 = unsafe { ::std::mem::transmute(level_triggered) };
            level_triggered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let logical_dest_mode: u32 = unsafe { ::std::mem::transmute(logical_dest_mode) };
            logical_dest_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let rsvd: u32 = unsafe { ::std::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_interrupt_control() {
    assert_eq!(
        ::std::mem::size_of::<hv_interrupt_control>(),
        8usize,
        concat!("Size of: ", stringify!(hv_interrupt_control))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_interrupt_control>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_interrupt_control))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_interrupt_control>())).as_uint64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_interrupt_control),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_interrupt_control {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_local_interrupt_controller_state {
    pub apic_id: __u32,
    pub apic_version: __u32,
    pub apic_ldr: __u32,
    pub apic_dfr: __u32,
    pub apic_spurious: __u32,
    pub apic_isr: [__u32; 8usize],
    pub apic_tmr: [__u32; 8usize],
    pub apic_irr: [__u32; 8usize],
    pub apic_esr: __u32,
    pub apic_icr_high: __u32,
    pub apic_icr_low: __u32,
    pub apic_lvt_timer: __u32,
    pub apic_lvt_thermal: __u32,
    pub apic_lvt_perfmon: __u32,
    pub apic_lvt_lint0: __u32,
    pub apic_lvt_lint1: __u32,
    pub apic_lvt_error: __u32,
    pub apic_lvt_cmci: __u32,
    pub apic_error_status: __u32,
    pub apic_initial_count: __u32,
    pub apic_counter_value: __u32,
    pub apic_divide_configuration: __u32,
    pub apic_remote_read: __u32,
}
#[test]
fn bindgen_test_layout_hv_local_interrupt_controller_state() {
    assert_eq!(
        ::std::mem::size_of::<hv_local_interrupt_controller_state>(),
        176usize,
        concat!("Size of: ", stringify!(hv_local_interrupt_controller_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_local_interrupt_controller_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_local_interrupt_controller_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_ldr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_ldr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_dfr as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_dfr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_spurious
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_spurious)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_isr as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_isr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_tmr as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_tmr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_irr as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_irr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_esr as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_esr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_icr_high
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_icr_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_icr_low as *const _
                as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_icr_low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_timer
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_thermal
                as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_thermal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_perfmon
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_perfmon)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_lint0
                as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_lint0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_lint1
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_lint1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_error
                as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_lvt_cmci
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_lvt_cmci)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_error_status
                as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_error_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_initial_count
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_initial_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_counter_value
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_counter_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>()))
                .apic_divide_configuration as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_divide_configuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_local_interrupt_controller_state>())).apic_remote_read
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_local_interrupt_controller_state),
            "::",
            stringify!(apic_remote_read)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_x64_xsave_xfem_register {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_x64_xsave_xfem_register__bindgen_ty_1,
    pub __bindgen_anon_2: hv_x64_xsave_xfem_register__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_xsave_xfem_register__bindgen_ty_1 {
    pub low_uint32: __u32,
    pub high_uint32: __u32,
}
#[test]
fn bindgen_test_layout_hv_x64_xsave_xfem_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xsave_xfem_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xsave_xfem_register__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xsave_xfem_register__bindgen_ty_1>())).low_uint32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1),
            "::",
            stringify!(low_uint32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xsave_xfem_register__bindgen_ty_1>())).high_uint32
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_1),
            "::",
            stringify!(high_uint32)
        )
    );
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_x64_xsave_xfem_register__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_x64_xsave_xfem_register__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xsave_xfem_register__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xsave_xfem_register__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_x64_xsave_xfem_register__bindgen_ty_2)
        )
    );
}
impl hv_x64_xsave_xfem_register__bindgen_ty_2 {
    #[inline]
    pub fn legacy_x87(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_legacy_x87(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn legacy_sse(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_legacy_sse(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpx_bndreg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_bndreg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpx_bndcsr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mpx_bndcsr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_512_op_mask(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_op_mask(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_512_zmmhi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_zmmhi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avx_512_zmm16_31(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_avx_512_zmm16_31(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd8_9(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd8_9(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pasid(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pasid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_u(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_u(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cet_s(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cet_s(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd13_16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd13_16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn xtile_cfg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xtile_cfg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtile_data(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_xtile_data(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd19_63(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 45u8) as u64) }
    }
    #[inline]
    pub fn set_rsvd19_63(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 45u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        legacy_x87: __u64,
        legacy_sse: __u64,
        avx: __u64,
        mpx_bndreg: __u64,
        mpx_bndcsr: __u64,
        avx_512_op_mask: __u64,
        avx_512_zmmhi: __u64,
        avx_512_zmm16_31: __u64,
        rsvd8_9: __u64,
        pasid: __u64,
        cet_u: __u64,
        cet_s: __u64,
        rsvd13_16: __u64,
        xtile_cfg: __u64,
        xtile_data: __u64,
        rsvd19_63: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let legacy_x87: u64 = unsafe { ::std::mem::transmute(legacy_x87) };
            legacy_x87 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let legacy_sse: u64 = unsafe { ::std::mem::transmute(legacy_sse) };
            legacy_sse as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let avx: u64 = unsafe { ::std::mem::transmute(avx) };
            avx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mpx_bndreg: u64 = unsafe { ::std::mem::transmute(mpx_bndreg) };
            mpx_bndreg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mpx_bndcsr: u64 = unsafe { ::std::mem::transmute(mpx_bndcsr) };
            mpx_bndcsr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let avx_512_op_mask: u64 = unsafe { ::std::mem::transmute(avx_512_op_mask) };
            avx_512_op_mask as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let avx_512_zmmhi: u64 = unsafe { ::std::mem::transmute(avx_512_zmmhi) };
            avx_512_zmmhi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let avx_512_zmm16_31: u64 = unsafe { ::std::mem::transmute(avx_512_zmm16_31) };
            avx_512_zmm16_31 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let rsvd8_9: u64 = unsafe { ::std::mem::transmute(rsvd8_9) };
            rsvd8_9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let pasid: u64 = unsafe { ::std::mem::transmute(pasid) };
            pasid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cet_u: u64 = unsafe { ::std::mem::transmute(cet_u) };
            cet_u as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cet_s: u64 = unsafe { ::std::mem::transmute(cet_s) };
            cet_s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 4u8, {
            let rsvd13_16: u64 = unsafe { ::std::mem::transmute(rsvd13_16) };
            rsvd13_16 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let xtile_cfg: u64 = unsafe { ::std::mem::transmute(xtile_cfg) };
            xtile_cfg as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xtile_data: u64 = unsafe { ::std::mem::transmute(xtile_data) };
            xtile_data as u64
        });
        __bindgen_bitfield_unit.set(19usize, 45u8, {
            let rsvd19_63: u64 = unsafe { ::std::mem::transmute(rsvd19_63) };
            rsvd19_63 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_x64_xsave_xfem_register() {
    assert_eq!(
        ::std::mem::size_of::<hv_x64_xsave_xfem_register>(),
        8usize,
        concat!("Size of: ", stringify!(hv_x64_xsave_xfem_register))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_x64_xsave_xfem_register>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_x64_xsave_xfem_register))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_x64_xsave_xfem_register>())).as_uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_x64_xsave_xfem_register),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_x64_xsave_xfem_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_state_data_xsave {
    pub flags: __u64,
    pub states: hv_x64_xsave_xfem_register,
}
#[test]
fn bindgen_test_layout_hv_vp_state_data_xsave() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_state_data_xsave>(),
        16usize,
        concat!("Size of: ", stringify!(hv_vp_state_data_xsave))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_state_data_xsave>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vp_state_data_xsave))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_state_data_xsave>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data_xsave),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_state_data_xsave>())).states as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_state_data_xsave),
            "::",
            stringify!(states)
        )
    );
}
impl Default for hv_vp_state_data_xsave {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_register_page {
    pub version: __u16,
    pub isvalid: __u8,
    pub rsvdz: __u8,
    pub dirty: __u32,
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_1,
    pub rip: __u64,
    pub rflags: __u64,
    pub __bindgen_anon_2: hv_vp_register_page__bindgen_ty_2,
    pub __bindgen_anon_3: hv_vp_register_page__bindgen_ty_3,
    pub cr0: __u64,
    pub cr3: __u64,
    pub cr4: __u64,
    pub cr8: __u64,
    pub efer: __u64,
    pub dr7: __u64,
    pub pending_interruption: hv_x64_pending_interruption_register,
    pub interrupt_state: hv_x64_interrupt_state_register,
    pub instruction_emulation_hints: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_1 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_1__bindgen_ty_1,
    pub gp_registers: [__u64; 16usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_vp_register_page__bindgen_ty_1__bindgen_ty_1 {
    pub rax: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rbx: __u64,
    pub rsp: __u64,
    pub rbp: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rax
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rcx
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rdx
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rbx
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rsp
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rbp
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rsi
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).rdi
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r8
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r9
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r10
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r11
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r12
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r13
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r14
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1__bindgen_ty_1>())).r15
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(r15)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(hv_vp_register_page__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_1>())).gp_registers as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_1),
            "::",
            stringify!(gp_registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_2 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_2__bindgen_ty_1,
    pub xmm_registers: [hv_u128; 6usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_vp_register_page__bindgen_ty_2__bindgen_ty_1 {
    pub xmm0: hv_u128,
    pub xmm1: hv_u128,
    pub xmm2: hv_u128,
    pub xmm3: hv_u128,
    pub xmm4: hv_u128,
    pub xmm5: hv_u128,
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>())).xmm0
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>())).xmm1
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>())).xmm2
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>())).xmm3
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>())).xmm4
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2__bindgen_ty_1>())).xmm5
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(xmm5)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_2>(),
        96usize,
        concat!("Size of: ", stringify!(hv_vp_register_page__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_2>())).xmm_registers as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_2),
            "::",
            stringify!(xmm_registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_vp_register_page__bindgen_ty_3 {
    pub __bindgen_anon_1: hv_vp_register_page__bindgen_ty_3__bindgen_ty_1,
    pub segment_registers: [hv_x64_segment_register; 6usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_vp_register_page__bindgen_ty_3__bindgen_ty_1 {
    pub es: hv_x64_segment_register,
    pub cs: hv_x64_segment_register,
    pub ss: hv_x64_segment_register,
    pub ds: hv_x64_segment_register,
    pub fs: hv_x64_segment_register,
    pub gs: hv_x64_segment_register,
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>())).es
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>())).cs
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>())).ss
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>())).ds
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>())).fs
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3__bindgen_ty_1>())).gs
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(gs)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_register_page__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page__bindgen_ty_3>(),
        96usize,
        concat!("Size of: ", stringify!(hv_vp_register_page__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_vp_register_page__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page__bindgen_ty_3>())).segment_registers
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page__bindgen_ty_3),
            "::",
            stringify!(segment_registers)
        )
    );
}
impl Default for hv_vp_register_page__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_vp_register_page() {
    assert_eq!(
        ::std::mem::size_of::<hv_vp_register_page>(),
        416usize,
        concat!("Size of: ", stringify!(hv_vp_register_page))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_vp_register_page>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_vp_register_page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).isvalid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(isvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).rsvdz as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(rsvdz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).dirty as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).rip as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).rflags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).cr0 as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).cr3 as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).cr4 as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).cr8 as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(cr8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).efer as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(efer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_vp_register_page>())).dr7 as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(dr7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page>())).pending_interruption as *const _
                as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(pending_interruption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page>())).interrupt_state as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(interrupt_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_vp_register_page>())).instruction_emulation_hints as *const _
                as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_vp_register_page),
            "::",
            stringify!(instruction_emulation_hints)
        )
    );
}
impl Default for hv_vp_register_page {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_partition_synthetic_processor_features {
    pub as_uint64: [__u64; 1usize],
    pub __bindgen_anon_1: hv_partition_synthetic_processor_features__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_partition_synthetic_processor_features__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_synthetic_processor_features__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_synthetic_processor_features__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_synthetic_processor_features__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_synthetic_processor_features__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_synthetic_processor_features__bindgen_ty_1)
        )
    );
}
impl hv_partition_synthetic_processor_features__bindgen_ty_1 {
    #[inline]
    pub fn hypervisor_present(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hypervisor_present(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hv1(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_hv1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_vp_run_time_reg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_vp_run_time_reg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_partition_reference_counter(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_partition_reference_counter(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_synic_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_synic_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_synthetic_timer_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_synthetic_timer_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_intr_ctrl_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_intr_ctrl_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_hypercall_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_hypercall_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_vp_index(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_vp_index(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_partition_reference_tsc(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_partition_reference_tsc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_guest_idle_reg(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_guest_idle_reg(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn access_frequency_regs(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_access_frequency_regs(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z12(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z12(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z13(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z13(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z14(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z14(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_extended_gva_ranges_for_flush_virtual_address_list(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_extended_gva_ranges_for_flush_virtual_address_list(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z16(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z16(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z17(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z17(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_hypercall_output(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_fast_hypercall_output(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z19(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z19(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start_virtual_processor(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_start_virtual_processor(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z21(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z21(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_synthetic_timers(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_direct_synthetic_timers(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_z23(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_reserved_z23(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_processor_masks(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_extended_processor_masks(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tb_flush_hypercalls(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_tb_flush_hypercalls(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synthetic_cluster_ipi(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_synthetic_cluster_ipi(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn notify_long_spin_wait(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_notify_long_spin_wait(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn query_numa_distance(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_query_numa_distance(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn signal_events(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_signal_events(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn retarget_device_interrupt(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_retarget_device_interrupt(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 33u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 33u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hypervisor_present: __u64,
        hv1: __u64,
        access_vp_run_time_reg: __u64,
        access_partition_reference_counter: __u64,
        access_synic_regs: __u64,
        access_synthetic_timer_regs: __u64,
        access_intr_ctrl_regs: __u64,
        access_hypercall_regs: __u64,
        access_vp_index: __u64,
        access_partition_reference_tsc: __u64,
        access_guest_idle_reg: __u64,
        access_frequency_regs: __u64,
        reserved_z12: __u64,
        reserved_z13: __u64,
        reserved_z14: __u64,
        enable_extended_gva_ranges_for_flush_virtual_address_list: __u64,
        reserved_z16: __u64,
        reserved_z17: __u64,
        fast_hypercall_output: __u64,
        reserved_z19: __u64,
        start_virtual_processor: __u64,
        reserved_z21: __u64,
        direct_synthetic_timers: __u64,
        reserved_z23: __u64,
        extended_processor_masks: __u64,
        tb_flush_hypercalls: __u64,
        synthetic_cluster_ipi: __u64,
        notify_long_spin_wait: __u64,
        query_numa_distance: __u64,
        signal_events: __u64,
        retarget_device_interrupt: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hypervisor_present: u64 = unsafe { ::std::mem::transmute(hypervisor_present) };
            hypervisor_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hv1: u64 = unsafe { ::std::mem::transmute(hv1) };
            hv1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let access_vp_run_time_reg: u64 =
                unsafe { ::std::mem::transmute(access_vp_run_time_reg) };
            access_vp_run_time_reg as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let access_partition_reference_counter: u64 =
                unsafe { ::std::mem::transmute(access_partition_reference_counter) };
            access_partition_reference_counter as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let access_synic_regs: u64 = unsafe { ::std::mem::transmute(access_synic_regs) };
            access_synic_regs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let access_synthetic_timer_regs: u64 =
                unsafe { ::std::mem::transmute(access_synthetic_timer_regs) };
            access_synthetic_timer_regs as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let access_intr_ctrl_regs: u64 =
                unsafe { ::std::mem::transmute(access_intr_ctrl_regs) };
            access_intr_ctrl_regs as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let access_hypercall_regs: u64 =
                unsafe { ::std::mem::transmute(access_hypercall_regs) };
            access_hypercall_regs as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let access_vp_index: u64 = unsafe { ::std::mem::transmute(access_vp_index) };
            access_vp_index as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let access_partition_reference_tsc: u64 =
                unsafe { ::std::mem::transmute(access_partition_reference_tsc) };
            access_partition_reference_tsc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let access_guest_idle_reg: u64 =
                unsafe { ::std::mem::transmute(access_guest_idle_reg) };
            access_guest_idle_reg as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let access_frequency_regs: u64 =
                unsafe { ::std::mem::transmute(access_frequency_regs) };
            access_frequency_regs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved_z12: u64 = unsafe { ::std::mem::transmute(reserved_z12) };
            reserved_z12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved_z13: u64 = unsafe { ::std::mem::transmute(reserved_z13) };
            reserved_z13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved_z14: u64 = unsafe { ::std::mem::transmute(reserved_z14) };
            reserved_z14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enable_extended_gva_ranges_for_flush_virtual_address_list: u64 = unsafe {
                ::std::mem::transmute(enable_extended_gva_ranges_for_flush_virtual_address_list)
            };
            enable_extended_gva_ranges_for_flush_virtual_address_list as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved_z16: u64 = unsafe { ::std::mem::transmute(reserved_z16) };
            reserved_z16 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let reserved_z17: u64 = unsafe { ::std::mem::transmute(reserved_z17) };
            reserved_z17 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let fast_hypercall_output: u64 =
                unsafe { ::std::mem::transmute(fast_hypercall_output) };
            fast_hypercall_output as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let reserved_z19: u64 = unsafe { ::std::mem::transmute(reserved_z19) };
            reserved_z19 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let start_virtual_processor: u64 =
                unsafe { ::std::mem::transmute(start_virtual_processor) };
            start_virtual_processor as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved_z21: u64 = unsafe { ::std::mem::transmute(reserved_z21) };
            reserved_z21 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let direct_synthetic_timers: u64 =
                unsafe { ::std::mem::transmute(direct_synthetic_timers) };
            direct_synthetic_timers as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved_z23: u64 = unsafe { ::std::mem::transmute(reserved_z23) };
            reserved_z23 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let extended_processor_masks: u64 =
                unsafe { ::std::mem::transmute(extended_processor_masks) };
            extended_processor_masks as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let tb_flush_hypercalls: u64 = unsafe { ::std::mem::transmute(tb_flush_hypercalls) };
            tb_flush_hypercalls as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let synthetic_cluster_ipi: u64 =
                unsafe { ::std::mem::transmute(synthetic_cluster_ipi) };
            synthetic_cluster_ipi as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let notify_long_spin_wait: u64 =
                unsafe { ::std::mem::transmute(notify_long_spin_wait) };
            notify_long_spin_wait as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let query_numa_distance: u64 = unsafe { ::std::mem::transmute(query_numa_distance) };
            query_numa_distance as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let signal_events: u64 = unsafe { ::std::mem::transmute(signal_events) };
            signal_events as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let retarget_device_interrupt: u64 =
                unsafe { ::std::mem::transmute(retarget_device_interrupt) };
            retarget_device_interrupt as u64
        });
        __bindgen_bitfield_unit.set(31usize, 33u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_synthetic_processor_features() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_synthetic_processor_features>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_synthetic_processor_features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_synthetic_processor_features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_synthetic_processor_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_partition_synthetic_processor_features>())).as_uint64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_synthetic_processor_features),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_synthetic_processor_features {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_register_x64_cpuid_result_parameters {
    pub input: hv_register_x64_cpuid_result_parameters__bindgen_ty_1,
    pub result: hv_register_x64_cpuid_result_parameters__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_register_x64_cpuid_result_parameters__bindgen_ty_1 {
    pub eax: __u32,
    pub ecx: __u32,
    pub subleaf_specific: __u8,
    pub always_override: __u8,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_hv_register_x64_cpuid_result_parameters__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>())).eax
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>())).ecx
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>()))
                .subleaf_specific as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(subleaf_specific)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>()))
                .always_override as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(always_override)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_1>()))
                .padding as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_register_x64_cpuid_result_parameters__bindgen_ty_2 {
    pub eax: __u32,
    pub eax_mask: __u32,
    pub ebx: __u32,
    pub ebx_mask: __u32,
    pub ecx: __u32,
    pub ecx_mask: __u32,
    pub edx: __u32,
    pub edx_mask: __u32,
}
#[test]
fn bindgen_test_layout_hv_register_x64_cpuid_result_parameters__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>())).eax
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>()))
                .eax_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(eax_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>())).ebx
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>()))
                .ebx_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ebx_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>())).ecx
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>()))
                .ecx_mask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(ecx_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>())).edx
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters__bindgen_ty_2>()))
                .edx_mask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters__bindgen_ty_2),
            "::",
            stringify!(edx_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_hv_register_x64_cpuid_result_parameters() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_cpuid_result_parameters>(),
        44usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_cpuid_result_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_cpuid_result_parameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_cpuid_result_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters>())).input as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_cpuid_result_parameters>())).result as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_cpuid_result_parameters),
            "::",
            stringify!(result)
        )
    );
}
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_FAULT:
    hv_unimplemented_msr_action = 0;
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_IGNORE_WRITE_READ_ZERO:
    hv_unimplemented_msr_action = 1;
pub const hv_unimplemented_msr_action_HV_UNIMPLEMENTED_MSR_ACTION_COUNT:
    hv_unimplemented_msr_action = 2;
pub type hv_unimplemented_msr_action = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_register_x64_msr_result_parameters {
    pub msr_index: __u32,
    pub access_type: __u32,
    pub action: __u32,
}
#[test]
fn bindgen_test_layout_hv_register_x64_msr_result_parameters() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_x64_msr_result_parameters>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_x64_msr_result_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_x64_msr_result_parameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_x64_msr_result_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_msr_result_parameters>())).msr_index as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_msr_result_parameters),
            "::",
            stringify!(msr_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_msr_result_parameters>())).access_type
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_msr_result_parameters),
            "::",
            stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_x64_msr_result_parameters>())).action as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_x64_msr_result_parameters),
            "::",
            stringify!(action)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_register_intercept_result_parameters {
    pub cpuid: hv_register_x64_cpuid_result_parameters,
    pub msr: hv_register_x64_msr_result_parameters,
}
#[test]
fn bindgen_test_layout_hv_register_intercept_result_parameters() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_intercept_result_parameters>(),
        44usize,
        concat!(
            "Size of: ",
            stringify!(hv_register_intercept_result_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_intercept_result_parameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_register_intercept_result_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_intercept_result_parameters>())).cpuid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_intercept_result_parameters),
            "::",
            stringify!(cpuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_register_intercept_result_parameters>())).msr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_intercept_result_parameters),
            "::",
            stringify!(msr)
        )
    );
}
impl Default for hv_register_intercept_result_parameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const hv_message_type_HVMSG_NONE: hv_message_type = 0;
pub const hv_message_type_HVMSG_UNMAPPED_GPA: hv_message_type = 2147483648;
pub const hv_message_type_HVMSG_GPA_INTERCEPT: hv_message_type = 2147483649;
pub const hv_message_type_HVMSG_TIMER_EXPIRED: hv_message_type = 2147483664;
pub const hv_message_type_HVMSG_INVALID_VP_REGISTER_VALUE: hv_message_type = 2147483680;
pub const hv_message_type_HVMSG_UNRECOVERABLE_EXCEPTION: hv_message_type = 2147483681;
pub const hv_message_type_HVMSG_UNSUPPORTED_FEATURE: hv_message_type = 2147483682;
pub const hv_message_type_HVMSG_EVENTLOG_BUFFERCOMPLETE: hv_message_type = 2147483712;
pub const hv_message_type_HVMSG_SYNIC_EVENT_INTERCEPT: hv_message_type = 2147483744;
pub const hv_message_type_HVMSG_SYNIC_SINT_INTERCEPT: hv_message_type = 2147483745;
pub const hv_message_type_HVMSG_X64_IO_PORT_INTERCEPT: hv_message_type = 2147549184;
pub const hv_message_type_HVMSG_X64_MSR_INTERCEPT: hv_message_type = 2147549185;
pub const hv_message_type_HVMSG_X64_CPUID_INTERCEPT: hv_message_type = 2147549186;
pub const hv_message_type_HVMSG_X64_EXCEPTION_INTERCEPT: hv_message_type = 2147549187;
pub const hv_message_type_HVMSG_X64_APIC_EOI: hv_message_type = 2147549188;
pub const hv_message_type_HVMSG_X64_LEGACY_FP_ERROR: hv_message_type = 2147549189;
pub const hv_message_type_HVMSG_X64_IOMMU_PRQ: hv_message_type = 2147549190;
pub const hv_message_type_HVMSG_X64_HALT: hv_message_type = 2147549191;
pub const hv_message_type_HVMSG_X64_INTERRUPTION_DELIVERABLE: hv_message_type = 2147549192;
pub const hv_message_type_HVMSG_X64_SIPI_INTERCEPT: hv_message_type = 2147549193;
pub type hv_message_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message_flags {
    pub asu8: __u8,
    pub __bindgen_anon_1: hv_message_flags__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_message_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_message_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_message_flags__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(hv_message_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_flags__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_flags__bindgen_ty_1))
    );
}
impl hv_message_flags__bindgen_ty_1 {
    #[inline]
    pub fn msg_pending(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_pending(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_pending: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_pending: u8 = unsafe { ::std::mem::transmute(msg_pending) };
            msg_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_message_flags() {
    assert_eq!(
        ::std::mem::size_of::<hv_message_flags>(),
        1usize,
        concat!("Size of: ", stringify!(hv_message_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message_flags>())).asu8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_flags),
            "::",
            stringify!(asu8)
        )
    );
}
impl Default for hv_message_flags {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const hv_port_type_HV_PORT_TYPE_MESSAGE: hv_port_type = 1;
pub const hv_port_type_HV_PORT_TYPE_EVENT: hv_port_type = 2;
pub const hv_port_type_HV_PORT_TYPE_MONITOR: hv_port_type = 3;
pub const hv_port_type_HV_PORT_TYPE_DOORBELL: hv_port_type = 4;
pub type hv_port_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_port_id {
    pub asu32: __u32,
    pub u: hv_port_id__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_port_id__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_port_id__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_port_id__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_port_id__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_id__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_port_id__bindgen_ty_1))
    );
}
impl hv_port_id__bindgen_ty_1 {
    #[inline]
    pub fn id(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(id: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_port_id() {
    assert_eq!(
        ::std::mem::size_of::<hv_port_id>(),
        4usize,
        concat!("Size of: ", stringify!(hv_port_id))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_port_id>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_port_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_port_id>())).asu32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_id),
            "::",
            stringify!(asu32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_port_id>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_port_id),
            "::",
            stringify!(u)
        )
    );
}
impl Default for hv_port_id {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_connection_id {
    pub asu32: __u32,
    pub u: hv_connection_id__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct hv_connection_id__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_connection_id__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_connection_id__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hv_connection_id__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_id__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_connection_id__bindgen_ty_1))
    );
}
impl hv_connection_id__bindgen_ty_1 {
    #[inline]
    pub fn id(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(id: __u32, reserved: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_connection_id() {
    assert_eq!(
        ::std::mem::size_of::<hv_connection_id>(),
        4usize,
        concat!("Size of: ", stringify!(hv_connection_id))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_connection_id>(),
        4usize,
        concat!("Alignment of ", stringify!(hv_connection_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_connection_id>())).asu32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_id),
            "::",
            stringify!(asu32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_connection_id>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_connection_id),
            "::",
            stringify!(u)
        )
    );
}
impl Default for hv_connection_id {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message_header {
    pub message_type: __u32,
    pub payload_size: __u8,
    pub message_flags: hv_message_flags,
    pub reserved: [__u8; 2usize],
    pub __bindgen_anon_1: hv_message_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message_header__bindgen_ty_1 {
    pub sender: __u64,
    pub port: hv_port_id,
}
#[test]
fn bindgen_test_layout_hv_message_header__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_message_header__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hv_message_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_header__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_message_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_message_header__bindgen_ty_1>())).sender as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header__bindgen_ty_1),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_message_header__bindgen_ty_1>())).port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header__bindgen_ty_1),
            "::",
            stringify!(port)
        )
    );
}
impl Default for hv_message_header__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_message_header() {
    assert_eq!(
        ::std::mem::size_of::<hv_message_header>(),
        16usize,
        concat!("Size of: ", stringify!(hv_message_header))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message_header>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message_header>())).message_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message_header>())).payload_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message_header>())).message_flags as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(message_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message_header>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message_header),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hv_message_header {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_message {
    pub header: hv_message_header,
    pub u: hv_message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_message__bindgen_ty_1 {
    pub payload: [__u64; 30usize],
}
#[test]
fn bindgen_test_layout_hv_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_message__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(hv_message__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_message__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_message__bindgen_ty_1>())).payload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message__bindgen_ty_1),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for hv_message__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_hv_message() {
    assert_eq!(
        ::std::mem::size_of::<hv_message>(),
        256usize,
        concat!("Size of: ", stringify!(hv_message))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_message>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_message>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_message),
            "::",
            stringify!(u)
        )
    );
}
impl Default for hv_message {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_register_assoc {
    pub name: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
    pub value: hv_register_value,
}
#[test]
fn bindgen_test_layout_hv_register_assoc() {
    assert_eq!(
        ::std::mem::size_of::<hv_register_assoc>(),
        32usize,
        concat!("Size of: ", stringify!(hv_register_assoc))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_register_assoc>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_register_assoc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_assoc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_assoc>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_assoc>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hv_register_assoc>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_register_assoc),
            "::",
            stringify!(value)
        )
    );
}
impl Default for hv_register_assoc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_LOCAL_INTERRUPT_CONTROLLER_STATE:
    hv_get_set_vp_state_type = 0;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_XSAVE: hv_get_set_vp_state_type =
    -2147483647;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_SIM_PAGE: hv_get_set_vp_state_type =
    -2147483646;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_SIEF_PAGE: hv_get_set_vp_state_type =
    -2147483645;
pub const hv_get_set_vp_state_type_HV_GET_SET_VP_STATE_SYNTHETIC_TIMERS: hv_get_set_vp_state_type =
    4;
pub type hv_get_set_vp_state_type = ::std::os::raw::c_int;
pub const hv_vp_state_page_type_HV_VP_STATE_PAGE_REGISTERS: hv_vp_state_page_type = 0;
pub const hv_vp_state_page_type_HV_VP_STATE_PAGE_COUNT: hv_vp_state_page_type = 1;
pub type hv_vp_state_page_type = ::std::os::raw::c_uint;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PRIVILEGE_FLAGS:
    hv_partition_property_code = 65536;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SYNTHETIC_PROC_FEATURES:
    hv_partition_property_code = 65537;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SUSPEND: hv_partition_property_code =
    131072;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_RESERVE: hv_partition_property_code =
    131073;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_CAP: hv_partition_property_code =
    131074;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_WEIGHT: hv_partition_property_code =
    131075;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_CPU_GROUP_ID:
    hv_partition_property_code = 131076;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_TIME_FREEZE: hv_partition_property_code =
    196611;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEBUG_CHANNEL_ID:
    hv_partition_property_code = 262144;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VIRTUAL_TLB_PAGE_COUNT:
    hv_partition_property_code = 327680;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VSM_CONFIG: hv_partition_property_code =
    327681;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ZERO_MEMORY_ON_RESET:
    hv_partition_property_code = 327682;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSORS_PER_SOCKET:
    hv_partition_property_code = 327683;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_NESTED_TLB_SIZE:
    hv_partition_property_code = 327684;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GPA_PAGE_ACCESS_TRACKING:
    hv_partition_property_code = 327685;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_VSM_PERMISSIONS_DIRTY_SINCE_LAST_QUERY : hv_partition_property_code = 327686 ;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_SGX_LAUNCH_CONTROL_CONFIG:
    hv_partition_property_code = 327687;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL0:
    hv_partition_property_code = 327688;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL1:
    hv_partition_property_code = 327689;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL2:
    hv_partition_property_code = 327690;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_DEFAULT_SGX_LAUNCH_CONTROL3:
    hv_partition_property_code = 327691;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_STATE:
    hv_partition_property_code = 327692;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ISOLATION_CONTROL:
    hv_partition_property_code = 327693;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_RDT_L3_COS_INDEX:
    hv_partition_property_code = 327694;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_RDT_RMID: hv_partition_property_code =
    327695;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_IMPLEMENTED_PHYSICAL_ADDRESS_BITS:
    hv_partition_property_code = 327696;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_NON_ARCHITECTURAL_CORE_SHARING:
    hv_partition_property_code = 327697;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_HYPERCALL_DOORBELL_PAGE:
    hv_partition_property_code = 327698;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_UNIMPLEMENTED_MSR_ACTION:
    hv_partition_property_code = 327703;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_VENDOR:
    hv_partition_property_code = 393216;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES_DEPRECATED:
    hv_partition_property_code = 393217;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_XSAVE_FEATURES:
    hv_partition_property_code = 393218;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_CL_FLUSH_SIZE:
    hv_partition_property_code = 393219;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_ENLIGHTENMENT_MODIFICATIONS:
    hv_partition_property_code = 393220;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_COMPATIBILITY_VERSION:
    hv_partition_property_code = 393221;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PHYSICAL_ADDRESS_WIDTH:
    hv_partition_property_code = 393222;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_XSAVE_STATES:
    hv_partition_property_code = 393223;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_MAX_XSAVE_DATA_SIZE:
    hv_partition_property_code = 393224;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_CLOCK_FREQUENCY:
    hv_partition_property_code = 393225;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES0:
    hv_partition_property_code = 393226;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_FEATURES1:
    hv_partition_property_code = 393227;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_GUEST_OS_ID: hv_partition_property_code =
    458752;
pub const hv_partition_property_code_HV_PARTITION_PROPERTY_PROCESSOR_VIRTUALIZATION_FEATURES:
    hv_partition_property_code = 524288;
pub type hv_partition_property_code = ::std::os::raw::c_uint;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_SUCCESS: hv_translate_gva_result_code = 0;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_PAGE_NOT_PRESENT:
    hv_translate_gva_result_code = 1;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_PRIVILEGE_VIOLATION:
    hv_translate_gva_result_code = 2;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_INVALIDE_PAGE_TABLE_FLAGS:
    hv_translate_gva_result_code = 3;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_UNMAPPED: hv_translate_gva_result_code =
    4;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_NO_READ_ACCESS:
    hv_translate_gva_result_code = 5;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_NO_WRITE_ACCESS:
    hv_translate_gva_result_code = 6;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_ILLEGAL_OVERLAY_ACCESS:
    hv_translate_gva_result_code = 7;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_INTERCEPT: hv_translate_gva_result_code = 8;
pub const hv_translate_gva_result_code_HV_TRANSLATE_GVA_GPA_UNACCEPTED:
    hv_translate_gva_result_code = 9;
pub type hv_translate_gva_result_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hv_translate_gva_result {
    pub as_uint64: __u64,
    pub __bindgen_anon_1: hv_translate_gva_result__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_translate_gva_result__bindgen_ty_1 {
    pub result_code: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_hv_translate_gva_result__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_translate_gva_result__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_translate_gva_result__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_translate_gva_result__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_translate_gva_result__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_translate_gva_result__bindgen_ty_1>())).result_code
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_translate_gva_result__bindgen_ty_1),
            "::",
            stringify!(result_code)
        )
    );
}
impl hv_translate_gva_result__bindgen_ty_1 {
    #[inline]
    pub fn cache_type(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cache_type(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn overlay_page(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlay_page(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache_type: __u32,
        overlay_page: __u32,
        reserved: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cache_type: u32 = unsafe { ::std::mem::transmute(cache_type) };
            cache_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let overlay_page: u32 = unsafe { ::std::mem::transmute(overlay_page) };
            overlay_page as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_translate_gva_result() {
    assert_eq!(
        ::std::mem::size_of::<hv_translate_gva_result>(),
        8usize,
        concat!("Size of: ", stringify!(hv_translate_gva_result))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_translate_gva_result>(),
        8usize,
        concat!("Alignment of ", stringify!(hv_translate_gva_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_translate_gva_result>())).as_uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_translate_gva_result),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_translate_gva_result {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_gpa_page_access_state_flags {
    pub __bindgen_anon_1: hv_gpa_page_access_state_flags__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hv_gpa_page_access_state_flags__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state_flags__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state_flags__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_gpa_page_access_state_flags__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state_flags__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_gpa_page_access_state_flags__bindgen_ty_1)
        )
    );
}
impl hv_gpa_page_access_state_flags__bindgen_ty_1 {
    #[inline]
    pub fn clear_accessed(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clear_accessed(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_access(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_set_access(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clear_dirty(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clear_dirty(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_dirty(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_set_dirty(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clear_accessed: __u64,
        set_access: __u64,
        clear_dirty: __u64,
        set_dirty: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clear_accessed: u64 = unsafe { ::std::mem::transmute(clear_accessed) };
            clear_accessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let set_access: u64 = unsafe { ::std::mem::transmute(set_access) };
            set_access as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clear_dirty: u64 = unsafe { ::std::mem::transmute(clear_dirty) };
            clear_dirty as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let set_dirty: u64 = unsafe { ::std::mem::transmute(set_dirty) };
            set_dirty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state_flags() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state_flags>(),
        8usize,
        concat!("Size of: ", stringify!(hv_gpa_page_access_state_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_access_state_flags))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_gpa_page_access_state_flags>())).as_uint64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_gpa_page_access_state_flags),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_gpa_page_access_state_flags {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hv_input_get_gpa_pages_access_state {
    pub partition_id: __u64,
    pub flags: hv_gpa_page_access_state_flags,
    pub hv_gpa_page_number: __u64,
}
#[test]
fn bindgen_test_layout_hv_input_get_gpa_pages_access_state() {
    assert_eq!(
        ::std::mem::size_of::<hv_input_get_gpa_pages_access_state>(),
        24usize,
        concat!("Size of: ", stringify!(hv_input_get_gpa_pages_access_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_input_get_gpa_pages_access_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_input_get_gpa_pages_access_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_input_get_gpa_pages_access_state>())).partition_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_gpa_pages_access_state),
            "::",
            stringify!(partition_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_input_get_gpa_pages_access_state>())).flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_gpa_pages_access_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_input_get_gpa_pages_access_state>())).hv_gpa_page_number
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_input_get_gpa_pages_access_state),
            "::",
            stringify!(hv_gpa_page_number)
        )
    );
}
impl Default for hv_input_get_gpa_pages_access_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_gpa_page_access_state {
    pub __bindgen_anon_1: hv_gpa_page_access_state__bindgen_ty_1,
    pub as_uint8: __u8,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct hv_gpa_page_access_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(hv_gpa_page_access_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_gpa_page_access_state__bindgen_ty_1)
        )
    );
}
impl hv_gpa_page_access_state__bindgen_ty_1 {
    #[inline]
    pub fn accessed(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_accessed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dirty(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dirty(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        accessed: __u8,
        dirty: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let accessed: u8 = unsafe { ::std::mem::transmute(accessed) };
            accessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dirty: u8 = unsafe { ::std::mem::transmute(dirty) };
            dirty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_gpa_page_access_state() {
    assert_eq!(
        ::std::mem::size_of::<hv_gpa_page_access_state>(),
        1usize,
        concat!("Size of: ", stringify!(hv_gpa_page_access_state))
    );
    assert_eq!(
        ::std::mem::align_of::<hv_gpa_page_access_state>(),
        1usize,
        concat!("Alignment of ", stringify!(hv_gpa_page_access_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_gpa_page_access_state>())).as_uint8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_gpa_page_access_state),
            "::",
            stringify!(as_uint8)
        )
    );
}
impl Default for hv_gpa_page_access_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union hv_partition_property_page_access_tracking_config {
    pub __bindgen_anon_1: hv_partition_property_page_access_tracking_config__bindgen_ty_1,
    pub as_uint64: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hv_partition_property_page_access_tracking_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_hv_partition_property_page_access_tracking_config__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_property_page_access_tracking_config__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_property_page_access_tracking_config__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_property_page_access_tracking_config__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_property_page_access_tracking_config__bindgen_ty_1)
        )
    );
}
impl hv_partition_property_page_access_tracking_config__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn granularity(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_granularity(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: __u64,
        granularity: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u64 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let granularity: u64 = unsafe { ::std::mem::transmute(granularity) };
            granularity as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_hv_partition_property_page_access_tracking_config() {
    assert_eq!(
        ::std::mem::size_of::<hv_partition_property_page_access_tracking_config>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hv_partition_property_page_access_tracking_config)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hv_partition_property_page_access_tracking_config>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hv_partition_property_page_access_tracking_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hv_partition_property_page_access_tracking_config>())).as_uint64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hv_partition_property_page_access_tracking_config),
            "::",
            stringify!(as_uint64)
        )
    );
}
impl Default for hv_partition_property_page_access_tracking_config {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const MSHV_PAGE_ACCESS_TRACKING_GRANULARITY_SMALL_PAGES: ::std::os::raw::c_uint = 0;
pub const MSHV_PAGE_ACCESS_TRACKING_GRANULARITY_LARGE_PAGES: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_create_partition {
    pub flags: __u64,
    pub partition_creation_properties: hv_partition_creation_properties,
    pub synthetic_processor_features: hv_partition_synthetic_processor_features,
}
#[test]
fn bindgen_test_layout_mshv_create_partition() {
    assert_eq!(
        ::std::mem::size_of::<mshv_create_partition>(),
        40usize,
        concat!("Size of: ", stringify!(mshv_create_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_create_partition>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_create_partition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_create_partition>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_create_partition>())).partition_creation_properties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(partition_creation_properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_create_partition>())).synthetic_processor_features
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_partition),
            "::",
            stringify!(synthetic_processor_features)
        )
    );
}
impl Default for mshv_create_partition {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Debug, Clone)]
pub struct mshv_user_mem_region {
    pub size: __u64,
    pub guest_pfn: __u64,
    pub userspace_addr: __u64,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_mshv_user_mem_region() {
    assert_eq!(
        ::std::mem::size_of::<mshv_user_mem_region>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_user_mem_region))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_user_mem_region>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_user_mem_region))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_user_mem_region>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_user_mem_region>())).guest_pfn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(guest_pfn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_user_mem_region>())).userspace_addr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(userspace_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_user_mem_region>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_user_mem_region),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mshv_create_vp {
    pub vp_index: __u32,
}
#[test]
fn bindgen_test_layout_mshv_create_vp() {
    assert_eq!(
        ::std::mem::size_of::<mshv_create_vp>(),
        4usize,
        concat!("Size of: ", stringify!(mshv_create_vp))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_create_vp>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_create_vp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_create_vp>())).vp_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_vp),
            "::",
            stringify!(vp_index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_vp_registers {
    pub count: ::std::os::raw::c_int,
    pub regs: *mut hv_register_assoc,
}
#[test]
fn bindgen_test_layout_mshv_vp_registers() {
    assert_eq!(
        ::std::mem::size_of::<mshv_vp_registers>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_vp_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_vp_registers>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_vp_registers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_vp_registers>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_registers),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_vp_registers>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_registers),
            "::",
            stringify!(regs)
        )
    );
}
impl Default for mshv_vp_registers {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_install_intercept {
    pub access_type_mask: __u32,
    pub intercept_type: hv_intercept_type,
    pub intercept_parameter: hv_intercept_parameters,
}
#[test]
fn bindgen_test_layout_mshv_install_intercept() {
    assert_eq!(
        ::std::mem::size_of::<mshv_install_intercept>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_install_intercept))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_install_intercept>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_install_intercept))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_install_intercept>())).access_type_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_install_intercept),
            "::",
            stringify!(access_type_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_install_intercept>())).intercept_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_install_intercept),
            "::",
            stringify!(intercept_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_install_intercept>())).intercept_parameter as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_install_intercept),
            "::",
            stringify!(intercept_parameter)
        )
    );
}
impl Default for mshv_install_intercept {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_assert_interrupt {
    pub control: hv_interrupt_control,
    pub dest_addr: __u64,
    pub vector: __u32,
}
#[test]
fn bindgen_test_layout_mshv_assert_interrupt() {
    assert_eq!(
        ::std::mem::size_of::<mshv_assert_interrupt>(),
        24usize,
        concat!("Size of: ", stringify!(mshv_assert_interrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_assert_interrupt>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_assert_interrupt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_assert_interrupt>())).control as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_assert_interrupt>())).dest_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(dest_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_assert_interrupt>())).vector as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_assert_interrupt),
            "::",
            stringify!(vector)
        )
    );
}
impl Default for mshv_assert_interrupt {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_vp_state {
    pub type_: hv_get_set_vp_state_type,
    pub xsave: hv_vp_state_data_xsave,
    pub buf_size: __u64,
    pub buf: mshv_vp_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mshv_vp_state__bindgen_ty_1 {
    pub lapic: *mut hv_local_interrupt_controller_state,
    pub bytes: *mut __u8,
}
#[test]
fn bindgen_test_layout_mshv_vp_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mshv_vp_state__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mshv_vp_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_vp_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_vp_state__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_vp_state__bindgen_ty_1>())).lapic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_state__bindgen_ty_1),
            "::",
            stringify!(lapic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_vp_state__bindgen_ty_1>())).bytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_state__bindgen_ty_1),
            "::",
            stringify!(bytes)
        )
    );
}
impl Default for mshv_vp_state__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_mshv_vp_state() {
    assert_eq!(
        ::std::mem::size_of::<mshv_vp_state>(),
        40usize,
        concat!("Size of: ", stringify!(mshv_vp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_vp_state>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_vp_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_vp_state>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_state),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_vp_state>())).xsave as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_vp_state>())).buf_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_state),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_vp_state>())).buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_vp_state),
            "::",
            stringify!(buf)
        )
    );
}
impl Default for mshv_vp_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_partition_property {
    pub property_code: hv_partition_property_code,
    pub property_value: __u64,
}
#[test]
fn bindgen_test_layout_mshv_partition_property() {
    assert_eq!(
        ::std::mem::size_of::<mshv_partition_property>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_partition_property))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_partition_property>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_partition_property))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_partition_property>())).property_code as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_partition_property),
            "::",
            stringify!(property_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_partition_property>())).property_value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_partition_property),
            "::",
            stringify!(property_value)
        )
    );
}
impl Default for mshv_partition_property {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_translate_gva {
    pub gva: __u64,
    pub flags: __u64,
    pub result: *mut hv_translate_gva_result,
    pub gpa: *mut __u64,
}
#[test]
fn bindgen_test_layout_mshv_translate_gva() {
    assert_eq!(
        ::std::mem::size_of::<mshv_translate_gva>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_translate_gva))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_translate_gva>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_translate_gva))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_translate_gva>())).gva as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(gva)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_translate_gva>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_translate_gva>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_translate_gva>())).gpa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_translate_gva),
            "::",
            stringify!(gpa)
        )
    );
}
impl Default for mshv_translate_gva {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mshv_irqfd {
    pub fd: __s32,
    pub resamplefd: __s32,
    pub gsi: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_mshv_irqfd() {
    assert_eq!(
        ::std::mem::size_of::<mshv_irqfd>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_irqfd))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_irqfd>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_irqfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_irqfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_irqfd>())).resamplefd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(resamplefd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_irqfd>())).gsi as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(gsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_irqfd>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_irqfd),
            "::",
            stringify!(flags)
        )
    );
}
pub const mshv_ioeventfd_flag_nr_datamatch: ::std::os::raw::c_uint = 0;
pub const mshv_ioeventfd_flag_nr_pio: ::std::os::raw::c_uint = 1;
pub const mshv_ioeventfd_flag_nr_deassign: ::std::os::raw::c_uint = 2;
pub const mshv_ioeventfd_flag_nr_max: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mshv_ioeventfd {
    pub datamatch: __u64,
    pub addr: __u64,
    pub len: __u32,
    pub fd: __s32,
    pub flags: __u32,
    pub pad: [__u8; 4usize],
}
#[test]
fn bindgen_test_layout_mshv_ioeventfd() {
    assert_eq!(
        ::std::mem::size_of::<mshv_ioeventfd>(),
        32usize,
        concat!("Size of: ", stringify!(mshv_ioeventfd))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_ioeventfd>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_ioeventfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_ioeventfd>())).datamatch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(datamatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_ioeventfd>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_ioeventfd>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_ioeventfd>())).fd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_ioeventfd>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_ioeventfd>())).pad as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_ioeventfd),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mshv_msi_routing_entry {
    pub gsi: __u32,
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
}
#[test]
fn bindgen_test_layout_mshv_msi_routing_entry() {
    assert_eq!(
        ::std::mem::size_of::<mshv_msi_routing_entry>(),
        16usize,
        concat!("Size of: ", stringify!(mshv_msi_routing_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_msi_routing_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_msi_routing_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_msi_routing_entry>())).gsi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(gsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_msi_routing_entry>())).address_lo as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(address_lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_msi_routing_entry>())).address_hi as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(address_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_msi_routing_entry>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing_entry),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Default)]
pub struct mshv_msi_routing {
    pub nr: __u32,
    pub pad: __u32,
    pub entries: __IncompleteArrayField<mshv_msi_routing_entry>,
}
#[test]
fn bindgen_test_layout_mshv_msi_routing() {
    assert_eq!(
        ::std::mem::size_of::<mshv_msi_routing>(),
        8usize,
        concat!("Size of: ", stringify!(mshv_msi_routing))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_msi_routing>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_msi_routing))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_msi_routing>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_msi_routing>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_msi_routing>())).entries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_msi_routing),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mshv_register_intercept_result {
    pub intercept_type: __u32,
    pub parameters: hv_register_intercept_result_parameters,
}
#[test]
fn bindgen_test_layout_mshv_register_intercept_result() {
    assert_eq!(
        ::std::mem::size_of::<mshv_register_intercept_result>(),
        48usize,
        concat!("Size of: ", stringify!(mshv_register_intercept_result))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_register_intercept_result>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_register_intercept_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_register_intercept_result>())).intercept_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_intercept_result),
            "::",
            stringify!(intercept_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_register_intercept_result>())).parameters as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_register_intercept_result),
            "::",
            stringify!(parameters)
        )
    );
}
impl Default for mshv_register_intercept_result {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mshv_get_gpa_pages_access_state {
    pub count: __u32,
    pub flags: __u64,
    pub hv_gpa_page_number: __u64,
    pub states: *mut hv_gpa_page_access_state,
}
#[test]
fn bindgen_test_layout_mshv_get_gpa_pages_access_state() {
    assert_eq!(
        ::std::mem::size_of::<mshv_get_gpa_pages_access_state>(),
        28usize,
        concat!("Size of: ", stringify!(mshv_get_gpa_pages_access_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_get_gpa_pages_access_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mshv_get_gpa_pages_access_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_get_gpa_pages_access_state>())).count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_get_gpa_pages_access_state>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_get_gpa_pages_access_state>())).hv_gpa_page_number
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(hv_gpa_page_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mshv_get_gpa_pages_access_state>())).states as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_get_gpa_pages_access_state),
            "::",
            stringify!(states)
        )
    );
}
impl Default for mshv_get_gpa_pages_access_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mshv_create_device {
    pub type_: __u32,
    pub fd: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_mshv_create_device() {
    assert_eq!(
        ::std::mem::size_of::<mshv_create_device>(),
        12usize,
        concat!("Size of: ", stringify!(mshv_create_device))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_create_device>(),
        4usize,
        concat!("Alignment of ", stringify!(mshv_create_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_create_device>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_create_device>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_device),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_create_device>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_create_device),
            "::",
            stringify!(flags)
        )
    );
}
pub const mshv_device_type_MSHV_DEV_TYPE_VFIO: mshv_device_type = 0;
pub const mshv_device_type_MSHV_DEV_TYPE_MAX: mshv_device_type = 1;
pub type mshv_device_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mshv_device_attr {
    pub flags: __u32,
    pub group: __u32,
    pub attr: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_mshv_device_attr() {
    assert_eq!(
        ::std::mem::size_of::<mshv_device_attr>(),
        24usize,
        concat!("Size of: ", stringify!(mshv_device_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<mshv_device_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(mshv_device_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_device_attr>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_device_attr>())).group as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_device_attr>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mshv_device_attr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mshv_device_attr),
            "::",
            stringify!(addr)
        )
    );
}
